<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>first_essay</title>
    <url>/2021/08/25/16-07-33/</url>
    <content><![CDATA[<p>a啊啊啊啊啊啊啊啊啊</p>
]]></content>
  </entry>
  <entry>
    <title>Linux 笔记</title>
    <url>/2021/08/25/16-07-33/</url>
    <content><![CDATA[<p>学习Linux几个月后，总结出来的笔记</p>
<span id="more"></span>

<h2 id="第一章-Linux开山篇"><a href="#第一章-Linux开山篇" class="headerlink" title="第一章 Linux开山篇"></a>第一章 Linux开山篇</h2><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1.1 课程介绍"></a>1.1 课程介绍</h3><p><img src="/2021/08/25/16-07-33/image-20210201173640892.png" alt="image-20210201173640892">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210201173701325.png">–</p>
<p><img src="/2021/08/25/16-07-33/image-20210206104942780.png">-</p>
<h3 id="1-2-Linux-学习方向"><a href="#1-2-Linux-学习方向" class="headerlink" title="1.2 Linux 学习方向"></a>1.2 Linux 学习方向</h3><p>​    运维工程师、嵌入式开发工程师、安全、</p>
<h3 id="1-3-Linux-学习阶段"><a href="#1-3-Linux-学习阶段" class="headerlink" title="1.3 Linux 学习阶段"></a>1.3 Linux 学习阶段</h3><p>​    <strong>第一阶段</strong>：掌握Linux的基本操作命令，包括<u>文件操作命令、vim编辑工具的使用、用户管理命令</u>等。</p>
<p>​    <strong>第二阶段</strong>：掌握Linux的各种配置，包括<u>环境变量、网络、服务配置</u>等。</p>
<p>​    <strong>第三阶段</strong>：掌握Linux下<u>搭建对应语言的开发环境</u>。</p>
<p>​    <strong>第四阶段</strong>：掌握基本的shell命令，能写出shell脚本对服务器进行维护。</p>
<p>​    <strong>第五阶段</strong>：能进行安全设置，防止攻击，保障服务器的正常运行。</p>
<p>​    <strong>第六阶段</strong>：深入理解Linux系统的**<u>内核</u>**，熟练掌握大型网站架构，并熟悉各个环节的部署和维护。</p>
<h2 id="第二章-Linux-基础入门篇"><a href="#第二章-Linux-基础入门篇" class="headerlink" title="第二章 Linux 基础入门篇"></a>第二章 Linux 基础入门篇</h2><h3 id="2-1-安装VMware-和-CentOS"><a href="#2-1-安装VMware-和-CentOS" class="headerlink" title="2.1 安装VMware 和 CentOS"></a>2.1 安装VMware 和 CentOS</h3><h4 id="2-1-1-安装VMware"><a href="#2-1-1-安装VMware" class="headerlink" title="2.1.1 安装VMware"></a>2.1.1 安装VMware</h4><ol>
<li>去<a href="https://www.vmware.com/products/workstation-pro.html">官网</a>下载VMware软件。</li>
<li>双击安装包，一直下一步，直至完成。</li>
<li>有些电脑还需要去BIOS里面修改设置<u><strong>开启虚拟化设备支持</strong></u>。</li>
</ol>
<h4 id="2-1-2-安装CentOS"><a href="#2-1-2-安装CentOS" class="headerlink" title="2.1.2 安装CentOS"></a>2.1.2 安装CentOS</h4><ol>
<li>去<a href="https://www.centos.org/download/">CentOS官网</a>下载需要的镜像文件（若网不好可先下载种子文件，再用迅雷下载）。</li>
<li>镜像下载完后打开VMware，按下<code>ctrl+n</code>键，在弹出的向导页面中选择<strong>典型</strong>，然后下一步，选择<strong>稍后安装操作系统</strong>，再下一步，然后选择<strong>Linux</strong>，版本选择<strong>centos 8 64位</strong>，然后下一步，名称和位置视具体情况决定，磁盘大小选择10G，并且选择<strong>将虚拟磁盘存储为单个文件</strong>，然后下一步，点击<strong>自定义硬件</strong>，内存和处理器<strong>不变</strong>（因为不安装桌面） <code>--&gt;</code> 网络适配器选择<strong>NAT模式</strong> <code>--&gt;</code> 新CD / DVD（IDE）选择<strong>使用ISO映像文件</strong>，点击浏览找到下载好的<strong>镜像文件</strong> <code>--&gt;</code> 删除<strong>打印机</strong>和<strong>USB控制器</strong>，点击<strong>关闭</strong>，点击<strong>完成</strong>。</li>
<li>点击<strong>开启此虚拟机</strong>，选择<code>Install CentOS Linux 8</code>，language中选择<strong>中文</strong>，点击继续，在**<u>本地化</u><strong>选项中，“</strong>键盘<strong>”中点击“</strong>+<strong>”，添加</strong>英语（美国）<strong>，“</strong>语言支持<strong>”中，添加<code>English(United States)</code>，“</strong>时间和日期<strong>”中，选择</strong>亚洲上海<strong>。在</strong><u>软件</u><strong>选项中，“</strong>安装源<strong>”中，输入<code>mirrors.aliyun.com/centos/8/BaseOS/x86_64/os</code>，在“</strong>软件选择<strong>”中，</strong>基本环境<strong>选择</strong>最小安装<strong>，额外环境勾选：</strong>虚拟机代理<strong>、</strong>标准安装<strong>、</strong>开发工具<strong>、</strong>网络服务器<strong>、</strong>安全性工具<strong>、</strong>系统工具<strong>。在</strong><u>系统</u><strong>选项中，“</strong>安装目的地<strong>”中，勾选本地标准磁盘下面的那块磁盘，“</strong>网络和主机名<strong>”中，点击</strong>配置<strong>下的IPv4设置，选择手动，然后输入IP地址等信息，最后点击保存。在</strong><u>用户设置</u><strong>选项中，设置根密码后，再创建一个用户。最后点击</strong><u>开始安装</u>**。</li>
<li>启动此系统后，点击最上面的菜单栏中的<strong>虚拟机</strong>，再点击<strong>安装VMware tools</strong>。</li>
<li>右击库中安装好的CentOS虚拟机，选择<strong>设置</strong>，选择<strong>选项</strong>，在<strong>共享文件夹</strong>栏中，选择<strong>总时启用</strong>，然后在下面的<strong>文件夹</strong>中添加一个（CentOS中的共享文件夹目录是/mnt/hgfs，需要挂载）。</li>
<li>挂载hgfs目录。首先创建此目录<code>mkdir /mnt /hgfs</code>，然后挂载<code>vmhgfs-fuse .host:/ /mnt/hgfs</code>，因为每次开机都需要输入一次，所以下面将创建一个开机自启sh脚本。首先，因为在centos7中/etc/rc.d/rc.local的权限被降低了，所以需要赋予其可执行权：<code>chmod +x /etc/rc.d/rc.local</code>，然后赋予脚本可执行权限（此时脚本的位置为/root/autostart_share.sh）：<code>chmod +x /root/autostart_share.sh</code>，最后打开/etc/rc.d/rc.local文件，在末尾增加如下内容：<code>/root/autostart_share.sh</code>。在Linux下：<img src="/2021/08/25/16-07-33/image-20210201200212681.png" alt="image-20210201200212681">，在window下：<img src="/2021/08/25/16-07-33/image-20210201200335489.png" alt="image-20210201200335489"></li>
<li>安装过程全部结束。</li>
</ol>
<h3 id="2-2-远程登陆-Linux-系统"><a href="#2-2-远程登陆-Linux-系统" class="headerlink" title="2.2 远程登陆 Linux 系统"></a>2.2 远程登陆 Linux 系统</h3><h4 id="2-2-1-为什么要远程登陆？"><a href="#2-2-1-为什么要远程登陆？" class="headerlink" title="2.2.1 为什么要远程登陆？"></a>2.2.1 为什么要远程登陆？</h4><p>​    因为Linux服务器是开发小组共享的，并且正式上线的项目是运行在公网上的，因此需要远程登陆到服务器进行项目的管理或开发。</p>
<h4 id="2-2-2-远程登陆具体流程"><a href="#2-2-2-远程登陆具体流程" class="headerlink" title="2.2.2 远程登陆具体流程"></a>2.2.2 远程登陆具体流程</h4><p>​    openssh服务器由<strong>openssh</strong>、<strong>openssh-server</strong>等软件包提供（默认已安装），并已将sshd添加为标准的系统服务。执行“<code>systemctl start sshd.service</code>”即可按默认配置<strong>启动sshd服务</strong>，包括root在内的大部份用户（只要拥有合法的登录shell）都可以远程登录系统。</p>
<p>​    sshd服务的<strong>配置文件是：/etc/ssh/sshd_config</strong>，ssh服务名称：<strong>sshd</strong>， sshd服务使用的<u><strong>默认端口号为22</strong>（<strong>Port 22</strong>）</u>，必要时建议<strong>修改此端口号</strong>，并指定监听服务的<u><strong>具体IP地址（ListenAddress 192.168.10.1）</strong></u>，以提高在网络中的隐蔽性。</p>
<p>​    SSH协议的版本选用V2比V1的安全性要更好，<u>禁用DNS反向解析（<strong>UseDNS no</strong>）</u>可以提高服务器的响应速度。</p>
<p>​    sshd服务的用户登录控制，通常就<strong>禁止root用户或密码为空</strong>（<strong>PermitRootLogin no</strong>、<strong>PermitEmptyPasswords no</strong> ）的用户登录。另外，可以<strong>限制登录验证的时间（默认为2分钟：LoginGraceTime 2m ）</strong>及<strong>最大重次数（MaxAuthTries 3）</strong>，若超过限制后仍未登录则断开连接。</p>
<p>​    如果只允许或禁止某些用户登录时，可以使用<strong>AllowUsers</strong>或<strong>DenyUsers</strong>配置，两者用法类似（不能同时使用）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AllowUsers    aliyun test@192.168.1.1            </span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许 aliyun 和从 192.168.1.1 登录的 <span class="built_in">test</span> 帐户通过 SSH 登录系统。</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>下载并安装XShell和Xftp软件。</p>
</li>
<li><p>打开XShell后点击<strong>文件</strong>下的<strong>新建</strong>，在弹出的窗口中依次填写：<strong>名称</strong>和<strong>主机</strong>，然后点击<strong>连接</strong>。</p>
</li>
<li><p>若正确连接，则下一步是输入<strong>用户名</strong>和<strong>密码</strong>，之后就连接上了Linux。</p>
<!--特别说明：如果希望安装好 XShell 5 就可以远程访问 Linux 系统的话，需要有一个前提，就是-->
<!--Linux 启用了 SSHD 服务，该服务会监听 22  号端口。--></li>
<li><p>若连接不了，解决方法为：windows的防火墙，总之我不知道。。。。。shit。<strong>2021年2月3日已解决，原因是虚拟机没有默认勾选下面这个选项</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210203180815928.png" alt="image-20210203180815928">-</p>
</li>
</ol>
<p>​    默认情况下root用户是可以通过ssh访问服务器，为了安全起见，应该禁止root用户使用ssh远程连接，正确做法是开放普通用户ssh服务，然后通过普通用户切换到root用户</p>
<p>突然遇到一个问题，关机前还能正常链接ssh，关机后，ping都不行了，网上找了半天的教程都不行，结果</p>
<p><img src="/2021/08/25/16-07-33/image-20210310095933031.png" alt="image-20210310095933031">-</p>
<p><strong>点一下这里，包治百病！！！</strong></p>
<p><strong>找到了另外一种解决方法</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310233457634.png" alt="image-20210310233457634">-</p>
<p>另外一种解决方法：</p>
<p>1、查看虚拟机NAT的网关和子网的地址</p>
<p><img src="/2021/08/25/16-07-33/image-20210324212922709.png" alt="image-20210324212922709">-</p>
<p>2、查看宿主机的VMnet8对应的网卡的IP地址：</p>
<p><img src="/2021/08/25/16-07-33/image-20210324213014750.png" alt="image-20210324213014750">-</p>
<p>IP地址随便设一个！</p>
<p>设置完成后，还需要重启网卡！</p>
<p>或者自动获取也可以</p>
<p>3、就可以了</p>
<!--同样可以解决问题-->

<p>==有时候本来正常的，换个网络就不行了，这时候，只需要把VM8那个网卡禁止然后启用即可解决问题==</p>
<p>ssh登录验证方式：</p>
<p>1、<strong>密码</strong>验证</p>
<p>​    具体不做讲解，因为很简单，直接输入账户和密码即可登录，以服务器中本地系统用户的登录名称、密码进行验证。从客户机角度来看，正在连接的服务器有可能被假冒；从服务器角度来看，当遭遇<strong>密码穷举（暴力破解）攻击</strong>时防御能力较弱。</p>
<p>2、<strong>密钥对</strong>（公钥和私钥）验证</p>
<p>​    要求提供相匹配的密钥信息才能通过验证。通常先在客户中<strong>创建一对密钥文件（公钥、私钥）</strong>,然后将<strong>公钥文件</strong>放到服务器中的指定位置。远程登录时，系统将使用公钥、私钥进行加密/解密关联验证，大增强了远程管理的安全性。公钥（Public Key)与私钥（Privtae Key）的关系如下：</p>
<p>  公钥与私钥是<strong>成对生成</strong>，这两个密钥<strong>互不相同</strong>，可以互相加密与解密。不能根据一个密钥来推算出另一个密钥。公钥对外公开，私钥只有私钥的持有人才知道。</p>
<p>​    公钥与私钥要<strong>配对使用</strong>，如果用公钥对数据进行加密，只有用相对就的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。</p>
<p>​    当<strong>密码验证</strong>与<strong>密钥对验证</strong>都启用时，服务器将优先使用<strong>密钥对验证</strong>。对于安全性要求较高的服务器，<strong>建议将密码验证方式禁用</strong>， 只允许启用密钥对验证方式；若没有特殊要求，则两种方式都可启用。</p>
<p>​    其中，公钥库文件用来保存各客户机上传的公钥文本，以便与客户机本地的私钥文件进行匹配。下面重点说怎么弄<strong>密钥对</strong>：</p>
<p>1、修改配置文件：</p>
<p><strong>PasswordAuthentication yes</strong>           # 启用<strong>密码验证</strong></p>
<p><strong>PubkeyAuthentication yes **          # 启用</strong>密钥对验证**</p>
<p><strong>AuthorizedKeysFile   .ssh/authorized_keys</strong>  # 指定<strong>公钥库数据文件</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210303084029374.png" alt="image-20210303084029374">-</p>
<!--.ssh/authorized_keys 的位置为：/root/.ssh/authorized_keys-->

<p>2、生成密钥对</p>
<p><img src="/2021/08/25/16-07-33/image-20210303083040206.png" alt="image-20210303083040206">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303083204158.png" alt="image-20210303083204158">-</p>
<p>其中：id_rsa 是私钥，而 id_rsa.pub 是公钥，下面需要做的是把私钥复制到Windows中，还是使用Xftp登录root用户，因为不能显示隐藏文件，所以把私钥先复制到/root目录下，然后就能显示了，再拖到Windows桌面即可：<img src="/2021/08/25/16-07-33/image-20210303083630113.png" alt="image-20210303083630113">-</p>
<p>然后将公钥移动并改名为：<code>cp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys</code></p>
<p>然后用XShell进行连接，却报错了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303091530564.png" alt="image-20210303091530564">-</p>
<p>应该是这个文件<img src="/2021/08/25/16-07-33/image-20210303104248619.png" alt="image-20210303104248619">-</p>
<p><strong>原因竟然是因为错吧公钥当私钥复制了，shit，复制错了，应该复制私钥的！！！！</strong></p>
<p>在Linux命令行使用ssh进行远程登录到root用户下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303172537552.png" alt="image-20210303172537552">-</p>
<p>在Windows上使用ssh远程登录到root用户下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303172706132.png" alt="image-20210303172706132">-</p>
<p>假如改了端口的话，还可以加上 -p 选项来指定一个<strong>端口</strong>：<code>ssh -p 2345 student@192.168.75.158</code></p>
<!--注意：格式是 ssh [-p port] user@remote-->

<p><strong>scp远程复制</strong>：</p>
<p>​    使用scp命令可以利用SSH安全连接与远程主机相互复制文件。使用scp命令时，除了必须指定复制源、目标外，还应指定目标主机地址、登录用户，执行后提示验证口令即可。</p>
<p><img src="/2021/08/25/16-07-33/image-20210303174128459.png" alt="image-20210303174128459">-</p>
<p>如果要复制文件夹的话，需要加上 -r 选项：“-r      Recursively copy entire directories.”</p>
<p><img src="/2021/08/25/16-07-33/image-20210303174522347.png" alt="image-20210303174522347">-</p>
<p>在Linux命令行使用ssh进行远程登录到root用户下（使用<strong>密钥对</strong>）：</p>
<p>​    此过程需要准备<strong>两台虚拟机</strong>，或则<strong>克隆</strong>原来的虚拟机！</p>
<ol>
<li><p>使用 <strong>ssh-keygen</strong> 生成密钥对：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304090401665.png" alt="image-20210304090401665">-</p>
<!--注意，此时的 passphrase 没有任何内容，直接回车-->

<!--也可以使用：ssh-keygen -t rsa -f /root/.ssh/id_rsa -N ''-->

<p>可以man ssh-keygen一下，看看具体参数代表的作用</p>
<p>==-t dsa | ecdsa | ed25519 | rsa | rsa1：==</p>
<pre><code>         ==Specifies the type of key to create.  The possible values are “rsa1” for protocol version 1==
         ==and “dsa”, “ecdsa”, “ed25519”, or “rsa” for protocol version 2.==
</code></pre>
<p>==-f filename：Specifies the filename of the key file==</p>
<p>==-N new_passphrase：Provides the new passphrase.==</p>
</li>
<li><p>使用 <strong>ssh-copy-id</strong> 将<strong>公钥</strong>复制到远程<strong>欲登录机器</strong>中：</p>
<p><code>ssh-copy-id -i .ssh/id_rsa.pub  username@192.168.x.xxx</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304090549022.png" alt="image-20210304090549022">-</p>
<!--注意：使用 ssh-copy-id 复制到远程root时，需要输入远程主机root的密码-->

<ol start="3">
<li>使用 <strong>ssh <a href="mailto:&#x75;&#115;&#x65;&#x72;&#x6e;&#x61;&#x6d;&#x65;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#x36;&#56;&#46;&#120;&#x2e;&#120;&#120;&#x78;">&#x75;&#115;&#x65;&#x72;&#x6e;&#x61;&#x6d;&#x65;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#x36;&#56;&#46;&#120;&#x2e;&#120;&#120;&#x78;</a></strong> 登录到<strong>欲登录机器</strong>，<strong>不再输入密码</strong></li>
</ol>
<p><img src="/2021/08/25/16-07-33/image-20210304090621790.png" alt="image-20210304090621790">-</p>
</li>
</ol>
<p><strong>使用 ssh 做端口转发</strong>：</p>
<p>​    这个面试题很重要：<a href="https://www.cnblogs.com/f-ck-need-u/p/10482832.html#13-ssh%E5%AE%89%E5%85%A8%E9%9A%A7%E9%81%93%E4%B8%89%EF%BC%9A%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91socks%E4%BB%A3%E7%90%86">https://www.cnblogs.com/f-ck-need-u/p/10482832.html#13-ssh%E5%AE%89%E5%85%A8%E9%9A%A7%E9%81%93%E4%B8%89%EF%BC%9A%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91socks%E4%BB%A3%E7%90%86</a></p>
<h4 id="2-2-3-TCP-Wrappers"><a href="#2-2-3-TCP-Wrappers" class="headerlink" title="2.2.3 TCP Wrappers"></a>2.2.3 TCP Wrappers</h4><p>​    在Linux系统中，许多网络服务针对客户机提供了某种<strong>访问控制机制</strong>，如samba、BIND、Httpd、OpenSSH等，除此之外还有一种防护机制—<strong>TCP Wrappers</strong>（TCP封套），以作为应用服务与网络之间的一道<strong>特殊防线</strong>，提供额外的安全保障。TCP Wrappers将其他的TCP服务程序“包裹”起来，增加了一个安全检测过程，<strong>外来的连接请求必须先通过这层安全检测</strong>，获得许可后才能访问真正的服务程序。TCP Wrappers还可以<strong>记录</strong>所有企图访问被保护服务的行为，为管理员提供丰富的安全分析资料。TCP Wrappers的访问控制是<strong>基于TCP协议</strong>的应用服务。</p>
<p><img src="/2021/08/25/16-07-33/image-20210303175805799.png" alt="image-20210303175805799">-</p>
<p>​    相对于<strong>iptables防火墙</strong>访问控制规则，TCP Wrappers的<strong>配置更简单</strong>。</p>
<p>​    但是TCP Wrappers也<strong>有两个缺点</strong>：</p>
<p>​        第一，TCP Wrappers只能控制<strong>TCP协议</strong>的应用服务；</p>
<p>​        第二，并不是所有基于TCP协议的应用服务都能接受TCP Wrappers控制。对于大多数Linux发行版，TCP Wrappers是默认提供的功能。</p>
<p><strong>TCP Wrappers 的访问策略</strong>：</p>
<p>​    TCP Wrappers机制的保护对象为种网络服务程序，针对访问服务的客户机地址进行访问控制。对应的两个策略文件为**/etc/hosts.allow<strong>和</strong>/etc/hosts.deny<strong>，分别用来设置</strong>允许<strong>和</strong>拒绝**的策略</p>
<p>​    <strong>策略的配置格式</strong>：**&lt;服务程序列表&gt;:&lt;客户机地址列表&gt;**</p>
<p>​    <!--注意：虽然有允许和拒绝两个策略，但是他们的格式都是一样--></p>
<p>​    <!--服务程序列表、客户机地址列表之间以冒号分隔，在每个表内的多个项之间以逗号分隔--></p>
<p>​    <strong>服务程序列表</strong>：</p>
<table>
<thead>
<tr>
<th align="center">服务</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALL</td>
<td align="center">代表所以的服务</td>
</tr>
<tr>
<td align="center">单个服务程序</td>
<td align="center">如：sshd</td>
</tr>
<tr>
<td align="center">多个服务程序组成的列表</td>
<td align="center">如：sshd、vsftpd</td>
</tr>
</tbody></table>
<p>​    <strong>客户机地址列表</strong>：</p>
<table>
<thead>
<tr>
<th align="center">服务</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALL</td>
<td align="center">代表任何客户机地址</td>
</tr>
<tr>
<td align="center">LOCAL</td>
<td align="center">代表本机地址</td>
</tr>
<tr>
<td align="center">单个IP地址</td>
<td align="center">如：192.168.75.158</td>
</tr>
<tr>
<td align="center">网络地址段</td>
<td align="center">如：192.168.75.0/255.255.255.0</td>
</tr>
<tr>
<td align="center">以“.”开始的域名</td>
<td align="center">如“.kgc.cn”匹配域中的所有主机</td>
</tr>
<tr>
<td align="center">以“.”结束的网络地址</td>
<td align="center">如192.168.75.匹配整个192.168.75.0/24网段</td>
</tr>
<tr>
<td align="center">嵌入通配符“*” 和 “？”</td>
<td align="center">前者代表任意长度字符，后者仅代表一个字符；如”10.0.8.2*”匹配以10.0.8.2开头的所有IP地址。不可与以“.”开始或结束的模式混用。</td>
</tr>
<tr>
<td align="center">多个客户机地址组成的列表</td>
<td align="center">如“192.168.1.,172.17.17.，.kgc.cn”</td>
</tr>
</tbody></table>
<p><strong>访问控制的基本原则</strong>：</p>
<p>关于TCP Wrappers机制的访问策略，应用时遵循以下顺序和原则：</p>
<p>​    首先检查**/etc/hosts.allow<strong>文件，如果匹配则</strong>允许访问**；</p>
<p>​    否则继续检查**/etc/hosts.deny<strong>文件，如果匹配则</strong>拒绝访问**；</p>
<p>​    <strong>如果上述两个文件都没有匹配，则允许访问</strong></p>
<p><strong>TCP Wrappers配置实例</strong>：</p>
<p>​    实际应用TCP Wrappers机制时，较宽松的策略可以是“允许所有，拒绝个别”，只在hosts.deny文件中添加拒绝策略就可以了。较严格策略是“允许个别，拒绝所有”，除了在hosts.allow中添加允许策略外还需要在hosts.deny文件中设置“ALL：ALL”的拒绝策略。</p>
<p><strong>实例</strong>：</p>
<p>问题：进制IP地址为：192.168.30.134的主机访问sshd服务</p>
<p><strong>在测试之前</strong>，应该先判断服务程序是否能够由tcp_wrapper进行访问控制的方法：</p>
<p><code>ldd /PATH/TO/PROGRAM|grep libwrap.so</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303192155143.png" alt="image-20210303192155143">-</p>
<p>上面表示<strong>没有</strong>，那么需要下载：<code>yum install -y tcp_wrappers</code></p>
<p>然后编辑拒绝访问名单：<code>vim /etc/hosts.deny</code></p>
<!--注：这2个文件改完立即生效同iptables-->

<!--未完待续，还没理解清楚-->

<!--注意：在CentOS 8 这个版本，TCP Wrappers 是不能用的，因为和防火墙起冲突了-->

<h2 id="第三章-Linux基础篇"><a href="#第三章-Linux基础篇" class="headerlink" title="第三章 Linux基础篇"></a>第三章 Linux基础篇</h2><h3 id="3-1-Linux的目录结构"><a href="#3-1-Linux的目录结构" class="headerlink" title="3.1 Linux的目录结构"></a>3.1 Linux的目录结构</h3><h4 id="3-1-1-基本介绍"><a href="#3-1-1-基本介绍" class="headerlink" title="3.1.1 基本介绍"></a>3.1.1 基本介绍</h4><p>​    linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录，总之记住一句话：**<u><em>在Linux世界里，一切皆为文件</em></u>**。</p>
<p><img src="/2021/08/25/16-07-33/image-20210201200803211.png" alt="image-20210201200803211">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210201212921968.png" alt="image-20210201212921968">-</p>
<h4 id="3-1-2-具体介绍"><a href="#3-1-2-具体介绍" class="headerlink" title="3.1.2 具体介绍"></a>3.1.2 具体介绍</h4><p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301191924569.png" alt="image-20210301191924569">-</p>
<p><strong>【】</strong>：提示符的分隔符号，没有特殊含义</p>
<p><strong>root</strong>：显示当前的登录用户</p>
<p>**@**：分隔符号，没有特殊含义</p>
<p>**~**：代表当前所在的目录</p>
<p>**#<strong>：命令提示符，超级用户是</strong>#**，普通用户是$</p>
<ol>
<li><h5 id="bin、-sbin、-usr-bin、-usr-sbin、-usr-local"><a href="#bin、-sbin、-usr-bin、-usr-sbin、-usr-local" class="headerlink" title="/bin、/sbin、/usr/bin、/usr/sbin、/usr/local"></a>/bin、/sbin、/usr/bin、/usr/sbin、/usr/local</h5><p>bin是<strong>binary</strong>的简写，</p>
<ul>
<li><em><strong>/bin</strong></em>目录存放着<strong>普通用户和超级用户</strong>都会用到的必要的命令，如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</li>
<li><em><strong>/sbin</strong></em>目录存放着<strong>系统管理员</strong>使用的必要的来管理系统的命令，s 就是 <strong>Super User</strong> 的意思，是 <strong>Superuser Binaries</strong> (超级用户的二进制文件) 的缩写。</li>
<li><em><strong>/usr/bin</strong></em>目录主要放置一些<strong>应用软件工具</strong>的必备执行档，如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 zip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。</li>
<li><em><strong>/usr/sbin</strong></em>目录主要放置一些网路管理的必备程序例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。</li>
<li><em><strong>/usr/local</strong></em>目录是另外一个给主机额外<strong>安装软件</strong>的目录，一般安装的是通过编译源码方式安装的程序。</li>
</ul>
<!--如果这是用户和管理员必备的二进制文件，就会放在/bin。如果这是系统管理员必备，但是一般用户根本不会用到的二进制文件，就会放在 /sbin。-->
<!--相对而言。如果不是用户必备的二进制文件，多半会放在/usr/bin；如果不是系统管理员必备的工具，多半会放在/usr/sbin。--></li>
<li><h5 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h5><p>用于存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户的账户名命名。</p>
</li>
<li><h5 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h5><p>该目录为系统管理员的主目录。</p>
</li>
<li><h5 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h5><p>是引导分区，也就是引导操作系统启动的程序所在的分区，存放的是<strong>启动Linux</strong>时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><h5 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h5><p><strong>processes</strong>的缩写，这个目录是一个虚拟的目录，它是系统内存的映射，可以访问这个目录来获取系统信息。</p>
</li>
<li><h5 id="srv"><a href="#srv" class="headerlink" title="/srv"></a>/srv</h5><p><strong>service</strong>的缩写，该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><h5 id="sys"><a href="#sys" class="headerlink" title="/sys"></a>/sys</h5><p><strong>system</strong>的缩写，存放内存中的数据，如内核、文件系统等。</p>
<p><img src="/2021/08/25/16-07-33/image-20210201212158424.png" alt="image-20210201212158424">-</p>
</li>
<li><h5 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h5><p><strong>temporary</strong>的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><h5 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h5><p><strong>device</strong>的缩写，类似于window的设备管理器，把所有的硬件用文件的形式存储。</p>
</li>
<li><h5 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h5><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><h5 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h5><p><strong>mount</strong>的缩写，系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><h5 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h5><p><strong>optional</strong>的缩写，这是给主机额外<strong>安装软件</strong>所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><h5 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h5><p><strong>unix system  resources</strong> 的缩写，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><h5 id="usr-src"><a href="#usr-src" class="headerlink" title="/usr/src"></a>/usr/src</h5><p><strong>source</strong>的缩写，内核源代码默认的放置位置。</p>
</li>
<li><h5 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h5><p><strong>variable</strong>的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><h5 id="run"><a href="#run" class="headerlink" title="/run"></a>/run</h5><p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
<li><h5 id="selinux"><a href="#selinux" class="headerlink" title="/selinux"></a>/selinux</h5><p>这个目录是 <u><strong>Redhat/CentOS 所特有的目录</strong></u>，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
</ol>
<h3 id="3-2-Linux的目录挂载"><a href="#3-2-Linux的目录挂载" class="headerlink" title="3.2 Linux的目录挂载"></a>3.2 Linux的目录挂载</h3><p>​    见后面章节</p>
<h2 id="第四章-Linux常用命令篇"><a href="#第四章-Linux常用命令篇" class="headerlink" title="第四章 Linux常用命令篇"></a>第四章 Linux常用命令篇</h2><h3 id="4-1-文件处理命令"><a href="#4-1-文件处理命令" class="headerlink" title="4.1 文件处理命令"></a>4.1 文件处理命令</h3><h4 id="4-1-1-目录处理命令"><a href="#4-1-1-目录处理命令" class="headerlink" title="4.1.1 目录处理命令"></a>4.1.1 目录处理命令</h4><ol>
<li><p>ls – 显示目录文件</p>
<p>ls 的英文原意为：<strong>list</strong></p>
<p><u>ls 所在路径：/bin/ls</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203141930217.png" alt="image-20210203141930217">-</p>
<!--“-a 显示所有文件，包括隐藏文件、-l 详细信息、-d 查看目录属性、-h以人看得懂的方式显示大小”-->

<p>注意：ls 是统计文件的”逻辑”大小，而du才是真是大小</p>
</li>
<li><p>mkdir – 创建新目录</p>
<p>mkdir 的英文原意为：<strong>make directories</strong></p>
<p><u>mkdir 所在路径：/bin/mkdir</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203142119846.png" alt="image-20210203142119846">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203142208579.png" alt="image-20210203142208579">-</p>
<!--"-p 递归创建"-->

<p>批量创建目录：<code>mkdir -pv /mnt/sysroot/&#123;etc/rc.d, usr, var, proc, sys, dev, lib, lib64, bin, sbin, boot, srv, mnt, media, home, root&#125;</code></p>
<!--“-v 打印已经创建的目录”--></li>
<li><p>mkdir – 创建新目录</p>
<p>rmdir 的英文原意为：<strong>remove empty directories</strong></p>
<p><u>rmdir 所在路径：/bin/rmdir</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203142506130.png" alt="image-20210203142506130">-</p>
</li>
<li><p>cd – 切换目录</p>
<p>cd 的英文原意为：<strong>change directory</strong></p>
<p><u>cd 所在路径：shell内置命令</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203142635828.png" alt="image-20210203142635828">-</p>
<!--cd ~ 或者cd为回到家目录、cd .. 回到上一级目录--></li>
<li><p>pwd – 显示当前目录</p>
<p>pwd 的英文原意为：<strong>print working directory</strong></p>
<p><u>pwd 所在路径：/bin/pwd</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203142940179.png" alt="image-20210203142940179">-</p>
</li>
<li><p>cp – 复制文件或目录</p>
<p>cp 的英文原意为：<strong>copy</strong></p>
<p><u>pwd 所在路径：/bin/cp</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203143118714.png" alt="image-20210203143118714">-</p>
<!--将文件x复制到上级目录-->

<!--“-r 复制目录、-p保留文件属性”-->

<!---a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合--></li>
<li><p>mv – 剪切文件、改名</p>
<p>mv 的英文原意为：<strong>move</strong></p>
<p><u>mv 所在路径：/bin/mv</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203143416163.png" alt="image-20210203143416163">-</p>
<!--上面执行的命令只是改了个名--></li>
<li><p>rm – 删除文件</p>
<p>rm 的英文原意为：<strong>remove</strong></p>
<p><u>rm 所在路径：/bin/rm</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203143645871.png" alt="image-20210203143645871">-</p>
<!--"-r 删除目录、-f 强制执行"--></li>
<li><p>echo – 输出内容到控制台</p>
<p><u>echo 所在路径：/usr/bin/echo</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210207121811027.png" alt="image-20210207121811027">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207121832713.png" alt="image-20210207121832713">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207121903117.png" alt="image-20210207121903117">-</p>
<!--用 echo 输出环境变量--></li>
</ol>
<h4 id="4-1-2-文件处理命令"><a href="#4-1-2-文件处理命令" class="headerlink" title="4.1.2 文件处理命令"></a>4.1.2 文件处理命令</h4><ol>
<li><p>touch – 创建空文件</p>
<p><u>touch 所在路径：/bin/touch</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203132558307.png" alt="image-20210203132558307">-</p>
</li>
<li><p>cat – 显示文件内容</p>
<p><u>cat 所在路径：/bin/cat</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203132839818.png" alt="image-20210203132839818">-</p>
<!--“-n 显示行号”-->

<p><strong>执行脚本的时候，需要往一个文件里自动输入N行内容。如果是少数几行，可以使用echo进行追加，如果是多行内容，再用echo追加就不合适了，这个时候就可以使用EOF结合cat进行内容的追加了</strong></p>
<p><strong>EOF是END OF FILE的缩写，表示自定义终止符。既然是自定义，那么EOF就不是固定的，可以随意设置别名，在Linux中按ctrl+d就可以代表EOF</strong></p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;&lt;EOF        //开始</span><br><span class="line">....</span><br><span class="line">EOF          //结束</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210311093927652.png" alt="image-20210311093927652">-</p>
<p>这个就是将EOF 文字 EOF，中的内容传给cat，所以下面会打印出来，既然能打印出来，那么也可以接着传给另外一个文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210311094206114.png" alt="image-20210311094206114">-</p>
<p>类似于这样！</p>
<p>所以说可以这样：</p>
<p><img src="/2021/08/25/16-07-33/image-20210311094307630.png" alt="image-20210311094307630">-</p>
<!--瞧瞧这个诡异的语法！-->

<p>一键自动化分区 &amp; 挂载分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">fdisk /dev/硬盘名 &lt;&lt; EOF # 格式化</span><br><span class="line">n</span><br><span class="line">p</span><br><span class="line">1</span><br><span class="line">wq</span><br><span class="line">EOF</span><br><span class="line">mkfs -t ext4 /dev/硬盘名  # 格式化</span><br><span class="line">mkdir /mnt/硬盘名 # 创建需要挂载到哪个目录</span><br><span class="line">mount /dev/硬盘名 /mnt/硬盘名 # 挂载</span><br></pre></td></tr></table></figure>

<!--注意：上面的n、p、1等都是进入fdisk以后需要输入的！--></li>
<li><p>tac – 倒序显示文件内容</p>
<p><u>tac 所在路径：/usr/bin/tac</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203133247557.png" alt="image-20210203133247557">-</p>
</li>
<li><p>more – 分页显示文件内容</p>
<p><u>more 所在路径：/bin/more</u></p>
<p><code>more /etc/services</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210203133451712.png" alt="image-20210203133451712">-</p>
<!--"使用more后，未显示完的话，最下面会显示more，然后可以通过按空格或f键翻页，或者回车键换行，q退出"--></li>
<li><p>less – 分页显示文件内容（可向上翻页）</p>
<p><u>less 所在路径：/usr/bin/less</u></p>
<p><code>less /etc/services</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210203134245780.png" alt="image-20210203134245780">-</p>
<!--俗话说“less is more”，less命令比more要强一点，支持各种显示终端，不是一次性加载整个文件，所以效率比more高，适合查看大文件--></li>
<li><p>head – 显示文件前几行</p>
<p><u>head 所在路径：/usr/bin/head</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203134656978.png" alt="image-20210203134656978">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203134856830.png" alt="image-20210203134856830">-</p>
<!--默认显示前10行的内容，-n 指定行数--></li>
<li><p>tail – 显示文件后几行</p>
<p><u>tail 所在路径：/usr/bin/tail</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203135241422.png" alt="image-20210203135241422">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203135316179.png" alt="image-20210203135316179">-</p>
<!--默认显示后10行的内容，-n 指定行数，-f动态显示文件末尾内容--></li>
<li><p>chattr – </p>
</li>
<li><p>输出 <u>重定向   <strong>&gt;</strong></u>   和 <u>追加   <strong>&gt;&gt;</strong></u>   指令</p>
<table>
<thead>
<tr>
<th align="center">设备名</th>
<th align="center">说明</th>
<th align="center">描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/dev/stdin</td>
<td align="center">输入文件—标准输入</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">/dev/sdtout</td>
<td align="center">输出文件—标准输出</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">/dev/sdterr</td>
<td align="center">错误输出文件—标准错误输出</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>详解：<a href="https://blog.csdn.net/world_zheng/article/details/83110029?dist_request_id=1328626.12903.16153840823154491&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">https://blog.csdn.net/world_zheng/article/details/83110029?dist_request_id=1328626.12903.16153840823154491&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p>
<p>&gt;指令是<strong>覆盖写</strong>：ls -l &gt; a.txt 将列表内容覆盖写入到a.txt中</p>
<p>&gt;&gt;指令是<strong>追加</strong>：ls -l &gt;&gt; a.txt 将列表内容追加到a.txt末尾</p>
<p>2&gt;指令是<strong>将错误消息</strong>覆盖写到XX里面（ 2&gt;&gt; 是追加）：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310220140521.png" alt="image-20210310220140521">-</p>
<p>命令输出的结果包含<strong>正常执行信息</strong>和<strong>错误信息</strong>两类，可使用&gt;和 2&gt;分别输出到不同的文 件，也可使用**&amp;&gt;**操作</p>
<p>符将两类<strong>输出信息保存到同一个文件</strong>。</p>
<p>例如，同时查看一个存在（内容为：<strong>我是a.txt</strong>）和一个不存在的文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210310220947319.png" alt="image-20210310220947319">-</p>
<p>现在将正确的输出内容重定向到b.txt，将错误的输出内容重定向到c.txt：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310221105889.png" alt="image-20210310221105889">-</p>
<p>将正确和错误的内容都统一重定向到<strong>同一个文件</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310221207359.png" alt="image-20210310221207359">-</p>
<p>忽略错误的消息（也就是将错误消息定向到:<strong>/dev/null</strong>）：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310221425601.png" alt="image-20210310221425601">-</p>
</li>
<li><p>alias – 查看别名</p>
<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301174417639.png" alt="image-20210301174417639">-</p>
<!--仅输入alias是查看别名，但是alias 别名='原命令'-->

<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301175234528.png" alt="image-20210301175234528">-</p>
</li>
<li><p>stat – 显示文件或文件系统的详细信息</p>
<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301181254270.png" alt="image-20210301181254270">-</p>
</li>
<li><p>wc – 用于计算字数</p>
<p>格式：wc [-clw][–help][–version][文件…]</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c或-bytes或-chars</td>
<td>显示大小，Bytes数</td>
</tr>
<tr>
<td>-l或–lines</td>
<td>显示行数</td>
</tr>
<tr>
<td>-w或–words</td>
<td>只显示字数</td>
</tr>
<tr>
<td>–help</td>
<td>在线帮助</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210310212145448.png" alt="image-20210310212145448">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210310212201788.png" alt="image-20210310212201788">-</p>
<!--由上图可见，果然是字节数--></li>
<li><p>cut</p>
</li>
<li><p>awk – 工具</p>
</li>
<li><p>sed – 工具</p>
</li>
</ol>
<h4 id="4-1-3-链接命令"><a href="#4-1-3-链接命令" class="headerlink" title="4.1.3 链接命令"></a>4.1.3 链接命令</h4><p>ln的英文原意为：<strong>link</strong></p>
<p><u>ln所在路径为：/bin/ln</u></p>
<ol>
<li><p>创建软连接</p>
<p><code>ln -s /etc/issue chen</code> – 创建文件/etc/issue的软链接chen</p>
<p><img src="/2021/08/25/16-07-33/image-20210203131124785.png" alt="image-20210203131124785">-</p>
<!--l表示软连接、软链接文件权限都是rwxrwxrwx、文件大小只是符号链接的大小不是原文件的大小--></li>
<li><p>创建硬链接</p>
<p><code>ln /etc/issue hao</code> – 创建文件/etc/issue的硬链接hao</p>
<p><img src="/2021/08/25/16-07-33/image-20210203131354496.png" alt="image-20210203131354496">-</p>
<!--硬链接=拷贝cp -p + 同步更新、不能跨分区、不能对目录使用，可以通过i节点实别--></li>
</ol>
<h3 id="4-2-文件搜索命令"><a href="#4-2-文件搜索命令" class="headerlink" title="4.2 文件搜索命令"></a>4.2 文件搜索命令</h3><ol>
<li><p>find – 文件搜索</p>
<p><u>find 所在路径：/bin/find</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203160425282.png" alt="image-20210203160425282">-</p>
<!--find / -size +10240：查找在根目录下大于10240的文件-->

<p><img src="/2021/08/25/16-07-33/image-20210203160546097.png" alt="image-20210203160546097">-</p>
<!--find /home/ -user chen：查找在home目录下梭有着为chen的文件-->

<p><img src="/2021/08/25/16-07-33/image-20210203160619374.png" alt="image-20210203160619374">-</p>
<!--find /bin/ -name find：查找在bin目录下文件名为find的文件-->

<p><img src="/2021/08/25/16-07-33/image-20210203161032478.png" alt="image-20210203161032478">-</p>
<!--find . -cmin -5：查找5分钟内被修改过属性的文件和目录-->

<!--amin 访问时间（access）、cmin 文件属性（change）、mmin 文件内容（modify）-->

<p><img src="/2021/08/25/16-07-33/image-20210203161315937.png" alt="image-20210203161315937">-</p>
<!--查找在etc目录下大于1024**并且**小于2048的文件-->

<!--”-a 表示同时满足、-o 表示满足其中一个“-->

<p><img src="/2021/08/25/16-07-33/image-20210203162134099.png" alt="image-20210203162134099">-</p>
<!--查找在root目录下类型为文件的文件-->

<!--f：文件、d：目录、l：软链接文件--></li>
<li><p>locate – 在文件资料库中查找文件</p>
<p><u>locate 所在路径：/usr/bin/locate</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203162700303.png" alt="image-20210203162700303">-</p>
<!--由于locate指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb命令创建locate数据库-->

<!--修改updatedb文件：vi /etc/update.conf-->

<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301192902973.png" alt="image-20210301192902973">-</p>
</li>
<li><p>which – 搜索命令所在目录及别名信息</p>
<p><u>which 所在路径：/usr/bin/which</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203162855923.png" alt="image-20210203162855923">-</p>
<!--alias：别名--></li>
<li><p>whereis – 搜索命令所在目录及帮助文档路径</p>
<p><u>whereis 所在路径：/usr/bin/whereis</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203163145500.png" alt="image-20210203163145500">-</p>
</li>
<li><p>grep – 在文件中搜寻字串匹配的行并输出</p>
<p><u>grep 所在路径：/bin/grep</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203163508172.png" alt="image-20210203163508172">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203163430888.png" alt="image-20210203163430888">-</p>
<!--"-i 不区分大小写、-v 排除指定字串、-n 显示匹配行及行号"-->

<!--grep 通常是 用于管道符 “|” 后面--></li>
<li><p>history – 查看过往使用过的命令</p>
<p><img src="/2021/08/25/16-07-33/image-20210311120419663.png" alt="image-20210311120419663">- </p>
<p>修改history记录的条数：<code>vim /etc/profile</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210311120723789.png" alt="image-20210311120723789">-</p>
<!--又配置文件可见，默认是1000条！--></li>
<li><p>| – 管道命令</p>
<p>格式：<strong>命令1 | 命令2 | …</strong></p>
<p>位于管道符号”|”左边的命令输出的结果，将作为右侧命令的输入（处理对象），同一行命令 中可以使用多个管道</p>
<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301180306147.png" alt="image-20210301180306147">-</p>
</li>
</ol>
<h3 id="4-3-压缩-amp-解压命令"><a href="#4-3-压缩-amp-解压命令" class="headerlink" title="4.3 压缩&amp;解压命令"></a>4.3 压缩&amp;解压命令</h3><ol>
<li><p>gzip – 压缩文件</p>
<p>gzip 的英文原意为：<strong>GNU zip</strong></p>
<!--注：GNU是很多年前发起的一个免费软件项目-->

<p><u>gzip 所在路径：/bin/gzip</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203170434255.png" alt="image-20210203170434255">-</p>
<!--gzip不能压缩目录，并且会删除源文件，压缩后的文件格式为.gz--></li>
<li><p>gunzip – 解压”.gz”文件</p>
<p><u>gunzip 所在路径：/bin/gunzip</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203170806199.png" alt="image-20210203170806199">-</p>
</li>
<li><p>tar – 打包<strong>目录</strong></p>
<p>tar 的英文原意为：<strong>tape archive</strong></p>
<p><u>tar 所在路径：/bin/tar</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203171306831.png" alt="image-20210203171306831">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203172303689.png" alt="image-20210203172303689">-</p>
<!--将目录yasuo打包并压缩为.tar.gz文件-->

<p><strong><!--使用tar会保留源文件--></strong></p>
<!--”-c 打包、-x 解包、-v 显示详细信息、-f 指定文件名、-z 打包同时压缩（-z 在有x时是解压缩的意思）“-->

<!--解压：tar -zxvf 压缩文件--></li>
<li><p>zip – 压缩文件或目录</p>
<p><u>zip 所在目录：/usr/bin/zip</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203172546005.png" alt="image-20210203172546005">-</p>
<!--上面的格式：zip -r 压缩后的名字 目录名-->

<p><strong><!--使用zip会保留源文件--></strong></p>
<!--"-r 压缩目录"--></li>
<li><p>unzip – 解压.zip文件</p>
<p><u>unzip 所在目录：/usr/bin/unzip</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203173046142.png" alt="image-20210203173046142">-</p>
</li>
<li><p>bzip2 – 压缩文件</p>
<p>bzip2 的英文原意为：<strong>bunzip2</strong></p>
<p><u>bzip2 所在路径：/usr/bin/bzip2</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203173514791.png" alt="image-20210203173514791">-</p>
<!--只能用于压缩文件-->

<!--”-k 保留源文件“--></li>
<li><p>bunzip2 – 解压.bz2文件</p>
<p><u>bunzip2 所在路径：/usr/bin/bunzip2</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203173746599.png" alt="image-20210203173746599">-</p>
<!--”-k 保留源压缩文件“--></li>
</ol>
<h3 id="4-4-网络命令"><a href="#4-4-网络命令" class="headerlink" title="4.4 网络命令"></a>4.4 网络命令</h3><ol>
<li><p>网卡配置文件位置：**/etc/sysconfig/network-scripts/ifcfg-ens32**</p>
<p><img src="/2021/08/25/16-07-33/image-20210305142010365.png" alt="image-20210305142010365">-</p>
<p>说明：<strong>TYPE</strong>就是网络类型，这里是以太网；<strong>PROXY_METHOD</strong>是网络代理，这里没有；<strong>BROWSER_ONLY</strong>表示只是浏览器，这里不是；<strong>BOOTPROTO</strong>是网卡的引导协议，这里用的是DHCP；<strong>DEFROUTE</strong>表示默认路由；<strong>IPV4_FAILURE_FATAL</strong>是否开启IPV4致命错误检测；IPV6INIT表示IPV6是否自动初始化；<strong>IPV6_AUTOCONF</strong>表示IPV6是否自动配置；<strong>IPV6_DEFROUTE</strong>表示IPV6是否可以为默认路由；<strong>IPV6_FAILURE_FATAL</strong>是否开启IPV6致命错误检测；<strong>IPV6_ADDR_GEN_MODE</strong>表示IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]；<strong>NAME</strong>表示网卡物理设备名称；<strong>UUID</strong>通用唯一识别码, 每一个网卡都会有, 不能重复；<strong>DEVICE</strong>表示网卡设备名称, 必须和 NAME 值一样；<strong>ONBOOT</strong>是否开机启动， 要想网卡开机就启动或通过 <code>systemctl restart network</code>控制网卡，必须设置为 <code>yes</code> </p>
<p>修改网卡配置文件：</p>
<ul>
<li><p>直接修改：<code>vim /etc/sysconfig/network-scripts/ens32</code></p>
<p>修改完成以后需要重启：<code>systemctl restart network.service</code></p>
</li>
<li><p>通过 ifconfig 命令修改</p>
<p>无选项的ifconfig是显示当前活动的网卡</p>
<p>设置 IP 地址（临时的）</p>
<p>​    命令格式：<code>ifconfig 网卡设备名 IP 地址 netmask 子网掩码</code></p>
<p>修改网卡的 MAC 地址（先禁用网卡，修改后重启网卡） </p>
<p>​    命令格式：<code>ifconfig 网卡设备名 hw ether MAC 地址</code></p>
<p>​    禁用网卡：<code>ifdown 网卡设备名</code></p>
<p>​    重启网卡：<code>ifup 网卡设备名</code></p>
</li>
</ul>
</li>
<li><p>hostname – 临时主机名配置</p>
<p><img src="/2021/08/25/16-07-33/image-20210305143044283.png" alt="image-20210305143044283">-</p>
</li>
<li><p>hostnamectl set-hostname 新主机名 – 永久设置主机名</p>
<p><img src="/2021/08/25/16-07-33/image-20210305143128332.png" alt="image-20210305143128332">-</p>
</li>
<li><p>write – 给用户发信息</p>
<p><u>write 所在路径：/usr/bin/write</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203174341044.png" alt="image-20210203174341044">-</p>
<!--对象必须在线-->

<p><img src="/2021/08/25/16-07-33/image-20210203181037209.png" alt="image-20210203181037209">-</p>
<p><img src="/2021/08/25/16-07-33/%5Cimage-20210203181013509.png" alt="image-20210203181013509">-</p>
<!--ctrl+d 保存结束--></li>
<li><p>wall – 发广播消息</p>
<p>wall 的英文原意为：<strong>write all</strong></p>
<p><u>wall 所在路径：/usr/bin/wall</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203181327768.png" alt="image-20210203181327768">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203181405359.png" alt="image-20210203181405359">-</p>
<!--发送给每个用户，包括发送信息的用户都会接收到这条消息--></li>
<li><p>ping – 测试网络连通性</p>
<p>ping 所在路径：/bin/ping</p>
<p><img src="/2021/08/25/16-07-33/image-20210203181655073.png" alt="image-20210203181655073">-</p>
<!--"-c 指定发送次数"--></li>
<li><p>ifconfig – 查看和设置网卡信息</p>
<p>若系统没有此命令，可先通过 <code>yum search ifconfig</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305104820491.png" alt="image-20210305104820491">-</p>
<p>然后安装下面得 <strong>net-tools</strong> 即可</p>
<p>ifconfig 的英文原意为：<strong>interface configure</strong></p>
<p><u>ifconfig 所在路径：/sbin/ifconfig</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203181843805.png" alt="image-20210203181843805">-</p>
<!--因为在sbin下，所以只能由root执行-->

<p>en表示以太网卡，是Ethernet的缩写，ether 表示MAC地址</p>
<p>RX表示接收到的包，TX表示发送的包，</p>
<p>lo表示回环</p>
<p>接口的激活与关闭：<code>ifconfig 接口名 up/down</code></p>
<p>例如：<code>ifconfig ens32 down</code></p>
<p>/release /renew /</p>
</li>
<li><p>ip addr – 获取网络地址</p>
<p>ip 是在 <strong>iproute2</strong> 里面</p>
<p><img src="/2021/08/25/16-07-33/image-20210313160313264.png" alt="image-20210313160313264">-</p>
</li>
<li><p><del>mail – 查看&amp;发送电子邮件，这里不展示，因为这个功能一般都由业务代码实现</del></p>
</li>
<li><p>last – 列出目前与过去登入系统的用户信息</p>
<p><u>last 所在路径：/usr/bin/last</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203182645978.png" alt="image-20210203182645978">-</p>
</li>
<li><p>lastlog – 检查某特定用户上次登录的时间</p>
<p> <u>lastlog 所在路径：/usr/bin/lastlog</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203182825277.png" alt="image-20210203182825277">-</p>
</li>
<li><p>traceroute – 显示数据包到主机间的路径</p>
<p><u>traceroute 所在路径：/bin/traceroute</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203191732834.png" alt="image-20210203191732834">-</p>
<!--显示*的原因可能是防火墙封掉了ICMP的返回信息--></li>
<li><p>curl – 查看网页</p>
<p>例如：<code>curl www.baidu.com</code></p>
</li>
<li><p>w3m – 显示网页</p>
<p>例如：<code>w3m www.baidu.com</code></p>
</li>
<li><p>netstat – 显示网络相关信息</p>
<p>==netstat对应到iproute2中的命令是ss==</p>
<p>==建议放弃net-tools，直接转到 iptoute2 的阵营==</p>
<p><img src="/2021/08/25/16-07-33/image-20210313163438761.png" alt="image-20210313163438761">-</p>
<p><u>netstat 所在路径：/bin/netstat</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203192040836.png" alt="image-20210203192040836">-</p>
<!--”-t：TCP协议、-u：UDP协议、-i：网络接口的统计信息、-l：监听、-r：路由、-n：显示IP地址和端口号“-->

<p><img src="/2021/08/25/16-07-33/image-20210313162033585.png" alt="image-20210313162033585">-</p>
<p>==这上面就能看到MTU（最大传输单元）==</p>
<!--”-tlun：查看本机监听的端口、-a：无论链接的情况如何都显示、-an：查看本机所有的网络链接、-rn查看本机路由表“--></li>
<li><p>route -n – 查看网关信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210304231655470.png" alt="image-20210304231655470">-</p>
</li>
<li><p>setup – 配置网络</p>
<!--注意：在CentOS 8 中使用nmtui-->

<p><u>nmtui 所在路径：/usr/bin/nmtui</u></p>
<p><u>记忆：尼玛tui</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203192751393.png" alt="image-20210203192751393">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203192807057.png" alt="image-20210203192807057">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203193055231.png" alt="image-20210203193055231">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203193114362.png" alt="image-20210203193114362">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203193306063.png" alt="image-20210203193306063">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203193210368.png" alt="image-20210203193210368">-</p>
<!--先通过`Edit a connection`Add一个新IP后，再点击`Active a  connection`激活刚刚配置的网络--></li>
</ol>
<h3 id="4-5-关机-amp-重启-amp-退出登录命令"><a href="#4-5-关机-amp-重启-amp-退出登录命令" class="headerlink" title="4.5 关机&amp;重启&amp;退出登录命令"></a>4.5 关机&amp;重启&amp;退出登录命令</h3><ol>
<li><p>shutdown – 停止、关机、重启</p>
<p>shutdown 所在路径：/usr/sbin/shutdown</p>
<p><img src="/2021/08/25/16-07-33/image-20210203194822508.png" alt="image-20210203194822508">-</p>
<!--在sbin目录下，只能由root用户执行-->

<!--halt、power-off、reboot the machine-->

<!--”-c 取消前一个关机命令、-h 关机、-r 重启“--></li>
<li><p>halt – 停止、关机、重启</p>
<p><u>halt 所在路径：/usr/sbin/halt</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203194933135.png" alt="image-20210203194933135">-</p>
<!--显示上面内容后只能重启了--></li>
<li><p>poweroff – 停止、关机、重启</p>
<p><u>poweroff 所在路径：/usr/sbin/poweroff</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203195310455.png" alt="image-20210203195310455">-</p>
<!--立即关机，没有等待--></li>
<li><p>reboot – 停止、关机、重启</p>
<p><u>reboot 所在路径：/usr/sbin/reboot</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203195404709.png" alt="image-20210203195404709">-</p>
<!--立即关机，没有等待--></li>
<li><hr>
<p>init 6 – 重启</p>
<p><u>init 所在路径：/usr/sbin/init</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203195839980.png" alt="image-20210203195839980">-</p>
<!--立即重启，没有等待--></li>
<li><p>init 0 – 关机</p>
<p><img src="/2021/08/25/16-07-33/image-20210203195949962.png" alt="image-20210203195949962">-</p>
<!--立即关机，没有等待-->

<p><strong><!--0：关机、1：单用户、2：不完全多用户，不含NFS服务、3：完全多用户、4：未分配、5图形界面、6：重启--></strong></p>
<p>6.1 查看系统运行级别：</p>
<p><img src="/2021/08/25/16-07-33/image-20210203200736603.png" alt="image-20210203200736603">-</p>
<!--N为null，表示还未修改-->

<p><del>6.2 修改系统默认运行级别：vim  /etc/inittab</del></p>
<p><img src="/2021/08/25/16-07-33/image-20210203202132863.png" alt="image-20210203202132863">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204100442023.png" alt="image-20210204100442023">-</p>
</li>
<li><hr>
<p>logout – 退出登录</p>
<p><img src="/2021/08/25/16-07-33/image-20210203200032138.png" alt="image-20210203200032138">-</p>
</li>
</ol>
<h3 id="4-6-帮助命令"><a href="#4-6-帮助命令" class="headerlink" title="4.6 帮助命令"></a>4.6 帮助命令</h3><ol>
<li><p>man – 获取帮助信息</p>
<p>man 的英文原意为：<strong>manual</strong></p>
<p><u>man 所在路径：/usr/bin/man</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203163916631.png" alt="image-20210203163916631">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203163938167.png" alt="image-20210203163938167">-</p>
</li>
<li><p>help – 获取Shell内置命令的帮助信息</p>
<p>help 所在路径：Shell内置命令</p>
<p><img src="/2021/08/25/16-07-33/image-20210203164052852.png" alt="image-20210203164052852">-</p>
</li>
<li><p>info – 一套完整的资料</p>
<p><img src="/2021/08/25/16-07-33/Users\chen\AppData\Roaming\Typora\typora-user-images\image-20210301183117970.png" alt="image-20210301183117970">-</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">上箭头</td>
<td align="center">向上移动一行</td>
</tr>
<tr>
<td align="center">下箭头</td>
<td align="center">向下移动一行</td>
</tr>
<tr>
<td align="center">PgUp</td>
<td align="center">向上翻一页</td>
</tr>
<tr>
<td align="center">PgDn</td>
<td align="center">向下翻一页</td>
</tr>
<tr>
<td align="center">Tab</td>
<td align="center">在有“*”符号的节点间进行切换</td>
</tr>
<tr>
<td align="center">回车</td>
<td align="center">进入有“*”符号的子页面，查看详细帮助信息</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">进入上一层信息（回车是进入下一层）</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">进入下小节信息</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">进入上小节信息</td>
</tr>
<tr>
<td align="center">？</td>
<td align="center">查看帮助信息</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">推出<strong>infor</strong>信息</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="4-7-时间日期命令"><a href="#4-7-时间日期命令" class="headerlink" title="4.7 时间日期命令"></a>4.7 时间日期命令</h3><ol>
<li><p>date – 时间日期</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">显示当前时间</td>
</tr>
<tr>
<td align="center">date +%Y</td>
<td align="center">显示当前年份</td>
</tr>
<tr>
<td align="center">date +%m</td>
<td align="center">显示当前月份</td>
</tr>
<tr>
<td align="center">date +%d</td>
<td align="center">显示当前是哪一天</td>
</tr>
<tr>
<td align="center">date “+%Y-%m-%d %H:%M:%S”</td>
<td align="center">显示年月日时分秒</td>
</tr>
<tr>
<td align="center">date -s ”xxxxxx“</td>
<td align="center">设置系统当前时间</td>
</tr>
</tbody></table>
</li>
<li><p>cal – 查看日历</p>
<p><img src="/2021/08/25/16-07-33/image-20210207125453829.png" alt="image-20210207125453829">-</p>
</li>
</ol>
<h3 id="4-9-系统命令"><a href="#4-9-系统命令" class="headerlink" title="4.9 系统命令"></a>4.9 系统命令</h3><h3 id="4-8-常用快捷键"><a href="#4-8-常用快捷键" class="headerlink" title="4.8 常用快捷键"></a>4.8 常用快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tab</td>
<td align="center">命令或文件补全</td>
</tr>
<tr>
<td align="center">ctrl + a</td>
<td align="center">把光标移到命令行头</td>
</tr>
<tr>
<td align="center">ctrl + e</td>
<td align="center">把光标移到命令行尾</td>
</tr>
<tr>
<td align="center">ctrl + c</td>
<td align="center">强制终止当前的命令</td>
</tr>
<tr>
<td align="center">ctrl + l</td>
<td align="center">清屏，相当于clear命令</td>
</tr>
<tr>
<td align="center">ctrl + u</td>
<td align="center">删除或剪切光标之前的命令</td>
</tr>
<tr>
<td align="center">ctrl + y</td>
<td align="center">粘贴剪切的内容</td>
</tr>
</tbody></table>
<h2 id="第五章-vi-和-vim-编辑器篇"><a href="#第五章-vi-和-vim-编辑器篇" class="headerlink" title="第五章 vi 和 vim 编辑器篇"></a>第五章 vi 和 vim 编辑器篇</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><p>​    <strong>Linux文本处理工具：vim、grep、egrep、sed、awk</strong></p>
<p>​    <strong>vim 是 vi 的升级版，所以现在应该使用vim，因为有代码高亮，代码补全</strong></p>
<p>​    <strong>vim 没有菜单，只有命令</strong></p>
<h3 id="5-2-工作模式"><a href="#5-2-工作模式" class="headerlink" title="5.2 工作模式"></a>5.2 工作模式</h3><p><img src="/2021/08/25/16-07-33/image-20210203202832432.png" alt="image-20210203202832432">-</p>
<h3 id="5-3-常用操作"><a href="#5-3-常用操作" class="headerlink" title="5.3 常用操作"></a>5.3 常用操作</h3><p><img src="/2021/08/25/16-07-33/image-20210207121422323.png" alt="image-20210207121422323">-</p>
<h4 id="5-3-1-插入命令"><a href="#5-3-1-插入命令" class="headerlink" title="5.3.1 插入命令"></a>5.3.1 插入命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
<td align="center">在光标所在<strong>字符后</strong>插入</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">在光标所在<strong>行尾</strong>插入</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">在光标所在<strong>字符前</strong>插入</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">在光标所在行<strong>行首</strong>插入</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">在<strong>光标下</strong>插入新行</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">在<strong>光标上</strong>插入新行</td>
</tr>
</tbody></table>
<h4 id="5-3-2-定位命令"><a href="#5-3-2-定位命令" class="headerlink" title="5.3.2 定位命令"></a>5.3.2 定位命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">：set nu</td>
<td align="center">显示行号</td>
</tr>
<tr>
<td align="center">：set <strong>no</strong>nu</td>
<td align="center">取消行号</td>
</tr>
<tr>
<td align="center">gg</td>
<td align="center">到第一行</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">到最后一行</td>
</tr>
<tr>
<td align="center">nG</td>
<td align="center">到第n行</td>
</tr>
<tr>
<td align="center">：n</td>
<td align="center">到第n行</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">移至行尾</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">移至行首</td>
</tr>
</tbody></table>
<h4 id="5-3-3-删除命令"><a href="#5-3-3-删除命令" class="headerlink" title="5.3.3 删除命令"></a>5.3.3 删除命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">删除光标所在处字符</td>
</tr>
<tr>
<td align="center">nx</td>
<td align="center">删除光标所在处后n个字符</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">删除光标所在行，ndd删除n行</td>
</tr>
<tr>
<td align="center">dG</td>
<td align="center">删除光标所在行<strong>到文件末尾</strong>内容</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">删除光标所在处<strong>到行尾</strong>内容</td>
</tr>
<tr>
<td align="center">：n1，n2d</td>
<td align="center">删除指定范围的行</td>
</tr>
</tbody></table>
<h4 id="5-3-4-复制和剪切命令"><a href="#5-3-4-复制和剪切命令" class="headerlink" title="5.3.4 复制和剪切命令"></a>5.3.4 复制和剪切命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">yy</td>
<td align="center">复制当前行</td>
</tr>
<tr>
<td align="center">nyy</td>
<td align="center">复制当前行到以下n行</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">剪切当前行</td>
</tr>
<tr>
<td align="center">ndd</td>
<td align="center">剪切当前行到以下n行</td>
</tr>
<tr>
<td align="center">p（小写）</td>
<td align="center">粘贴在当前光标所在行<strong>下</strong></td>
</tr>
<tr>
<td align="center">P（大写）</td>
<td align="center">粘贴在当前光标所在行<strong>上</strong></td>
</tr>
</tbody></table>
<h4 id="5-3-5-替换和取消命令"><a href="#5-3-5-替换和取消命令" class="headerlink" title="5.3.5 替换和取消命令"></a>5.3.5 替换和取消命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">取代光标所在处字符</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">从光标所在处开始替换字符，按Esc结束</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">取消上一步操作</td>
</tr>
</tbody></table>
<h4 id="5-3-6-搜索和搜索替换命令"><a href="#5-3-6-搜索和搜索替换命令" class="headerlink" title="5.3.6 搜索和搜索替换命令"></a>5.3.6 搜索和搜索替换命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/sting</td>
<td align="center">搜索指定字符串，回车后会一直高亮，取消高亮”<strong>：nohl</strong>“，搜索时忽略大小写”<strong>：set ic</strong>“</td>
</tr>
<tr>
<td align="center"><em>n（怎么弄？）</em></td>
<td align="center">搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td align="center">：%s/old/new/g</td>
<td align="center">全文替换old字符串为new字符串</td>
</tr>
<tr>
<td align="center">：n1，n2s/old/new/g</td>
<td align="center">在一定范围内替换指定字符串</td>
</tr>
</tbody></table>
<h4 id="5-3-7-保存和退出命令"><a href="#5-3-7-保存和退出命令" class="headerlink" title="5.3.7 保存和退出命令"></a>5.3.7 保存和退出命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">：w</td>
<td align="center">保存修改</td>
</tr>
<tr>
<td align="center">：w new_filename</td>
<td align="center">另存为指定文件</td>
</tr>
<tr>
<td align="center">：wq</td>
<td align="center">保存修改并退出</td>
</tr>
<tr>
<td align="center">ZZ</td>
<td align="center">保存修改并退出</td>
</tr>
<tr>
<td align="center">：q！</td>
<td align="center">不保存修改退出</td>
</tr>
<tr>
<td align="center">：wq！</td>
<td align="center">保存修改并退出（仅文件所有者和root可用）</td>
</tr>
</tbody></table>
<h3 id="5-4-额外技巧"><a href="#5-4-额外技巧" class="headerlink" title="5.4 额外技巧"></a>5.4 额外技巧</h3><ol>
<li><p>连续行注释：<code>：n1，n2s/^/#/g</code>、<code>：n1，n2s/^#//g</code></p>
</li>
<li><p>自定义快捷键：<code>：map 快捷键 出发命令</code></p>
</li>
<li><p>导入<strong>命令（外部命令）</strong>执行结果：<code>：r ！命令</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210203211750550.png" alt="image-20210203211750550">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203211838877.png" alt="image-20210203211838877">-</p>
</li>
<li><p>vim 分屏操作</p>
</li>
</ol>
<h3 id="5-5-Visual-模式"><a href="#5-5-Visual-模式" class="headerlink" title="5.5 Visual 模式"></a>5.5 Visual 模式</h3><p>1、按下v键，即可进入视图模式，然后就可以移动光标选择内容：</p>
<p><img src="/2021/08/25/16-07-33/image-20210313133326951.png" alt="image-20210313133326951">-</p>
<p>然后就可以在这之上进行相应的操作，比如删除，按下：<strong>d</strong>即可，再次按下<strong>v</strong>即可取消</p>
<p>2、按下ctrl+v可以<strong>按块选择</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210313133853537.png" alt="image-20210313133853537">-</p>
<p>==再次按下ctrl+v即可取消==</p>
<p>3、按下shift+v也就是V，可以选中一行：</p>
<p><img src="/2021/08/25/16-07-33/image-20210313134054124.png" alt="image-20210313134054124">-</p>
<p>==再次按下shift+v即可取消==</p>
<h3 id="5-6-Insert-模式"><a href="#5-6-Insert-模式" class="headerlink" title="5.6 Insert 模式"></a>5.6 Insert 模式</h3><p>进入插入模式有6种方式：</p>
<p>a、i、o：</p>
<p>a是在当前光标所选择字母的后面（append）</p>
<p>i是在当前前光标所选择字母的前面（insert）</p>
<p>o是当前行的下一行（open a line below）</p>
<p>A、I、O：</p>
<p>A是在当前行的最后面</p>
<p>I是在当前行的最前面</p>
<p>O是在当前行的上一行</p>
<p>ctrl + h 删除上一个字母，跟backspace一样</p>
<p>ctrl + w 删除一个单词，得把光标放到单词末尾</p>
<p>ctrl + u 删除这一行，得把光标放到这行末尾</p>
<p>==注意：ctrl + h w u 可以在终端使用==</p>
<p>==在终端：ctrl + b 是往前移动，ctrl + f 是往后移动 ，ctrl + a 移动到最前面，ctrl + e 移动到最后面==</p>
<p>替换esc得方法：ctrl + c 或者 ctrl + [，一般不适应ctrl + c 因为可能会停掉某些插件</p>
<p>使用==gi==来快速跳转到最后一次编辑的位置，并开启插入模式</p>
<h3 id="5-7-Normal-模式"><a href="#5-7-Normal-模式" class="headerlink" title="5.7 Normal 模式"></a>5.7 Normal 模式</h3><p>：w保存</p>
<p>：q退出</p>
<p>：vs（vertical split）</p>
<p><img src="/2021/08/25/16-07-33/image-20210313140503552.png" alt="image-20210313140503552">-</p>
<p>：sp（split）</p>
<p><img src="/2021/08/25/16-07-33/image-20210313140452485.png" alt="image-20210313140452485">-</p>
<p>==退出分配可以使用：q==</p>
<p>全局替换：:% s/原字符串/新字符串/g </p>
<p><img src="/2021/08/25/16-07-33/image-20210313140700833.png" alt="image-20210313140700833">-</p>
<p>移动：</p>
<p>==左（h）、下（j）、上（k）、右（l）==</p>
<p><img src="/2021/08/25/16-07-33/image-20210313144410363.png" alt="image-20210313144410363">-</p>
<p>w/W：移动到下一个word/WORD开头。</p>
<p>e/E：移动到下一个word/WORD尾、</p>
<p>b/B：回到上一个word/WORD开头，可以理解为backword</p>
<p>==注意：word指的是以非空白符分割的单词，WORD是以空白行分割的单词==</p>
<p>使用==f{char}==可以移动到char字符上，==t==移动到char的前一个字符</p>
<p>如果第一次没有搜到，可以用分号(==；==)或者逗号(==，==)继续进行搜索改行上一个/下一个</p>
<p>大写的F表示反过来搜前面的字符</p>
<p>==0（数字零）==移动到行首第一个字符，==^==移动到第一个非空白字符</p>
<p>注意 0 和^ 都是移动到行首，只不过一个是可以移动到空白字符，一个是非空白字符</p>
<p>==$==移动到行尾，==g_==移动到行尾非空白字符</p>
<p>==常用 0 和 $==</p>
<p>gg/G 移动到文件开头/结尾，可以使用ctrl + o快速返回</p>
<p>H/M/L跳转到屏幕的开头（Head），中间（Middle），结尾（Lower）</p>
<p>ctrl + u，ctrl + f上下翻页（upword / forward），zz把屏幕置为中间</p>
<h2 id="第六章-Shell-脚本篇"><a href="#第六章-Shell-脚本篇" class="headerlink" title="第六章 Shell 脚本篇"></a>第六章 Shell 脚本篇</h2><h3 id="6-1-Bash-基本功能"><a href="#6-1-Bash-基本功能" class="headerlink" title="6.1 Bash 基本功能"></a>6.1 Bash 基本功能</h3><p>​    Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行出去的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207130329578.png" alt="image-20210207130329578">-</p>
<p>​    Shell脚本格式要求：</p>
<p>​    1、脚本以 #!/bin/bash 开头，表明此shell脚本用上面shell执行，因为Linux不止一种shell，国内一般用的是bash shell</p>
<p>​    查看当前Linux系统安装的所有shell：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210310205946621.png" alt="image-20210310205946621">-</p>
<p>​    /bin/sh 是 Bourne Shell（shebang） <strong>|-|</strong> /bin/bash 是 Bourne Again Shell <strong>|-|</strong>/usr/bin/sh 是 Bourne Shell </p>
<p>​    2、脚本需要有可执行权限：chmod +x xx.sh</p>
<p>​    3、第一个shell脚本：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207131101681.png" alt="image-20210207131101681">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207131035378.png" alt="image-20210207131035378">-</p>
<p>​    也可以用**<u>绝对路径</u>**执行：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207131311609.png" alt="image-20210207131311609">-</p>
<p>​    如果不给文件加上<strong>x权限</strong>，则需要用：<code>sh hello.sh</code> 执行</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207131453433.png" alt="image-20210207131453433">-</p>
<p>​    4、shell 脚本的单行注释用 #、多行注释用：“<code>：&lt;&lt;! 内容 !</code>”</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207141333149.png" alt="image-20210207141333149">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207141356283.png" alt="image-20210207141356283">-</p>
<h3 id="6-2-Bash-变量"><a href="#6-2-Bash-变量" class="headerlink" title="6.2 Bash 变量"></a>6.2 Bash 变量</h3><p>​    Linux Shell 中的变量分为<strong>系统变量</strong>和<strong>用户自定义变量</strong></p>
<h4 id="6-2-1-系统变量"><a href="#6-2-1-系统变量" class="headerlink" title="6.2.1 系统变量"></a>6.2.1 系统变量</h4><p>​    1、系统变量：$HOME、$PWD、$SHELL、$USER、​$PATH、$HOSTNAME等等</p>
<p>​    2、显示当前shell中的<strong>所有变量</strong>：<code>set</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210207132045983.png" alt="image-20210207132045983"></p>
<p>​    查看当前系统运行的shell：<code>echo $SHELL</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210310210835824.png" alt="image-20210310210835824">-</p>
<p>​    查看本机的Bash版本：<code>echo $BASH_VERSION</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210310210949023.png" alt="image-20210310210949023">-</p>
<p>​    <!--注意：release 表示发行版--></p>
<p>​    或者通过：<code>bash --version</code> 查看</p>
<p><img src="/2021/08/25/16-07-33/image-20210310211057642.png" alt="image-20210310211057642">-</p>
<p>​    3、向<strong>PATH变量</strong>中添加脚本文件：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311115502590.png" alt="image-20210311115502590">-</p>
<h4 id="6-2-2-自定义变量"><a href="#6-2-2-自定义变量" class="headerlink" title="6.2.2 自定义变量"></a>6.2.2 自定义变量</h4><p>​    1、定义变量：<code>变量=值</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207133751926.png" alt="image-20210207133751926">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207133807217.png" alt="image-20210207133807217">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134013257.png" alt="image-20210207134013257">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134029315.png" alt="image-20210207134029315">-</p>
<p>​    <!--等号左右不能有空格--></p>
<p>​    <!--加不加引号都一样--></p>
<p>​    2、撤销变量：<code>unset 变量</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134135398.png" alt="image-20210207134135398">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134151367.png" alt="image-20210207134151367">-</p>
<p>​    <strong>双引号</strong>一般是用于下面这种情况：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311112244398.png" alt="image-20210311112244398">-</p>
<p>​    3、声明静态变量：<code>readonly 变量</code>，注意此变量<strong>不能unset</strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134428045.png" alt="image-20210207134428045">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207134456128.png" alt="image-20210207134456128">-</p>
<p>​    <!--变量定义规则：变量名称可以由字母、数字、下划线组成，但不能以数字开头--></p>
<p>​    <!--一般变量名称用大写--></p>
<p>​    4、将命令的返回值赋给变量</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207135356908.png" alt="image-20210207135356908">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207135416184.png" alt="image-20210207135416184">-</p>
<p>​    <!--变量C那个是反引号，tab键上面那个，注意反引号也是只能存放系统命令之类的--></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311111806117.png" alt="image-20210311111806117">-</p>
<p>​    <!--变量D是圆括号，注意圆括号中不能放自定义变量，圆括号可以放代码--></p>
<p>​    <!--自定义变量只能放到 ${} 这个里面--></p>
<p>​    <strong>单引号</strong>的作用：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311112433569.png" alt="image-20210311112433569">-</p>
<h4 id="6-2-3-环境变量"><a href="#6-2-3-环境变量" class="headerlink" title="6.2.3 环境变量"></a>6.2.3 环境变量</h4><p>​    在 Linux 系统中，环境变量的全局配置文件为/etc/profile,在此文件中定义的变量 作用于所有用户。除此外，每个用户还有自己的独立配置文件（~/.bash_profile)。</p>
<p>​    若要长期变更 或设置某个环境变量，应在上述文件中进行设置</p>
<table>
<thead>
<tr>
<th align="right">代码</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="right">export 变量名=变量值, 变量名,…..</td>
<td align="left">将shell变量输出为<strong>环境变量/全局变量</strong></td>
</tr>
<tr>
<td align="right">source 配置文件</td>
<td align="left">让修改后的配置信息立即生效</td>
</tr>
<tr>
<td align="right">echo $变量名</td>
<td align="left">查询环境变量的值</td>
</tr>
</tbody></table>
<p>​    1、在/etc/profile文件中定义TOMCAT_HOME环境变量：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207140408781.png" alt="image-20210207140408781">-</p>
<p>​    2、在输出TOMCAT_HOME前，需要让其生效：<code>source /etc/profile</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207140501633.png" alt="image-20210207140501633">-</p>
<p>​    3、输出这个环境变量：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207140558114.png" alt="image-20210207140558114">-</p>
<p>​    4、在shell文件中使用这个TOMCAT_HOME变量：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207140801290.png" alt="image-20210207140801290">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207140827730.png" alt="image-20210207140827730">-</p>
<p>​    5、使用 env 命令可以查看到当前工作环境下的环境变量：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311114716798.png" alt="image-20210311114716798">-</p>
<h4 id="6-2-4-位置参数变量"><a href="#6-2-4-位置参数变量" class="headerlink" title="6.2.4 位置参数变量"></a>6.2.4 位置参数变量</h4><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$n</td>
<td align="center">n为数字，0表示本身，1-9表示第一到第九个参数，10以上的参数需要用大括号，如：${10}</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="center">这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">这个变量代表命令行中所有的参数，不过$@把每个参数区分对待</td>
</tr>
<tr>
<td align="center">$#</td>
<td align="center">这个变量代表命令行中所有的参数的个数</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210207142448262.png" alt="image-20210207142448262">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207142530781.png" alt="image-20210207142530781">-</p>
<h4 id="6-2-5-预定义变量"><a href="#6-2-5-预定义变量" class="headerlink" title="6.2.5 预定义变量"></a>6.2.5 预定义变量</h4><p>​    预定义变量就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$$</td>
<td align="left">当前进程的进程号（PID）</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="left">后台运行的最后一个进程的进程号（PID）</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="left">最后一次执行的命令的返回状态，如果值为0，证明上一个命令正确执行，如果非0（具体哪个数字，由命令自己来决定），则证明上一个命令没有正确执行</td>
</tr>
<tr>
<td align="center">$0</td>
<td align="left">示当前执行的脚本或程序名称</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210207143613718.png" alt="image-20210207143613718">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207143719321.png" alt="image-20210207143719321">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210311122010651.png" alt="image-20210311122010651">-</p>
<h3 id="6-3-数值运算"><a href="#6-3-数值运算" class="headerlink" title="6.3 数值运算"></a>6.3 数值运算</h3><p>​    1、“**$((运算式))<strong>” 或 “</strong>$[运算式]**” 或者 <strong>expr m + n</strong> ，如果希望将expr的结果赋值给某个变量：<code>A=`expr m + n` </code></p>
<p>​    <!--推荐使用：“$[运算式]”--> </p>
<p>​    <!--m、n是数字--></p>
<p>​    <!--expr = expression 表达式--></p>
<p>​    <!--注意expr运算符间要有空格--></p>
<p>​    2、expr \*、/、%：乘、除、取余</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207153755308.png" alt="image-20210207153755308">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207153815125.png" alt="image-20210207153815125">-</p>
<p>​    <!--注意：使用 expr 进行计算的时候，变量必须是整数，不能是字符串，也不能含小数，否则会出错--></p>
<p>​    除了上面3种以为还有<strong>let</strong>命令：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210311114436295.png" alt="image-20210311114436295">-</p>
<h3 id="6-4-条件判断"><a href="#6-4-条件判断" class="headerlink" title="6.4 条件判断"></a>6.4 条件判断</h3><table>
<thead>
<tr>
<th align="right">判断</th>
<th align="center">格式</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="right">条件判断</td>
<td align="center">=</td>
<td align="left">字符串的比较</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">!=</td>
<td align="left">字符串的比较</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-z</td>
<td align="left">检查字符串为空（zero)，对于未定义或赋予空值的变量将视为空串</td>
</tr>
<tr>
<td align="right">两个整数的比较</td>
<td align="center">-lt</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-le</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-eq</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-gt</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-ge</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-ne</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="right">按文件权限进行判断</td>
<td align="center">-r</td>
<td align="left">有读的权限</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-w</td>
<td align="left">有写的权限</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-x</td>
<td align="left">有执行的权限</td>
</tr>
<tr>
<td align="right">按文件类型进行判断</td>
<td align="center">-f</td>
<td align="left">文件存在并是一个常规文件</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-e</td>
<td align="left">文件存在</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">-d</td>
<td align="left">文件存在并是一个目录</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210207160008382.png" alt="image-20210207160008382">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207160027723.png" alt="image-20210207160027723">-</p>
<!--注意：在条件判断中shell 环境根据命令执行后的返回状态（$?）来判断是否执行成功，当返回 0 时表示成功，当 返回 1 时表示失败或异常-->

<h3 id="6-5-逻辑判断"><a href="#6-5-逻辑判断" class="headerlink" title="6.5 逻辑判断"></a>6.5 逻辑判断</h3><table>
<thead>
<tr>
<th align="center">格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="left">逻辑与，表示而且，只有当前后两个条件都成立时，整个测试的命令返回值才为 0（结果 成立）。使用 test 命令测试时可改为-a</td>
</tr>
<tr>
<td align="center">||</td>
<td align="left">逻辑或，表示或者，只要前后两个条件有一个成立，则整个测试的命令返回值为 0（结果 成立）。使用 test命令测试时可改为-o</td>
</tr>
<tr>
<td align="center">！</td>
<td align="left">逻辑否，表示不，只有当指定的条件不成立时，整个测试命令的返回值才为 0（结果成立）</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210311125735979.png" alt="image-20210311125735979">-</p>
<p><strong>判断是否存在这个目录，如果存在则打印”yes”，否则打印”oh no”</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210311125844617.png" alt="image-20210311125844617">-</p>
<!--这加了 ！就是取反嘛，懂的都懂-->

<h3 id="6-6-流程控制"><a href="#6-6-流程控制" class="headerlink" title="6.6 流程控制"></a>6.6 流程控制</h3><p>if语句的语法结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]   # $? 要和 0 比较 : $? -eq 0</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">else</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">else</span><br><span class="line">代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/25/16-07-33/image-20210207202418309.png" alt="image-20210207202418309">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207202444252.png" alt="image-20210207202444252">-</p>
<p>注意if 后面的 <strong>[]</strong> 也可以换成 <strong>test</strong> 命令：</p>
<p><img src="/2021/08/25/16-07-33/image-20210311115745426.png" alt="image-20210311115745426">-</p>
<p>使用 shell 脚本挂载硬盘，并进行永久挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;挂载光盘镜像文件脚本: $&#123;0&#125; 启动！&quot;</span><br><span class="line">echo &quot;=================================&quot;</span><br><span class="line">read -p &quot;请输入需要挂载的目录路径：&quot; MOUNT_DIR</span><br><span class="line">read -p &quot;请输入需要挂载的光盘路径：&quot; CD_DISK</span><br><span class="line">read -p &quot;请指定一个文件系统格式：&quot; FORMAT_DISK</span><br><span class="line"></span><br><span class="line">if [ ! -d $&#123;MOUNT_DIR&#125; ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录不存在，先创建目录</span></span><br><span class="line">then</span><br><span class="line">mkdir $&#123;MOUNT_DIR&#125; &amp;&gt; /dev/null</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断该目录是否已经挂载</span></span><br><span class="line">mount | grep $&#123;MOUNT_DIR&#125;</span><br><span class="line"></span><br><span class="line">if [ ! $? ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;该光盘文件已经挂载！&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;开始挂载光盘！&quot;</span><br><span class="line">    if [ ! -z $&#123;FORMAT_DISK&#125; ] &amp;&amp; [ -e $&#123;CD_DISK&#125; ]</span><br><span class="line">    then</span><br><span class="line">      mount -t $&#123;FORMAT_DISK&#125; $&#123;CD_DISK&#125; $&#123;MOUNT_DIR&#125; &amp;&gt; /dev/null</span><br><span class="line">      if [ $? -eq 0 ]</span><br><span class="line">      then</span><br><span class="line">        echo &quot;光盘挂载成功！&quot;</span><br><span class="line">        echo &quot;=================================&quot;</span><br><span class="line">      else</span><br><span class="line">        echo &quot;光盘挂载失败！&quot;</span><br><span class="line">        echo &quot;=================================&quot;</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">      echo &quot;光盘镜像不存在！&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>case语句的语法结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量 <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;参数1&quot;</span>)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210207203105029.png" alt="image-20210207203105029">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207203131453.png" alt="image-20210207203131453">-</p>
<p>for循环语句的第一种结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3....</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210207204259441.png" alt="image-20210207204259441">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207204334440.png" alt="image-20210207204334440">-</p>
<p>for循环语句的第二种结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((初始值；循环控制条件；变量变化))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210207205816258.png" alt="image-20210207205816258">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207205829576.png" alt="image-20210207205829576">-</p>
<!--注：循环中的100可以改为$1接收输入的值-->

<p>实战：</p>
<p>创建50个用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1; i&lt;=50;i++))</span><br><span class="line">do</span><br><span class="line">USER=&quot;stu$&#123;i&#125;&quot;</span><br><span class="line">useradd $&#123;USER&#125;</span><br><span class="line">echo $USER | passwd --stdin $USER &amp;&gt; /dev/null</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>删除50个用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1; i&lt;=50;i++))</span><br><span class="line">do</span><br><span class="line">USER=&quot;stu$&#123;i&#125;&quot;</span><br><span class="line">userdel $USER</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>while语句的语法结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ] # while和中括号有空格，中括号中也有空格</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210207210851742.png" alt="image-20210207210851742">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207210905153.png" alt="image-20210207210905153">-</p>
<!--注意：上面的 i=$[$i+1] 也可以改为 let i++-->

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;猜数游戏开始~&quot;</span><br><span class="line">REAL_NUM=$[$&#123;RANDOM&#125; % 10]</span><br><span class="line">TIMES=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">  if [ $&#123;TIMES&#125; -eq 5 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;5次都不行，算了吧兄弟！&quot;</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line">  read -p &quot;请输入一个10以内的数：&quot; INPUT_NUM</span><br><span class="line">  if [ $&#123;INPUT_NUM&#125; -eq $&#123;REAL_NUM&#125; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;栽种居然猜对了!&quot;</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line">  let TIMES++</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="6-7-读取控制台输入"><a href="#6-7-读取控制台输入" class="headerlink" title="6.7 读取控制台输入"></a>6.7 读取控制台输入</h3><p>​    语法：<code>read 选项 参数</code></p>
<p>​    选项：</p>
<p>​    -p：指定读取值时的提示符</p>
<p>​    -t：指定读取值时<strong>等待的时间</strong>（秒），如果没有在指定时间内输入，就不再等待</p>
<p>​    参数：</p>
<p>​    变量：指定读取值的变量名</p>
<p><img src="/2021/08/25/16-07-33/image-20210207211912533.png" alt="image-20210207211912533">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210207211929322.png" alt="image-20210207211929322">-</p>
<p>若是想实现<strong>回车</strong>的效果，需要这样：</p>
<p><img src="/2021/08/25/16-07-33/image-20210311113840384.png" alt="image-20210311113840384">-</p>
<h3 id="6-8-Shell函数"><a href="#6-8-Shell函数" class="headerlink" title="6.8 Shell函数"></a>6.8 Shell函数</h3><p>​    Shell编程跟其它语言一样，有<strong>系统函数</strong>，也可以有<strong>自定义函数</strong></p>
<p>​    <strong>系统函数basename</strong>：</p>
<p>​    功能：返回完整路径最后的**/**的部分，常用于获取文件名</p>
<p>​    <code>basename [pathname] [suffix]</code></p>
<p>​    功能：删掉所有的前缀表壳最后一个**/**,然后将字符串显示出来</p>
<p>​    <code>basename [string] [suffix]</code></p>
<p>​    选项：</p>
<p>​    suffix 为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207212730130.png" alt="image-20210207212730130">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207212848432.png" alt="image-20210207212848432">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207212753673.png" alt="image-20210207212753673">-</p>
<p>​    <strong>系统函数dirname：</strong></p>
<p>​    功能：返回完整路径最后**/**前面的部分，常用于返回路径部分</p>
<p>​    <code>dirname 文件绝对路径</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207213111154.png" alt="image-20210207213111154">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207213635470.png" alt="image-20210207213635470">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207213703142.png" alt="image-20210207213703142">-</p>
<p>​    <strong>自定义函数的语法结构：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname[()] &#123;</span><br><span class="line">		Action;</span><br><span class="line">		[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    调用直接写函数名：funame [值]</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207221135300.png" alt="image-20210207221135300">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207220043276.png" alt="image-20210207220043276">-</p>
<p>​    <!--跟上面是一样的--></p>
<h3 id="6-9-正则表达式"><a href="#6-9-正则表达式" class="headerlink" title="6.9 正则表达式"></a>6.9 正则表达式</h3><h3 id="6-10-调试脚本"><a href="#6-10-调试脚本" class="headerlink" title="6.10 调试脚本"></a>6.10 调试脚本</h3><ol>
<li><p>使用 <strong>echo</strong> 命令调试脚本</p>
<p>懂的都懂，直接往代码里面放echo就行了，废话不多！</p>
</li>
<li><p>使用 <strong>bash</strong> 命令调试脚本</p>
<p>格式：<strong>sh [-nvx] 脚本名</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-n</td>
<td align="center">不会执行该脚本，仅查询脚本语法是否有问题，如果没有语法问题就不显示任何内容，如果有问题就会报错</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">在执行脚本时，先将脚本的内容输出到屏幕上然后执行脚本，如果有错误，也会给出提示</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="center">将执行的脚本内容输出到屏幕上</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210311180015054.png" alt="image-20210311180015054">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210311175952007.png" alt="image-20210311175952007">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210311180105760.png" alt="image-20210311180105760">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210311180131179.png" alt="image-20210311180131179">-</p>
</li>
<li><p>使用 <strong>set</strong> 命令调试脚本</p>
<p>这个是用来指定调试一段脚本：</p>
<p><img src="/2021/08/25/16-07-33/image-20210311180806631.png" alt="image-20210311180806631">-</p>
<!--set - +是指定调试范围-->

<p><img src="/2021/08/25/16-07-33/image-20210311180853433.png" alt="image-20210311180853433">-</p>
</li>
<li></li>
</ol>
<h3 id="6-11-实战1"><a href="#6-11-实战1" class="headerlink" title="6.11 实战1"></a>6.11 实战1</h3><p>数据库定时备份</p>
<p><img src="/2021/08/25/16-07-33/image-20210207221619682.png" alt="image-20210207221619682"></p>
<h3 id="6-12-实战2"><a href="#6-12-实战2" class="headerlink" title="6.12 实战2"></a>6.12 实战2</h3><p>​    一键安装ftp,不允许匿名用户访问。配置系统用户student访问指定目录/mnt/pub，并且对/mnt/pub/FTP这个目录具有上传、新建、删除的权限，系统用户stu1只具有下载的权限，配置完成后，重启服务，并在客户端进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> =============准备工作====================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙开启ftp服务</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=ftp &amp;&gt; /dev/null</span><br><span class="line">firewall-cmd --reload &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把 selinux 安全机制关了</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否安装vsftpd和ftp</span></span><br><span class="line">for SF in vsftpd ftp</span><br><span class="line">do</span><br><span class="line">  rpm -qa | grep &quot;^$&#123;SF&#125;$&quot;</span><br><span class="line">  if [ ! $? -eq 0 ]</span><br><span class="line">  then</span><br><span class="line">    # 通过网络源安装 vsfpt 和 ftp</span><br><span class="line">    yum install -y $&#123;SF&#125; &amp;&gt; /dev/null</span><br><span class="line">  else</span><br><span class="line">    echo -e &quot;\033[31m 软件已安装，请去确认配置文件是否已经被修改！ \033[0m&quot;</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果网络yum源用不了，则跟换本地yum源</span></span><br><span class="line">rpm -qa | grep &quot;^$&#123;SF&#125;$&quot;</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 执行挂载脚本</span></span><br><span class="line">  sh mount_disk</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 再安装</span></span><br><span class="line">  yum install -y vsftpd ftp &amp;&gt; /dev/null</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看21端口是否被占用：netstat -lanpt | grep 21</span></span><br><span class="line">SER_NAME=`netstat -lanpt | grep :21 | awk &#x27;&#123;print $7&#125;&#x27; | awk -F/ &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果端口被占用，就把对应服务停掉</span></span><br><span class="line">if [  $&#123;SER_NAME&#125; != &quot;vsftpd&quot; ]</span><br><span class="line">then</span><br><span class="line">  SER_ID=`ps -aux | grep $&#123;SER_NAME&#125; | awk &#x27;NR==1 &#123;print $2&#125;&#x27;`</span><br><span class="line">  kill -9 $&#123;SER_ID&#125;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 vsftpd 服务</span></span><br><span class="line">systemctl start vsftpd</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line">  echo -e &quot;\033[31m 启动失败，请自行查找其它原因！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 vsftpd 开机自启</span></span><br><span class="line">systemctl enable vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> =============准备工作结束=================</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> =============正式配置====================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断两个用户是否存在</span></span><br><span class="line">for U in student stu</span><br><span class="line">do</span><br><span class="line">  cat /etc/passwd | grep &quot;^$&#123;U&#125;$&quot;</span><br><span class="line">  EX_USER=$?</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 如果不存在，则创建系统用户</span></span><br><span class="line">  if [ ! $&#123;EX_USER&#125; -eq 0 ]</span><br><span class="line">  then</span><br><span class="line">    useradd -s /sbin/nologin $U</span><br><span class="line">    echo $U | passwd --stdin $U &amp;&gt; /dev/null</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断目录是否存在</span></span><br><span class="line">if [ ! -d /mnt/pub/FTP ]</span><br><span class="line">then</span><br><span class="line">  mkdir -p /mnt/pub/FTP</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 配置 pub/FTP 的权限为 student</span></span><br><span class="line">  chown -R student /mnt/pub</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置ftp</span></span><br><span class="line">CONFIG=&quot;/etc/vsftpd/vsftpd.conf&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份配置文件</span></span><br><span class="line">[ -e &quot;$&#123;CONFIG&#125;.old&quot; ] || cp $&#123;CONFIG&#125; $CONFIG.old</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，实现禁止匿名用户登录</span></span><br><span class="line">sed -i &#x27;/^anonymous_enable/s/YES/NO/g&#x27; $&#123;CONFIG&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许本地用户登录，且具有写入权限</span></span><br><span class="line">sed -i -e &#x27;/^local_enable/s/NO/YES/g&#x27; -e &#x27;/^write_enable/s/NO/YES/g&#x27; $&#123;CONFIG&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 20 行追加local_root 之后换行追加</span></span><br><span class="line">sed  -i ‘19alocal_root=/mnt/pub/\nchroot_local_user=YES\nchroot_local_user=YES\nallow_writeable_chroot=YES’ $&#123;CONFIG&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> =============正式配置结束====================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">systemctl restart vsftpd</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line">  echo -e &quot;\033[31m 启动失败，请自行查找其它原因！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line">echo -e &quot;\033[32m ftp 服务已配置完成，可正常使用！ \033[0m&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-13-实战3"><a href="#6-13-实战3" class="headerlink" title="6.13 实战3"></a>6.13 实战3</h3><p>​    写一个自动化shell脚本，一键安装apache服务器，自动发布网站，分别通过<a href="http://www.hr.com,www.test.com访问网站!(dns)/">www.hr.com，www.test.com访问网站！（DNS）</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙开启ftp服务</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=httpd &amp;&gt; /dev/null</span><br><span class="line">firewall-cmd --reload &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把 selinux 安全机制关了</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否安装httpd</span></span><br><span class="line">rpm -qa | grep &quot;httpd&quot;</span><br><span class="line">if [ ! $? -eq 0  ]</span><br><span class="line">then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 通过网络源安装 httpd</span></span><br><span class="line">  yum install -y httpd  &amp;&gt; /dev/null</span><br><span class="line">else</span><br><span class="line">  echo -e &quot;\033[31m 软件已安装，请去确认配置文件是否已经被修改！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果网络yum源用不了，则跟换本地yum源</span></span><br><span class="line">rpm -qa | grep &quot;httpd&quot;</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 执行挂载脚本</span></span><br><span class="line">  sh mount_disk</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 再安装</span></span><br><span class="line">  yum install -y httpd  &amp;&gt; /dev/null</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看80端口是否被占用：netstat -lanpt | grep 80</span></span><br><span class="line">SER_NAME=`netstat -lanpt | grep :80 | awk &#x27;&#123;print $7&#125;&#x27; | awk -F/ &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果端口被占用，就把对应服务停掉</span></span><br><span class="line">if [ ! -z $&#123;SER_NAME&#125; ]</span><br><span class="line">then</span><br><span class="line">  SER_ID=`ps -aux | grep $&#123;SER_NAME&#125; | awk &#x27;NR==1 &#123;print $2&#125;&#x27;`</span><br><span class="line">  kill - 9 $&#123;SER_ID&#125;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 httpd 开机自启</span></span><br><span class="line">systemctl enable httpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 httpd 服务</span></span><br><span class="line">systemctl start httpd</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 启动 httpd 服务失败, 退出</span></span><br><span class="line">  echo -e &quot;\033[31m 启动失败，请自行查找其它原因！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取本机IP地址</span></span><br><span class="line">IP_ADDR=`ifconfig | grep inet | awk &#x27;NR==1 &#123;print $2&#125;&#x27;`</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改hosts文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改之前也可以判断一下是否存在</span></span><br><span class="line">echo &quot;$&#123;IP_ADDR&#125; www.exam.com&quot; &gt;&gt; /etc/hosts</span><br><span class="line">echo &quot;$&#123;IP_ADDR&#125; www.hr.com&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改httpd主配置文件</span></span><br><span class="line">CONFIG=&quot;/etc/httpd/conf/httpd.conf&quot;</span><br><span class="line">echo &quot;Include conf/vhost/*.conf&quot; &gt;&gt; $&#123;CONFIG&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建vhost目录, 配置权限</span></span><br><span class="line">mkdir /etc/httpd/conf/vhost</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别为exam 和 hr 配置</span></span><br><span class="line">cd /etc/httpd/conf/vhost</span><br><span class="line">cat &lt;&lt; EOF &gt; exam.conf</span><br><span class="line">&lt;VirtualHost $&#123;IP_ADDR&#125;&gt;</span><br><span class="line">ServerName www.exam.com</span><br><span class="line">DocumentRoot /var/www/html/exam/</span><br><span class="line">&lt;Directory &quot;/var/www/html/exam/&quot;&gt;</span><br><span class="line">Options Indexes FollowSymLinks</span><br><span class="line">AllowOverride none</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; hr.conf</span><br><span class="line">&lt;VirtualHost $&#123;IP_ADDR&#125;&gt;</span><br><span class="line">ServerName www.hr.com</span><br><span class="line">DocumentRoot /var/www/html/hr/</span><br><span class="line">&lt;Directory &quot;/var/www/html/hr/&quot;&gt;</span><br><span class="line">Options Indexes FollowSymLinks</span><br><span class="line">AllowOverride none</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改两个文件的权限为apache</span></span><br><span class="line">chown -R apache /etc/httpd/conf/vhost</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 httpd 服务</span></span><br><span class="line">systemctl restart httpd &amp;&gt; /dev/null</span><br><span class="line">if [ $? ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;一键部署apache成功！&quot;</span><br><span class="line">else </span><br><span class="line">  echo &quot;一键部署apache失败！&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="第七章-（未完）用户-amp-组-amp-权限篇"><a href="#第七章-（未完）用户-amp-组-amp-权限篇" class="headerlink" title="第七章 （未完）用户&amp;组&amp;权限篇"></a>第七章 （未完）用户&amp;组&amp;权限篇</h2><h3 id="7-1-用户管理命令"><a href="#7-1-用户管理命令" class="headerlink" title="7.1 用户管理命令"></a>7.1 用户管理命令</h3><ol>
<li><p>useradd – 添加新用户</p>
<p><u>useradd 所在路径：/usr/sbin/useradd</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203164235451.png" alt="image-20210203164235451">-</p>
<hr>
<p><img src="/2021/08/25/16-07-33/image-20210203165210798.png" alt="image-20210203165210798">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203164925425.png" alt="image-20210203164925425">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203165129899.png" alt="image-20210203165129899">-</p>
<!--”-d：给新创建的用户指定家目录 “-->

<!--因为此命令在sbin下，所以只有root才能执行此命令--></li>
<li><p>passwd – 给用户设置密码</p>
<p><u>passwd 所在路径：/usr/sbin/passwd</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203165430300.png" alt="image-20210203165430300">-</p>
</li>
<li><p>who – 查看登录用户信息</p>
<p><u>who 所在路径：/usr/bin/who</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203165508361.png" alt="image-20210203165508361">-</p>
</li>
<li><p>w – 查看登录用户详细信息</p>
<p><u>w 所在路径：/usr/bin/w</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203165633539.png" alt="image-20210203165633539">-</p>
</li>
</ol>
<h3 id="7-3-权限管理命令"><a href="#7-3-权限管理命令" class="headerlink" title="7.3 权限管理命令"></a>7.3 权限管理命令</h3><p><img src="/2021/08/25/16-07-33/image-20210203153309815.png" alt="image-20210203153309815">-</p>
<p>  <strong>权限的数字表示形式：r = 4 、w = 2、x = 1</strong></p>
<ol>
<li><p>chmod – 改变文件或目录的<strong>权限</strong></p>
<p>chmod 的英文原意为：<strong>change the permissions mode of a file</strong></p>
<p><u>chmod 所在路径：/bin/chmod</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203154813432.png" alt="image-20210203154813432">-</p>
<!--格式：chmod [{ugoa} {+-=} {rwx}] [文件或目录]、-R 递归修改--></li>
<li><p>chown – 改变文件或目录的所有者</p>
<p>chown 的英文原意为：<strong>change file ownership</strong></p>
<p><u>chown 所在路径：/bin/chown</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203154020530.png" alt="image-20210203154020530">-</p>
<!--改变文件sa的所有者为chen--></li>
<li><p>chgrp – 改变文件或目录的<strong>所属组</strong></p>
<p>chgrp 的英文原意为：<strong>change file group ownership</strong></p>
<p><u>chgrp 所在路径：/bin/chgrp</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203153817834.png" alt="image-20210203153817834">-</p>
<!--改变文件sa的所属组为chen--></li>
<li><p>umask – 显示、设置文件的缺省权限</p>
<p>umask 的英文原意为：<strong>the user file-creation mask</strong></p>
<p><u>umask 所在路径：Shell内置命令</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210203151253400.png" alt="image-20210203151253400">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203151356650.png" alt="image-20210203151356650">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210203151557010.png" alt="image-20210203151557010">-</p>
<!--“-S 以rwx形式显示新建文件缺省权限，注意上面创建的文件为什么没有x呢？mask 是掩码的意思，，，，，未完待续”-->

<p>umask对于<strong>普通权限</strong>默认是022，<strong>文件夹</strong>的默认权限是777，<strong>文件</strong>是666，所以设置了umask之后，生成的<strong>文件夹</strong>的默认权限是777-022=755=rwxr-xr-x：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302175251323.png" alt="image-20210302175251323">-</p>
<p>生成的<strong>文件</strong>的默认权限是666-022=644=rw-r–r–：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302175435169.png" alt="image-20210302175435169">-</p>
<p>umask对于特殊权限默认是0，特殊权限有：SUID、SGID、SBIT</p>
<p><strong>SUID（Set UID）</strong>：<strong>以所有者的身份执行</strong>，把x变为s</p>
<p>​    例如：/usr/bin/passwd 文件，虽然文件所有者和所属组都是root，但普通用户还是可以修改自己的密码，就是这个意思，但是只有可执行的二进制程序才能设定这个权限</p>
<p><strong>SGID（Set GID）</strong>：<strong>以所属组的身份执行</strong>，把x变为s</p>
<p>​    针对目录：</p>
<p>​    ，但是只有可执行的二进制程序才能设定这个权限</p>
<p>​    针对文件：</p>
<p>​    例如：root用户创建了一个文件夹，本来其他人不能操作这个文件夹（添加文件，删除文件），但是有了这个权限之后，就可以了，即使不是同一个组</p>
<p><strong>SBIT（Sticky BIT）</strong>：</p>
<p>​    仅针对目录有效，如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一但赋予了粘着位，除了root 可以删除所有文件，普通用户就算拥有w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</p>
<!--未完待续--></li>
</ol>
<h2 id="第八章-服务管理篇"><a href="#第八章-服务管理篇" class="headerlink" title="第八章 服务管理篇"></a>第八章 服务管理篇</h2><p>​    服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它进程的请求，比如（mysql、sshd、防火墙等），因此又称为守护进程。</p>
<p>​    服务一共有7种运行级别：</p>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">单用户工作状态，root权限，用于系统维护，禁止远程登陆</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">多用户状态（没有NFS），不支持网络</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center">完全的多用户状态（有NFS），登录后进入控制台命令模式</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">系统未使用，保留</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center">X11控制台，登录后进入图形GUI模式</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">系统正常关闭重启，默认运行级别不能设为6，否则不能正常启动</td>
</tr>
</tbody></table>
<p>​    <!--NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。--></p>
<p>CentOS 7 之后运行级别说明：<code>head /etc/inittab</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210205201221615.png" alt="image-20210205201221615">-</p>
<p>​    <!--常用3和5--></p>
<p>修改运行级别：<code>systemctl set-default graphical.target</code>（修改为带图像界面）</p>
<p>开机流程：</p>
<p>​    <strong>开机 –&gt; BIOS –&gt; /boot –&gt; systemd进程1 –&gt; 运行级别 –&gt; 运行对应服务</strong></p>
<h3 id="8-1-service-管理指令"><a href="#8-1-service-管理指令" class="headerlink" title="8.1 service 管理指令"></a>8.1 service 管理指令</h3><ol>
<li><p>service 服务名 [start | stop | restart | reload | status]</p>
</li>
<li><p>在CentOS 7 之后，很多服务不再使用<strong>service</strong>，而是使用<strong>systemctl</strong></p>
</li>
<li><p>service指令管理的服务可以通过 <strong>/etc/init.d</strong> 目录查看，或者使用<strong>setup</strong>命令</p>
<p><img src="/2021/08/25/16-07-33/image-20210205194005608.png" alt="image-20210205194005608">-</p>
<ol start="4">
<li>下面把宝塔服务关闭：</li>
</ol>
<p><img src="/2021/08/25/16-07-33/image-20210205194444618.png" alt="image-20210205194444618">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210205194508180.png" alt="image-20210205194508180">-</p>
</li>
</ol>
<h3 id="8-2-chkconfig-管理指令"><a href="#8-2-chkconfig-管理指令" class="headerlink" title="8.2 chkconfig 管理指令"></a>8.2 chkconfig 管理指令</h3><p>​    通过chkconfig命令可以给服务的各个运行级别设置：自启动/关闭。chkconfig指令管理的服务在 /etc/init.d 查看。</p>
<p><code>chkconfig --list</code> 查看服务</p>
<p><img src="/2021/08/25/16-07-33/image-20210205202213438.png" alt="image-20210205202213438">-</p>
<!--可以配合grep命令-->

<p><code>chkconfig 服务名 --list</code> 查看单个服务</p>
<p><img src="/2021/08/25/16-07-33/image-20210205202347300.png" alt="image-20210205202347300">-</p>
<p><code>chkconfig --level n 服务名 on/off</code> 修改服务级别为n</p>
<p>例如：把network服务在级别3的自启动关闭：<code>chkconfig --level 3 network off</code></p>
<!--chkconfig重新设置服务自启动或关闭后，需要重启生效-->

<h3 id="8-3-systemctl-管理指令"><a href="#8-3-systemctl-管理指令" class="headerlink" title="8.3 systemctl 管理指令"></a>8.3 systemctl 管理指令</h3><p>​    基本语法：systemctl [start | stop | restart | status] 服务名</p>
<p><img src="/2021/08/25/16-07-33/image-20210205204125678.png" alt="image-20210205204125678">-</p>
<p>​    systemctl指令管理的服务在 <strong>/usr/lib/systemd/system</strong> 查看</p>
<p><img src="/2021/08/25/16-07-33/image-20210205203537036.png" alt="image-20210205203537036">-</p>
<p>​    <strong>systemctl设置服务的自启动状态：</strong></p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">systemctl liist-unit-files [| grep 服务名]</td>
<td align="center">查看服务开机启动状态，grep过滤一下</td>
</tr>
<tr>
<td align="center">systemctl enable 服务名</td>
<td align="center">设置服务开机启动</td>
</tr>
<tr>
<td align="center">systemctl disable 服务名</td>
<td align="center">关闭服务开机启动</td>
</tr>
<tr>
<td align="center">systemctl is-enabled 服务名</td>
<td align="center">查询某个服务是否自启动</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210205203723211.png" alt="image-20210205203723211">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210205204002591.png" alt="image-20210205204002591">-</p>
<h3 id="8-4-ntsysv-管理指令"><a href="#8-4-ntsysv-管理指令" class="headerlink" title="8.4 ntsysv 管理指令"></a>8.4 ntsysv 管理指令</h3><p>​    Linux ntsysv命令用于设置系统的各种服务的<strong>自启动</strong>。</p>
<p>​    这个跟 <strong>systemctl enable</strong> 功能一样</p>
<p>​    这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务，跟<strong>setup</strong>作用一样，按<strong>tab键</strong>可转到确定和退出那行</p>
<p><img src="/2021/08/25/16-07-33/image-20210207095849146.png" alt="image-20210207095849146"></p>
<h3 id="8-5-iptables-管理指令"><a href="#8-5-iptables-管理指令" class="headerlink" title="8.5 iptables 管理指令"></a>8.5 iptables 管理指令</h3><h4 id="8-5-1-iptables-基本介绍"><a href="#8-5-1-iptables-基本介绍" class="headerlink" title="8.5.1 iptables 基本介绍"></a>8.5.1 iptables 基本介绍</h4><p>​    Netfilter/iptables IP数据包过滤系统实际由netfilter和<strong>iptables</strong>两个组件构成。Netfilter是集成在内核中的一部分，它的作用是定义、保存相应的规则。而<strong>iptables</strong>是一种工具，用以修改信息的过滤规则及其他配置。用户可以通过iptables来设置适合当前环境的规则，而这些规则会保存在内核空间中。对于Linux服务器而言，采用netfilter/iptables 数据包过滤系统，能够节约软件成本，并可以提供强大的数据包过滤控制功能，iptables是理想的防火墙解决方案。</p>
<p><img src="/2021/08/25/16-07-33/image-20210308120351694.png" alt="image-20210308120351694">-</p>
<p><strong>iptables默认的4个规则表</strong>：</p>
<p>​    <strong>raw表</strong>：确定是否对该数据包进行状态跟踪</p>
<p>​    <strong>mangle表</strong>：为数据包设置标记</p>
<p>​    <strong>nat表</strong>：修改数据包中的源、目标ip地址或端口</p>
<p>​    <strong>filter表</strong>：确定是否放行该数据包（过滤）</p>
<p><strong>iptables默认的5种规则链</strong>：</p>
<p>​    <strong>INPUT</strong>：处理入站数据包</p>
<p>​    <strong>OUTPUT</strong>：处理出站数据包</p>
<p>​    <strong>FORWARD</strong>：处理转发数据包</p>
<p>​    <strong>POSTROUTING</strong>：在进行路由选择后处理数据包</p>
<p>​    <strong>PREROUTING</strong>：在进行路由选择前处理数据包</p>
<p>其中<strong>INPUT</strong>、<strong>OUTPUT</strong>链主要用在“主机型防火墙”中，主要针对服务器本机进行保护；</p>
<p>而<strong>FORWARD</strong>、<strong>POSTROUTING</strong>、<strong>PREROUTING</strong>多用在“网络型防火墙”中，如使用Linux防火墙作为网关服务器，在公司内网与Ineternet之间进行安全控制。</p>
<p><strong>匹配顺序</strong>：</p>
<ol>
<li><strong>规则表之间</strong>的顺序：<strong>raw –&gt; mangle –&gt; nat –&gt; filter</strong></li>
<li><strong>规则链之间</strong>的顺序：<strong>不同链的处理时机比较固定，顺序取决于数据包的流向</strong>，具体看下面的流程介绍</li>
<li>规则链内部各条防火墙<strong>规则之间</strong>的顺序：<strong>从上往下，一旦匹配，立即终止</strong></li>
</ol>
<p><strong>经过iptables的数据包的流程介绍</strong>：</p>
<p>一个数据包到达时,是怎么依次穿过各个链和表的，如下图所示：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210308115733481.png" alt="image-20210308115733481">-</p>
<p><strong>基本步骤如下</strong>：</p>
<ol>
<li>数据包到达网络接口，比如 eth0。</li>
<li>进入 raw 表的 PREROUTING 链，这个链的作用是赶在连接跟踪之前处理数据包。</li>
<li>如果进行了连接跟踪，在此处理。</li>
<li>进入 mangle 表的 PREROUTING 链，在此可以修改数据包，比如 TOS 等。</li>
<li>进入 nat 表的 PREROUTING 链，可以在此做DNAT，但不要做过滤。</li>
<li>决定路由，看是交给本地主机还是转发给其它主机。</li>
</ol>
<p><strong>到了这里我们就得分两种不同的情况进行讨论了，一种情况就是数据包要转发给其它主机，这时候它会依次经过</strong>：</p>
<ol start="7">
<li>进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。</li>
<li>进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。</li>
<li>进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。</li>
<li>进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。</li>
<li>进入出去的网络接口。完毕。</li>
</ol>
<p><strong>另一种情况是，数据包就是发给本地主机的，那么它会依次穿过</strong>：</p>
<ol start="7">
<li>进入 mangle 表的 INPUT 链，这里是在路由之后，交由本地主机之前，我们也可以进行一些相应的修改。</li>
<li>进入 filter 表的 INPUT 链，在这里我们可以对流入的所有数据包进行过滤，无论它来自哪个网络接口。</li>
<li>交给本地主机的应用程序进行处理。</li>
<li>处理完毕后进行路由决定，看该往那里发出。</li>
<li>进入 raw 表的 OUTPUT 链，这里是在连接跟踪处理本地的数据包之前。</li>
<li>连接跟踪对本地的数据包进行处理。</li>
<li>进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤。</li>
<li>进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做 NAT 。</li>
<li>再次进行路由决定。</li>
<li>进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。</li>
<li>进入 mangle 表的 POSTROUTING 链，同上一种情况的第9步。注意，这里不光对经过防火墙的数据包进行处理，还对防火墙自己产生的数据包进行处理。</li>
<li>进入 nat 表的 POSTROUTING 链，同上一种情况的第10步。</li>
<li>进入出去的网络接口。完毕。</li>
</ol>
<h4 id="8-5-2-iptables的基本格式"><a href="#8-5-2-iptables的基本格式" class="headerlink" title="8.5.2 iptables的基本格式"></a>8.5.2 iptables的基本格式</h4><p>​    首先关闭firewalld：<code>systemctl stop firewalld</code></p>
<p>​    然后安装iptables：<code>yum install -y iptables-services</code></p>
<p>​    再设置开机启动iptables：<code>systemctl enable iptables</code></p>
<p>​    打开iptables：<code>systemctl start iptables</code></p>
<p>​    保存设置：<code>service iptables save</code></p>
<p>​    重启iptables服务：<code>service iptables restart</code> || <code>systemctl restart iptables</code></p>
<p><strong>iptables语法格式</strong>：</p>
<p>​    <strong>iptables</strong> <strong>[-t</strong> 表名**]** <strong>管理选项</strong> [<strong>链名</strong>] [<strong>条件匹配</strong>] [<strong>-j</strong> 目标动作]</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-A</td>
<td align="center">在链尾追加一条新的规则</td>
</tr>
<tr>
<td align="center">-I</td>
<td align="center">在指定位置（或链首）插入一条新的规则</td>
</tr>
<tr>
<td align="center">-P</td>
<td align="center">设置指定链的默认策略</td>
</tr>
<tr>
<td align="center">-L</td>
<td align="center">列表查看各条规则的信息</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">删除指定位置或内容的规则</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">清空规则链内的所有规则</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">查看iptables命令的使用帮助</td>
</tr>
</tbody></table>
<p>注意事项：</p>
<ol>
<li>不指定表名时，默认表示filter表</li>
<li>不指定链名时，默认表示该表内所有链</li>
<li>除非设置规则链得缺省策略，否则需要指定匹配条件</li>
</ol>
<table>
<thead>
<tr>
<th align="center">匹配条件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通用匹配</td>
<td align="center">可以直接使用，不依赖于其他的条件或扩展模块，包括网络协议、IP地址、网络接口等匹配方式</td>
</tr>
<tr>
<td align="center">协议匹配</td>
<td align="center">使用“**-p 协议名**”的形式，协议名可使用在”/etc/protocols”文件中定义的名称，常用的协议包括tcp、udp、icmp等</td>
</tr>
<tr>
<td align="center">地址匹配</td>
<td align="center">使用”<strong>-s 源地址</strong>“、”<strong>-d 目标地址</strong>“的形式，地址可以是单个IP地址、网络地址（带掩码长度）</td>
</tr>
<tr>
<td align="center">接口匹配</td>
<td align="center">使用”<strong>-i 网络接口名</strong>“、”<strong>-o 网络接口名</strong>“的形式，分别对应接收、发送数据包的网络接口</td>
</tr>
<tr>
<td align="center">隐含条件匹配</td>
<td align="center">一般需要以特定的协议匹配作为前提，包括端口、TCP标记、ICMP类型等匹配方式</td>
</tr>
<tr>
<td align="center">端口匹配</td>
<td align="center">使用”<strong>-sport 源端口</strong>“、”<strong>-dport 目标端口</strong>“的形式，采用”<strong>端口1：端口2</strong>“的形式可以指定一个范围的端口</td>
</tr>
<tr>
<td align="center">TCP标记匹配</td>
<td align="center">使用”<strong>-tcp-flags 检查范围 被设置的标记</strong>“的形式，如”<strong>–tcp-flags SYN,RST,ACK SYN</strong>“表示检查SYN、RST、ACK这三个标记，只有SYN为1时满足条件</td>
</tr>
<tr>
<td align="center">ICMP类型匹配</td>
<td align="center">使用”<strong>–icmp-type ICMP类型</strong>“的形式，ICMP类型可以使用类型字符串或者对应的数值，例如Echo-Request、Echo-Reply</td>
</tr>
<tr>
<td align="center">显示条件匹配</td>
<td align="center">需要使用”<strong>-m 扩展模块</strong>“的形式明确指定匹配方式</td>
</tr>
<tr>
<td align="center">MAC地址匹配</td>
<td align="center">使用**”-m mac**”结合”<strong>–mac-source MAC地址</strong>“的形式</td>
</tr>
<tr>
<td align="center">多端口匹配</td>
<td align="center">使用”<strong>-m multiport</strong>“结合”<strong>–sports 源端口列表</strong>“或者”<strong>-dports 目标端口列表</strong>“的形式，多个端口之间使用逗号”<strong>,</strong>“分隔，连续的端口也可以使用冒号”<strong>:</strong>“分隔</td>
</tr>
<tr>
<td align="center">IP地址范围匹配</td>
<td align="center">使用”<strong>-m iprange</strong>“结合”<strong>–src-range 源IP范围</strong>“或者”<strong>–dst-range 目标IP范围</strong>“的形式</td>
</tr>
</tbody></table>
<p>常见的数据包处理方式：</p>
<table>
<thead>
<tr>
<th align="center">处理方式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACCEPT</td>
<td align="center">旅行数据包</td>
</tr>
<tr>
<td align="center">DROP</td>
<td align="center">丢弃数据包</td>
</tr>
<tr>
<td align="center">REJECT</td>
<td align="center">拒绝数据包</td>
</tr>
<tr>
<td align="center">SNAT</td>
<td align="center">修改数据包的源地址信息</td>
</tr>
<tr>
<td align="center">DNAT</td>
<td align="center">修改数据包的目标地址信息</td>
</tr>
</tbody></table>
<h4 id="8-5-3-iptables的具体实操"><a href="#8-5-3-iptables的具体实操" class="headerlink" title="8.5.3 iptables的具体实操"></a>8.5.3 iptables的具体实操</h4><p>1、拒绝192.168.0.1访问web服务：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308203509976.png" alt="image-20210308203509976">-</p>
<!--注意，上面的iptables -L ，没有 -t 指定表名，默认查看的时filter表中的信息-->

<p><img src="/2021/08/25/16-07-33/image-20210308204317091.png" alt="image-20210308204317091"></p>
<!----line-number  查看的是fileter表中的信息，并显示行号-->

<p>备份规则集：<code>iptables-save &gt; /etc/iptables-save</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210308204720262.png" alt="image-20210308204720262">-</p>
<p>清空filter表：<code>iptables -t filter -F</code> </p>
<p><img src="/2021/08/25/16-07-33/image-20210308204828573.png" alt="image-20210308204828573">-</p>
<p>恢复规则集：<code>iptables-restore &lt; /etc/iptables-save</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210308205001524.png" alt="image-20210308205001524">-</p>
<p>保存更改的设置：<code>service iptables save</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210308205053623.png" alt="image-20210308205053623">-</p>
<p>2、拒绝192.168.0.0/24ping通服务器：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308203713003.png" alt="image-20210308203713003">-</p>
<p>3、允许192.168.1.0/24访问服务器的21与80端口：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308204000786.png" alt="image-20210308204000786">-</p>
<!--注意：-m multiport 后面必须跟 -p，不然会出错-->

<!--注意上面的"-A"都是在链尾追加-->

<p>4、允许192.168.5.0/24访问服务器的8080端口：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308205540546.png" alt="image-20210308205540546"></p>
<!--现在用的"-I"是在第一个位置添加-->

<p>5、允许192.168.9.0/24访问服务器的8080端口：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308205807086.png" alt="image-20210308205807086">-</p>
<!--现在时在第2条规则的前面添加-->

<p>5、删除OUTPUT链中的第一条规则：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308210103338.png" alt="image-20210308210103338">-</p>
<p>6、设置默认策略为拒绝所有链接：iptables -P OUTPUT DROP</p>
<p><img src="/2021/08/25/16-07-33/image-20210308210359444.png" alt="image-20210308210359444">-</p>
<p>然后XShell直接断开链接了，因为数据出来的时候被iptables拦截了，然后立即调回来，将默认策略改为允许：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308210637093.png" alt="image-20210308210637093">-</p>
<p>7、查看帮助信息：<code>iptables -h</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210308210747122.png" alt="image-20210308210747122">-</p>
<!--看着不错，就是认不到。。。。shit！！！-->

<p>8、使用 man 查看iptables手册：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308210843183.png" alt="image-20210308210843183"></p>
<p>9、拒绝icmp：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308211354061.png" alt="image-20210308211354061">-</p>
<p>10、删除上面的那条规则：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308211520104.png" alt="image-20210308211520104">-</p>
<!--只需要把"-A"换成"-D"就行了-->

<p>11、基于TCP包的目的端口来匹配包：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308211852339.png" alt="image-20210308211852339">-</p>
<p>12、基于目标网络来匹配包：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308212136519.png" alt="image-20210308212136519">-</p>
<p>13、以包离开本地所使用的网络来匹配：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308212234632.png" alt="image-20210308212234632">-</p>
<p>14、查看filter表中所有OUTPUT链的规则：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308212859051.png" alt="image-20210308212859051">-</p>
<p>15、禁止员工访问域名为<a href="http://www.xxxx.org的网站：">www.xxxx.org的网站：</a></p>
<p><img src="/2021/08/25/16-07-33/image-20210308214100617.png" alt="image-20210308214100617">-</p>
<p>注意：域名必须存在，且能被解析，否则会出错，下面放一个正确的域名上去：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308214143649.png" alt="image-20210308214143649">-</p>
<p>16、禁止员工访问IP地址为212.1.2.3的网站：</p>
<p><img src="/2021/08/25/16-07-33/image-20210308214535274.png" alt="image-20210308214535274">-</p>
<h4 id="8-5-4-NAT网络地址转换"><a href="#8-5-4-NAT网络地址转换" class="headerlink" title="8.5.4 NAT网络地址转换"></a>8.5.4 NAT网络地址转换</h4><p>​    NAT对于学过网络的我，就不用过多的解释了，直接上操作：</p>
<p>​    假如某公司需要Internet接入，由ISP分配IP地址202.112.113.112。<strong>采用iptables作为NAT服务器接入网络</strong>，内部采用192.168.1.0/24地址，外部采用202.112.113地址。为确保案例需要配置防火墙功能，要求内部web服务器192.168.1.100通过端口映射方式对外提供服务。</p>
<p>​    SNAT：源地址转换，通常指私有地址转换为公有地址，（内部数据发往外网的数据）对应的链postrouting（路由规则后的动作）</p>
<p>​    DNAT：目标地址转换，通常指公有地址转换为私有地址，（外网数据发往内网的数据）对应的链是prerouting（路由规则前的动作）</p>
<!--注意：SNAT和DNAT不是我理解的那样，必须成对出现，还有网上的内网穿透就是通过DNAT实现的，当使用了DNAT后，最好加上固定的一个端口号，不能直接将外网转换成内网地址，这就叫做端口地址转发，为的就是安全起见-->

<p>基操：</p>
<p>1、开启网关的路由转发功能：<code>vim /etc/sysctl.conf</code></p>
<p>2、终端执行：<code>sed -i &#39;s/net.ipv4.ip_forward = 0/net.ipv4.ip_forward = 1/&#39; /etc/sysctl.conf</code></p>
<p>​        <!--《插播一条信息：Linux sed命令是利用script来处理文本文件，而加上选项 -i ：直接修改读取的文件内容，而不是输出到终端，所以：`sed -i 's/原字符串/新字符串/' file`，意思是：替换掉每行的第一个字符串》--></p>
<p>​    所以：<code>sed -i &#39;s/net.ipv4.ip_forward = 0/net.ipv4.ip_forward = 1/&#39; /etc/sysctl.conf</code>的意思是：替换文件**/etc/sysctl.conf<strong>中的字符串</strong>net.ipv4.ip_forward = 0<strong>为</strong>net.ipv4.ip_forward = 1**</p>
<p>​    <strong>But，这个文件是空的。。。。。。替换个啥？</strong></p>
<p>​    答案来了，如果文件为空，则直接往文件里面加上：<strong>net.ipv4.ip_forward = 1</strong></p>
<p>3、执行：<code>sysctl -p</code></p>
<p>3、添加使用DNAT策略的防火墙规则</p>
<p>​    <code>iptables -t nat -A PREROUTING -i 网卡 -d 外网地址 -p tcp --dport 80 -j DNAT --to-destination 内网地址</code></p>
<p>4、然后把XP系统加入到这台CentOS的子网中：</p>
<p>​    <!--其实你设置虚拟机的网络适配器的时候，也是选的NAT，因为虚拟机上面的操作系统也属于内网主机，通过本机去访问外网--></p>
<p>​    <!--刚才张老师过来让我放弃，目前这个操作不实用--></p>
<h3 id="8-6-firewalld-管理指令"><a href="#8-6-firewalld-管理指令" class="headerlink" title="8.6 firewalld 管理指令"></a>8.6 firewalld 管理指令</h3><p>​    <strong>firewalld</strong>防火墙是CentOS7版本系统默认的防火墙管理工具，取代了之前的<strong>iptables</strong>防火墙，与iptables防火墙一样也属于典型的<strong>包过滤防火墙</strong>或称之为<strong>网络层防火墙</strong>，firewalld和iptables都是用来管理防火墙的工具（属于用户态）来定义防火墙的各种规则功能，内部结构都指向netfilter这一强大的网络过滤子系统（属于内核态）以实现包过滤防火墙功能。firewalld防火墙最大的优点在于<strong>支持动态更新</strong>以及加入了防火墙的“<strong>Zone</strong>”概念，firewalld防火墙<strong>支持IPV4和IPV6地址</strong>。可以通过<u>字符管理工具<strong>firewall-cmd</strong></u>和<u>图形化管理工具<strong>firewall-config</strong></u>进行管理</p>
<p>​    <strong>Zone的概念</strong>：</p>
<p>​    firewalld防火墙为了简化管理，<strong>将所有网络流量分为多个区域（zone）</strong>。然后要所数据包的源IP地址或传入的网络接口条件等将流量<strong>传入相应区域</strong>。每个区域都定义了自己打开或关闭的端口服务列表。其中<strong>默认区域为public区域</strong>，<strong>trusted区域</strong>默认允许所有流量通过，是一个特殊的区域。</p>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Trusted</td>
<td align="center">允许所有的传入流量</td>
</tr>
<tr>
<td align="center">Home</td>
<td align="center">允许与ssh、mdns、ipp-client、samba-client或dhcpv6-client预定义服务匹配的传入流量，其余均拒绝</td>
</tr>
<tr>
<td align="center">Internal</td>
<td align="center">默认值时与home区域相同</td>
</tr>
<tr>
<td align="center">Work</td>
<td align="center">允许与ssh、ipp-client或dhcpv6-client预定义服务匹配的传入流量，其余均拒绝</td>
</tr>
<tr>
<td align="center">Public</td>
<td align="center">允许与ssh或dhcpv6-client预定义服务匹配的传入流量，其余均拒绝。是新添加网络接口的默认区域</td>
</tr>
<tr>
<td align="center">External</td>
<td align="center">允许与ssh预定义服务匹配的传入流量，其余均拒绝。默认将经过此区域转发的IPv4地址传出流量进行地址伪装</td>
</tr>
<tr>
<td align="center">Dmz</td>
<td align="center">允许与ssh预定义服务匹配的传入流量，其余均拒绝</td>
</tr>
<tr>
<td align="center">Block</td>
<td align="center">拒绝所有传入流量</td>
</tr>
<tr>
<td align="center">Drop</td>
<td align="center">丢弃所有传入流量</td>
</tr>
</tbody></table>
<p>​    在流量经过防火墙时，firewalld防火墙会对传入的每个数据包进行检查，如果此数据包的源地址关联到特定的区域，则会应用该区域的规则对此数据包进行处理，如果该源地址没有关联到任何区域，则将使用传入网络接口所在的区域规则进行处理。如果流量与不允许的端口、协议或者服务匹配，则防火墙拒绝传入流量</p>
<h4 id="8-6-1-字符管理工具：fire-wall-cmd"><a href="#8-6-1-字符管理工具：fire-wall-cmd" class="headerlink" title="8.6.1 字符管理工具：fire-wall-cmd"></a>8.6.1 字符管理工具：fire-wall-cmd</h4><p>​    firewall-cmd是firewalld防火墙自带的字符管理工具，可以用来设置firewalld防火墙的各种规则，需要注意的是firewalld防火墙规则分为两种状态，<strong>一种是runtime(正在运行生效的状态）</strong>，在runtime状态添加新的防火墙规则，这些规则会立即生效，但是重新加载防火墙配置或者重启系统后这些规则将会失效；<strong>一种是permanent（永久生效的状态）</strong>，在permanent状态添加新的防火墙规则，这些规则不会马上生效，需要重新加载防火墙配置或者重启系统后生效。</p>
<p>​    在使用firewall-cmd命令管理防火墙时，需要添加为永久生效的规则需要在配置规则时添加**–permanent**选项（否则所有命令都是作用于runtime，运行时配置）,如果让永久生效规则立即覆盖当前规则生效使用，还需要使用<code>firewall-cmd --reload</code>命令重新加载防火墙配置。</p>
<table>
<thead>
<tr>
<th align="center">firewall-cmd命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–get-default-zone</td>
<td align="center">查看当前默认区域</td>
</tr>
<tr>
<td align="center">–get–active-zones</td>
<td align="center">列出当前正在使用的区域及其所对应的网卡接口</td>
</tr>
<tr>
<td align="center">–get-zones</td>
<td align="center">列出所有可用的区域</td>
</tr>
<tr>
<td align="center">–set-default-zone=<ZONE></ZONE></td>
<td align="center">设置默认区域（注意此命令会同时修改运行时配置和永久配置）</td>
</tr>
<tr>
<td align="center">–add-source=<CIDR>[–zone=<ZONE>]</ZONE></CIDR></td>
<td align="center">将来自IP地址或网段的所有流量路由到指定区域，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–remove-source=<CIDR>[–zone=&lt;ZONE]</CIDR></td>
<td align="center">从指定区域中删除来自IP地址或网段的所有路由流量规则，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–add-interface=<Interface>[–zone=&lt;ZONE]</Interface></td>
<td align="center">将来自该接口的所有流量都路由到指定区域。没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–change-interface=<Interface>[–zone=&lt;ZONE]</Interface></td>
<td align="center">将接口与指定区域做关联，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–list-all[–zone=&lt;ZONE]</td>
<td align="center">列出指定区域已配置接口、源、服务、端口等信息，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–add-service=<SERVICE>[–zone=&lt;ZONE]</SERVICE></td>
<td align="center">允许到该服务的流量通过指定区域，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–remove-service=<SERVICE>[–zone=&lt;ZONE]</SERVICE></td>
<td align="center">从指定区域的允许列表中删除该服务，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–add-port=&lt;PORT/PROTOCOL&gt;[–zone=&lt;ZONE]</td>
<td align="center">允许到该端口的流量通过指定区域，没有指定区域时使用默认区域。</td>
</tr>
<tr>
<td align="center">–remove-port=&lt;PORT/PROTOCOL&gt;[–zone=&lt;ZONE]</td>
<td align="center">从指定区域的允许列表中删除该端口，没有指定区域时使用默认区域。</td>
</tr>
</tbody></table>
<h5 id="8-6-1-1-区域管理"><a href="#8-6-1-1-区域管理" class="headerlink" title="8.6.1.1 区域管理"></a>8.6.1.1 区域管理</h5><p>1、查看查看当前默认区域：<code>firewall-cmd --get-default-zone</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309124818648.png" alt="image-20210309124818648">-</p>
<p>2、列出当前正在使用的区域及其所对应的网卡接口：<code>firewall-cmd --get-active-zones</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309124853849.png" alt="image-20210309124853849">-</p>
<p>3、列出所有可用的区域：<code>firewall-cmd --get-zones</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309124947325.png" alt="image-20210309124947325">-</p>
<p>4、设置默认区域：<code>firewall-cmd --set-default-zone=home</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309125124771.png" alt="image-20210309125124771">-</p>
<h5 id="8-6-1-2-服务管理"><a href="#8-6-1-2-服务管理" class="headerlink" title="8.6.1.2 服务管理"></a>8.6.1.2 服务管理</h5><p>1、查看预定义服务：<code>firewall-cmd --get-services</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309125855731.png" alt="image-20210309125855731">-</p>
<p>2、查看public区域已配置的规则：<code>firewall-cmd --list-all --zone=public</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309130149554.png" alt="image-20210309130149554">-</p>
<p>3、添加http服务到public区域：<code>firewall-cmd --add-service=http --zone=public --permanent</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309130252569.png" alt="image-20210309130252569">-</p>
<p>又上图可知，使用permanent不会立即生效，还需要使用：<code>firewall-cmd --reload</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309130438445.png" alt="image-20210309130438445">-</p>
<p>4、移除在public区域添加的http服务：<code>firewall-cmd --remove-service=http --permanent --zone=public</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309130641574.png" alt="image-20210309130641574">-</p>
<p>5、同时将多个服务添加到某一个区域：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309131057163.png" alt="image-20210309131057163">-</p>
<!--不添加--permanent选项表示是即时生效的临时设置-->

<!--不使用--zone指定区域时使用默认区域-->

<h5 id="8-6-1-3-端口管理"><a href="#8-6-1-3-端口管理" class="headerlink" title="8.6.1.3 端口管理"></a>8.6.1.3 端口管理</h5><p>1、允许TCP的3306端口到public区域：<code>firewall-cmd --add-port=3306/tcp</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309131405787.png" alt="image-20210309131405787">-</p>
<p>2、从public区域将TCP的3306端口移除：<code>firewall-cmd --remove-port=3306/tcp</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309131502821.png" alt="image-20210309131502821">-</p>
<p>3、允许某一范围的端口，如允许UDP的2048-2050端口到public区域：</p>
<p>​    <code>firewall-cmd --add-port=2048-2050/udp --zone=public</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309131629982.png" alt="image-20210309131629982">-</p>
<p>4、查看加入的端口操作是否成功：<code>firewall-cmd --list-ports</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309140748877.png" alt="image-20210309140748877">-</p>
<p>注意：前面使用的都是 –list-all，其实这个all可以换成列表中的任何一个参数，例如：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309140833254.png" alt="image-20210309140833254">-</p>
<!--这里查看的是服务-->

<h5 id="8-6-1-4-伪装IP地址"><a href="#8-6-1-4-伪装IP地址" class="headerlink" title="8.6.1.4 伪装IP地址"></a>8.6.1.4 伪装IP地址</h5><p>​    伪装IP，就是通过NAT实现的</p>
<p>实操：</p>
<p>​    检查是否允许伪装IP：<code>firewall-cmd --query-masquerade</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210309215309629.png" alt="image-20210309215309629">-</p>
<p>​    妹的，居然不允许！</p>
<p>​    允许防火墙伪装IP：<code>firewall-cmd --permanent --add-masquerade</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210310110814844.png" alt="image-20210310110814844">-</p>
<p>​    我管你允不允许！</p>
<h5 id="8-6-1-5-端口转发–分流"><a href="#8-6-1-5-端口转发–分流" class="headerlink" title="8.6.1.5 端口转发–分流"></a>8.6.1.5 端口转发–分流</h5><p>​    在防火墙上阻止22端口访问，然后再开一个不规则的端口8080，之后配置防火墙的<strong>端口转发</strong>，将流量转发过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-masquerade # 我在想，需要加上这句吗？</span><br><span class="line">firewall-cmd --add-forward-port=port=8080:proto=tcp:toport=22</span><br><span class="line">firewall-cmd --add-port=8080/tcp   # 允许访问8080端口</span><br><span class="line">firewall-cmd --remove-service=ssh  # 拒绝访问22端口</span><br></pre></td></tr></table></figure>

<p>实验结果就是，这样：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310111735988.png" alt="image-20210310111735988">-</p>
<h5 id="8-6-1-6-多区域的应用"><a href="#8-6-1-6-多区域的应用" class="headerlink" title="8.6.1.6 多区域的应用"></a>8.6.1.6 多区域的应用</h5><h5 id="8-6-1-7-直接规则的应用"><a href="#8-6-1-7-直接规则的应用" class="headerlink" title="8.6.1.7 直接规则的应用"></a>8.6.1.7 直接规则的应用</h5><p>​    firewalld提供了‘direct interface” (直接接口)， 它允许管理员手动编写的iptables. ip6tables 和ebtables规则插入firewalld管理的区域中，适用于应用程序，而不是用户。</p>
<p>​    firewalld 保持对所增加项目的追踪,所以它还能质询firewalld 和发现使用直接端口模式的程序造成的更改</p>
<p>​    直接端口通过firewall-cmd 命令中的– -direct选项实现</p>
<p>​    除非将直接规则显式插入firewalld管理的区域,否则将首先解析直接规则,然后解析其他firewalld规则。</p>
<h5 id="8-6-1-8-富规则的应用"><a href="#8-6-1-8-富规则的应用" class="headerlink" title="8.6.1.8 富规则的应用"></a>8.6.1.8 富规则的应用</h5><h4 id="8-6-2-CentOS-7-防火墙设置"><a href="#8-6-2-CentOS-7-防火墙设置" class="headerlink" title="8.6.2 CentOS 7 防火墙设置"></a>8.6.2 CentOS 7 防火墙设置</h4><p>1、查看防火墙状态: <code>firewall-cmd --state</code></p>
<p>2、停止防火墙：<code>systemctl stop firewalld.service</code></p>
<p>3、禁止firewall开机启动：<code>systemctl disable firewalld.service</code> </p>
<h4 id="8-6-3-CentOS-8-防火墙设置"><a href="#8-6-3-CentOS-8-防火墙设置" class="headerlink" title="8.6.3 CentOS 8 防火墙设置"></a>8.6.3 CentOS 8 防火墙设置</h4><p>1、查看防火墙状态：<code>systemctl status firewalld.service</code></p>
<p>2、打开防火墙：<code>systemctl start firewalld.service</code></p>
<p>3、关闭防火墙：<code>systemctl stop firewalld.service</code></p>
<p>4、开启防火墙：<code>systemctl enable firewalld.service</code></p>
<p>5、禁用防火墙：<code>systemctl disable firewalld.service</code></p>
<p><strong>6、打开端口：<code>firewall-cmd --permanent --add-port=端口号/协议</code></strong></p>
<p>​      例如打开ftp服务：<code>firewall-cmd --permanent --add-port=ftp</code></p>
<p><strong>7、关闭端口：<code>firewall-cmd --permanent --remove-port=端口号/协议</code></strong></p>
<p><strong>8、打开、关闭后需要重新载入，才能生效：<code>firewall-cmd --reload</code></strong></p>
<p><strong>9、查询端口是否开放：<code>firewall-cmd --query-port=端口/协议</code></strong></p>
<p>端口和协议通过 <code>netstat -anp</code> 查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210205205918228.png" alt="image-20210205205918228">-</p>
<h2 id="第九章-文件系统管理篇"><a href="#第九章-文件系统管理篇" class="headerlink" title="第九章 文件系统管理篇"></a>第九章 文件系统管理篇</h2><p>挂载命令</p>
<h3 id="9-1-软件包管理"><a href="#9-1-软件包管理" class="headerlink" title="9.1 软件包管理"></a>9.1 软件包管理</h3><h4 id="9-1-1-rpm包管理"><a href="#9-1-1-rpm包管理" class="headerlink" title="9.1.1 rpm包管理"></a>9.1.1 rpm包管理</h4><p>​    rpm是用于互联网下载包的打包及安装工具，它包含着某些Linux分发版中，它生成具有.RPM扩展名的文件。RPM是ReadHat Package Manager（红帽软件包管理工具）的缩写，类似Windows的setup.exe，这一文件格式虽然打上了ReadHat的标志，但理念是通用的。</p>
<p>​    rpm包依赖查询：<a href="https://www.rpmfind.net/">https://www.rpmfind.net/</a></p>
<p>​    rpm主要有５种基本功能：<strong>查询、安装、升级、刷新、卸载</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示所有软件包</td>
</tr>
<tr>
<td align="center">-q</td>
<td align="center">查询功能</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">安装指定的软件包，通常和-v,-h 选项结合使用</td>
</tr>
<tr>
<td align="center">-e</td>
<td align="center">删除指定的软件包</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">查询拥有指定文件的软件包</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">显示软件包的相关信息，通常和-q 选项结合使用</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">显示软件包的文件列表</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">查询待安装的软件包</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">显示软件包的关联性信息</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">显示文件状态，通常结合-l 选项使用</td>
</tr>
<tr>
<td align="center">-U</td>
<td align="center">升级指定的软件包</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示指令执行过程</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">在安装过程中将显示一系列的#来表示安装进度</td>
</tr>
<tr>
<td align="center">-vv</td>
<td align="center">详细显示指令执行过程，便于排错</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">刷新软件</td>
</tr>
</tbody></table>
<p>查询：</p>
<p><strong>查询已安装的rpm列表：<code>rpm -qa</code></strong></p>
<p>​    软件包的查询功能主要由**-q** 选项完成，为了实现特殊的查询功能<strong>要配合其它的选项使用</strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207103554531.png" alt="image-20210207103554531">-</p>
<p>​    <!--一般要在上面命令加上grep--></p>
<p>​    其中：bt-mysql56-5.6.50-1.el8.x86_64</p>
<p>​    by-mysql56：名称</p>
<p>​    5.6.50-1：版本</p>
<p>​    el8：<strong>EL</strong>是Red Hat <strong>E</strong> nterprise <strong>L</strong> inux（<strong>EL</strong>）的缩写，EL8是Red Hat 8.x，CentOS 8.x和CloudLinux 8.x的下载</p>
<p>​    x86_64：表示<strong>64位系统</strong>，如果是i686、i386则表示32位系统，noarch表示<strong>通用</strong></p>
<p><strong>查询软件包是否安装：<code>rpm -q 软件包名</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207105038099.png" alt="image-20210207105038099">-</p>
<p><strong>查询软件包信息：<code>rpm -qi 软件包名</code></strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210207105113220.png" alt="image-20210207105113220">-</p>
<p><strong>查询软件包中的文件：<code>rpm -ql 软件包名</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207105146827.png" alt="image-20210207105146827">-</p>
<p><strong>查询文件所属的软件包：<code>rpm -qf 文件绝对路径</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207105215729.png" alt="image-20210207105215729">-</p>
<p><strong>查看软件包的配置文件所在位置： rpm -qc 软件名</strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210305081224626.png" alt="image-20210305081224626">-</p>
<p><strong>安装</strong>：<code>rpm -ivh  软件包名称</code></p>
<p>​    先去mariadb官网或者包依赖网站下载一个rpm包，然后进行安装：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305160939036.png" alt="image-20210305160939036">-</p>
<p>安装rpm包，最最恶心的一点就是要自己解决依赖问题！好在有包依赖网站</p>
<p><img src="/2021/08/25/16-07-33/image-20210305161117001.png" alt="image-20210305161117001"></p>
<p>因为刚才是下载的这个rpm包，所以点击前面的那个网页就可以找到需要的依赖包</p>
<p><img src="/2021/08/25/16-07-33/image-20210305161208882.png" alt="image-20210305161208882">-</p>
<p>跟报错的包一样，所以这里需要一个一个地下载并安装！</p>
<p>首先下载：<strong>ld-linux-aarch64.so.1()(64bit)</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210305161454218.png" alt="image-20210305161454218"></p>
<p>然后搜索**ld-linux-aarch64.so.1(GLIBC_2.17)(64bit)**，发现这个是包含着glibc中的，所以只需要安装上面那个就能解决这个两个依赖包的问题！</p>
<p>然而安装glibc还需要其它依赖包，我死了！简直是一环套一环，而且包下载又很慢，艹，放弃了</p>
<p><strong>升级</strong>：<code>rpm -Uvh 软件包名称</code></p>
<p>​    升级是先将低版本的软件包卸载，再安装高版本的软件包</p>
<p><strong>刷新</strong>：<code>rpm -Fvh 软件包名称</code></p>
<p>​    如果选项指定软件包的版本更高，会升级安装。如果未安装该软件包，刷新选项不会安装软件包。</p>
<p><strong>卸载</strong>：<code>rpm -e RPM包的名称</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207110229635.png" alt="image-20210207110229635">-</p>
<p>​    在卸载的时候有可能会产生依赖错误，比如卸载的软件包里面有一些文件是其它文件所依赖的，一般不推荐直接卸载，如果要卸载可以增加参数 <strong>–nodeps</strong>，就可以强制删除</p>
<p>​    <strong><code>rpm -e --nodeps RPM包的名称</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207110345686.png" alt="image-20210207110345686">-</p>
<p>​    <strong>安装rpm包：<code>rpm -ivh rpm包全路径名称</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210207110907979.png" alt="image-20210207110907979">-</p>
<p>​    现在目录下正好有一个rpm包，下面进行github的安装：</p>
<p><img src="/2021/08/25/16-07-33/image-20210207111104851.png" alt="image-20210207111104851">-</p>
<p>​    <!--“-i=install 安装、v=verbose 提示、h=hash 进度条”--></p>
<h4 id="9-1-2-yum包管理"><a href="#9-1-2-yum包管理" class="headerlink" title="9.1.2 yum包管理"></a>9.1.2 yum包管理</h4><p>​    yum 是一个Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软件包</p>
<p>​    yum源文件<strong>存放的目录</strong>在：/etc/yum.repos.d/</p>
<p><img src="/2021/08/25/16-07-33/image-20210302100121246.png" alt="image-20210302100121246">-</p>
<p>​    <!--用rpm就不会自动处理依赖关系，很麻烦--></p>
<p>​    查询yum服务器是否有需要安装的软件：<code>yum list | grep xx</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210207112736550.png" alt="image-20210207112736550"></p>
<p>​    或者：<code>yum search xx</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210207113246191.png" alt="image-20210207113246191">-</p>
<p>​    安装指定的yum包：<code>yum install xxx</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210207113323387.png" alt="image-20210207113323387"></p>
<p>​    查询相关包的信息 ： <code>yum info 包名</code></p>
<p>​    先使用 <code>whereis 软件名</code> 去查看所在的路径，然后使用 <code>rpm -qf 路径</code>，查看ifconfig是属于哪个包，然后在使用 <code>yum info 包名</code>，去查看包相关的信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210313161435320.png" alt="image-20210313161435320">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210313161453962.png" alt="image-20210313161453962">-</p>
<h4 id="9-1-3-安装不了，如何排错"><a href="#9-1-3-安装不了，如何排错" class="headerlink" title="9.1.3 安装不了，如何排错"></a>9.1.3 安装不了，如何排错</h4><p>​    如果是网络源，首先用ping查看网络是否正常，然后检查yum源是否能用，然后检查<u>yum源文件（看上面）里面的语法</u>是否正确，再清楚缓存重新生成新的缓存。</p>
<p><code>vim /etc/yum.repos.d/CentOS-Linux-BaseOS.repo</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210302100359860.png" alt="image-20210302100359860">-</p>
<!--不一定是BaseOS这个文件，也可以修改其它文件-->

<p>​    如果是本地源，首先看本地软件仓库是否有相应的软件（挂载），检查yum源文件语法，弱国有多个本地源文件，可能还需要检查是否<strong>冲突</strong>。</p>
<h4 id="9-1-4-CentOS-7-换阿里源"><a href="#9-1-4-CentOS-7-换阿里源" class="headerlink" title="9.1.4 CentOS 7 换阿里源"></a>9.1.4 CentOS 7 换阿里源</h4><p>1、对默认原文件进行备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br><span class="line">mkdir bak</span><br><span class="line">mv *.repo bak/</span><br></pre></td></tr></table></figure>

<p>2、配置阿里云yum源：#wget <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p>
<p>​     然后安装 EPEL源：   #yum install -y epel-release</p>
<h4 id="9-1-5-CentOS-8-换清华源"><a href="#9-1-5-CentOS-8-换清华源" class="headerlink" title="9.1.5 CentOS 8 换清华源"></a>9.1.5 CentOS 8 换清华源</h4><p>例如：我下载需要下载zabbix，首先打开<a href="https://mirrors.tuna.tsinghua.edu.cn/%EF%BC%8C%E7%84%B6%E5%90%8E%E6%90%9C%E7%B4%A2%E6%A1%86%E8%BE%93%E5%85%A5zabbix">https://mirrors.tuna.tsinghua.edu.cn/，然后搜索框输入zabbix</a></p>
<p><img src="/2021/08/25/16-07-33/image-20210317165724450.png" alt="image-20210317165724450">-</p>
<p>版本的选择需要先去zabbix官网去看一下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210317165803863.png" alt="image-20210317165803863"></p>
<p><img src="/2021/08/25/16-07-33/image-20210317165943864.png" alt="image-20210317165943864">-</p>
<!--不然有可能下载了一个高版本，却找不到支持的数据库-->

<p>所以我们这里选择5.0版本：</p>
<p><img src="/2021/08/25/16-07-33/image-20210317165912411.png" alt="image-20210317165912411"></p>
<p>往下翻找到跟上面红框一样的内容：</p>
<p><img src="/2021/08/25/16-07-33/image-20210317170107434.png" alt="image-20210317170107434"></p>
<p>然后点击下载后，传到centos系统里面去：</p>
<p>然后执行：<code>rpm -ivh  包名</code> 命令，就会创建一个repo文件：</p>
<p>————未完待续——————–</p>
<!--注意，这里需要先备份repo文件-->

<ol>
<li><p>备份 <strong>/etc/yum.repos.d/CentOS-Linux-BaseOS.repo</strong>：</p>
<p><code>mv /etc/yum.repos.d/CentOS-Linux-BaseOS.repo /etc/yum.repos.d/CentOS-Linux-BaseOS.repo.backup</code></p>
</li>
<li><p>修改源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[BaseOS]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=BaseOS&amp;infra=$infra</span></span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/BaseOS/<span class="variable">$basearch</span>/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class="line"> </span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Extras</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra</span></span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class="line"> </span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Plus</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra</span></span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/centosplus/<span class="variable">$basearch</span>/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class="line"> </span><br><span class="line">[AppStream]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - AppStream</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra</span></span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/AppStream/<span class="variable">$basearch</span>/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class="line"> </span><br><span class="line">[PowerTools]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - PowerTools</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=PowerTools&amp;infra=$infra</span></span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/PowerTools/<span class="variable">$basearch</span>/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br></pre></td></tr></table></figure></li>
<li><p>然后执行下面的命令重新编译源缓存并执行更新操作：</p>
<p><code>yum makecache</code> </p>
<p><code>yum -y update</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304151342149.png" alt="image-20210304151342149">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304152638582.png" alt="image-20210304152638582">-</p>
<p>换源就这样搞定了</p>
</li>
<li><p>或者去到网站：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">https://mirrors.tuna.tsinghua.edu.cn/help/centos/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g&#x27;\</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-*.repo</span><br></pre></td></tr></table></figure>

<p>使用上面的命令一样可以达到效果！</p>
</li>
</ol>
<h4 id="9-1-6-配置本地yum源"><a href="#9-1-6-配置本地yum源" class="headerlink" title="9.1.6 配置本地yum源"></a>9.1.6 配置本地yum源</h4><p>方法1：</p>
<p>​    创建一个文件夹：/mnt/cdrom， 然后将 /dev/sr0 挂载到这个文件夹：<code>mount /dev/sr0 /mnt/cdrom</code></p>
<p>​    /dev/sr0里面就有需要的本地源：<img src="/2021/08/25/16-07-33/image-20210305173529005.png" alt="image-20210305173529005"></p>
<p>其中的<strong>Packages</strong> 里面就是需要的yum源，也就是rpm包，然后设置<strong>自动挂载（vim /etc/fstab）</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/sr0        /mnt/cdrom      iso9660 	defaults        0       0</span><br></pre></td></tr></table></figure>

<p>​    将 /etc/yum.repos.d/ 下创建一个bak文件夹，然后将所以repo移到这个文件夹里面</p>
<p>​    新建一个repo文件（文件名随意，但后缀必须是repo）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dvd]</span><br><span class="line">name=centos7</span><br><span class="line">baseurl=file:///mnt/cdrom # file:// + /mnt/cdrom</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0  # : gpgcheck是gpg验证是否开启的选项,1是开启,0是不开启,一般情况可以关掉</span><br></pre></td></tr></table></figure>

<p>​    然后就可以了，以后安装都只会去这个路径下找安装包</p>
<p>方法2：</p>
<p>将所有的依赖包全部下载到目录中： <code>yum install --downloadonly --downloaddir=目录</code></p>
<p>然后创建一个repo文件（方法同上）</p>
<h4 id="9-1-7-源码安装Nginx"><a href="#9-1-7-源码安装Nginx" class="headerlink" title="9.1.7 源码安装Nginx"></a>9.1.7 源码安装Nginx</h4><p>1、安装步骤：</p>
<ol>
<li>对下载的码包进行解压；</li>
<li>进入解压目录执行 configure 命令做相关设置；</li>
<li>执行 make 进行编译；</li>
<li>执行 make install 进行安装</li>
<li>将安装的nginx作为系统服务来启动</li>
<li>配置环境变量，使软件对应的命令能够直接使用</li>
</ol>
<p>2、安装Nginx实例：</p>
<ol>
<li><p>去官网下载Nginx压缩包：<a href="http://nginx.org/download/nginx-1.19.7.tar.gz">http://nginx.org/download/nginx-1.19.7.tar.gz</a></p>
</li>
<li><p>解压：<code>tar -zxvf nginx-1.19.7.tar.gz</code></p>
<p>解压后进入Nginx文件夹：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305174955116.png" alt="image-20210305174955116">-</p>
</li>
<li><p>执行 <strong>./configure</strong> 或者 <strong>sh configure</strong> 命令对安装环境进行配置</p>
</li>
<li><p>执行 <strong>make</strong> 命令进行<strong>编译</strong></p>
</li>
<li><p>执行 <strong>make install</strong> 命令进行<strong>安装</strong></p>
</li>
<li><p>如果要卸载：执行 <strong>make uninstall</strong> 即可</p>
</li>
<li><p>运行nginx，<strong>cd</strong> 到 <strong>/usr/local/nginx/sbin</strong> 然后执行 <code>./nginx</code> 即可</p>
<p>先关闭防火墙，然后浏览器地址栏输入IP地址即可访问！</p>
<p><img src="/2021/08/25/16-07-33/image-20210305182154009.png" alt="image-20210305182154009">-</p>
</li>
<li><p>nginx服务名称：<strong>nginx</strong></p>
</li>
<li><p>nginx的主配置文件在：**/usr/local/nginx/conf/nginx.conf**</p>
<p>主配置文件包含三个部份：<strong>全局配置、I/O事件配置、HTTP配置</strong></p>
<ul>
<li><p><strong>全局配置</strong>：包括Nginx服务的运行用户、工作进程数、错误日志、PID存放位置等基本设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user nginx;             // 运行用户</span><br><span class="line">worker_processes auto;        // 工作进程数量</span><br><span class="line">error_log /var/log/nginx/error.log; // 错误日志文件的位置</span><br><span class="line">pid /run/nginx.pid;         // PID文件的位置</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210309152410620.png" alt="image-20210309152410620">-</p>
</li>
<li><p><strong>I/O事件配置</strong>：用来指定Nginx进程的I/O响应模型、每个进程的连接数等设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">	Use epoll；  //使用epoll模型</span><br><span class="line">	worker_connections 1024; //每个进程处理1024个连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210309152611563.png" alt="image-20210309152611563">-</p>
<p>注意这里的worker_connections 和上面的worker_processes是倍数关系：</p>
<p>​    实际的连接数=worker_processes * worker_connections </p>
<p>一般会把worker_processes设置为auto，也就是自动</p>
<p>epoll模型详解：<a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311">https://blog.csdn.net/daaikuaichuan/article/details/83862311</a></p>
</li>
<li><p><strong>HTTP配置</strong>：包含访问日志、HTTP端口、网页目录、默认字符集、连接保持以及虚拟WEB主机、PHP解析等一系列设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    //日志格式</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;       //访问日志</span><br><span class="line">    sendfile            on;       //支持文件发送（下载）</span><br><span class="line">    tcp_nopush          on;       </span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;       //连接保持超时</span><br><span class="line">    types_hash_max_size 2048;     //</span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;          //监听端口配置</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">		server_name  _;                           //网站名称</span><br><span class="line">		charest utf-8                            //网页的默认字符集</span><br><span class="line">        root         /usr/share/nginx/html;   //  默认首页</span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line">        location / &#123;                  //根目录配置</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 404 /404.html;      </span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>nginx默认的网页文件位置：**/usr/local/nginx/html/index.html**</p>
</li>
<li><p>先做一个别用：<code>alias nginx=&quot;cd /usr/local/nginx/sbin; ./nginx&quot;</code></p>
<p>用来启动，不然每次都需要cd到那个目录下，很麻烦</p>
</li>
<li><p>访问状态统计</p>
<p>Nginx内置了HTTP_STUB_STATUS状态统计模块，可使用nginx -V查看安装的Nginx是否包含这个模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location /status &#123;         //设置访问位置</span><br><span class="line">	stub_status on;  //打开状态统计功能</span><br><span class="line">	access_log off;  //关闭此位置的日志记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基于授权的访问控制</p>
<p>1、首先使用htpasswd生成用户认证用户文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309162059122.png" alt="image-20210309162059122">-</p>
<!--如何命令不能使用，还需要安装 httpd-tools-->

<p>2、修改主配置文件，添加认证配置项：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309163610715.png" alt="image-20210309163610715">-</p>
<p>注意只需要添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auth_basic &quot;secret&quot;;</span><br><span class="line">auth_basic_user_file passwd.db； // 注意此时passwd.db的位置和文件的权限</span><br></pre></td></tr></table></figure>

<p>3、访问主页：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309163523867.png" alt="image-20210309163523867">-</p>
<!--就能看到提示输入账号和密码了，在输入成功以后就会进入主页-->

<!--注意页面访问不了，有可能是selinux的问题--></li>
<li><p>基于客户端的访问控制</p>
<p>只需要在location中加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deny XXXX.XXXX.XXXX.XXXX;</span><br><span class="line">allow all;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210309165308651.png" alt="image-20210309165308651">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210309165235774.png" alt="image-20210309165235774">-</p>
</li>
<li><p>基于域名的虚拟主机</p>
<p>修改 /etc/hosts文件，添加下面这句：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309165845460.png" alt="image-20210309165845460">-</p>
<p>然后修改主配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.examhaha.com;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/exam/;</span><br><span class="line">            index  index.html;</span><br><span class="line">           	# auth_basic &quot;secret&quot;;</span><br><span class="line">           	# auth_basic_user_file passwd.db;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<!--在配置文件里面主要是加上 server_name 即可，也可以把listen改为：IP：80的 形式-->

<p>注意上面是直接在主配置文件里面修改，其实也可以单独为虚拟主机创建一个conf文件</p>
<p>1、还是先修改hosts文件，加一条：192.168.30.136 <a href="http://www.hrhaha.com/">www.hrhaha.com</a></p>
<p>2、然后在conf目录下新建一个vhost目录，cd到vhost，然后vim hr.conf</p>
<p><img src="/2021/08/25/16-07-33/image-20210309170751187.png" alt="image-20210309170751187">-</p>
<!--注意文件的所有者权限，改不改都可以，只要能读就行-->

<p>3、修改主配置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309171533637.png" alt="image-20210309171533637">-</p>
<!--注意，这一步加是在http下，而不是server下面加-->

<p>4、访问成功，但出现了乱码，这个时候就需要进入hr.conf配置文件中</p>
<p><img src="/2021/08/25/16-07-33/image-20210309172553573.png" alt="image-20210309172553573">-</p>
<p>加上这两句就可以了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">default_type &#x27;text/html&#x27;;</span><br><span class="line">charset gb2312;</span><br></pre></td></tr></table></figure></li>
<li><p>基于端口、IP的虚拟主机 – 了解即可</p>
</li>
<li><p>配置Nginx支持PHP环境</p>
<p>没想到吧，Nginx默认还不能解析php文件，还必须添加一个新模块php-fpm或者交给apache运行</p>
<p><code>yum install -y php-fpm</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309174421619.png" alt="image-20210309174421619">-</p>
<p>查看php-fpm的安装位置：<code>rpm -ql php-fpm</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309174450515.png" alt="image-20210309174450515">-</p>
<!--还可以查看到配置文件的所在位置-->

<p>然后修改配置文件：<code>cd /usr/share/doc/php-fpm-5.4.16</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210309174736302.png" alt="image-20210309174736302">-</p>
<p>然后：<code>cp php-fpm.conf.default php-fpm.conf</code></p>
<p>然后编辑 php-fpm.conf 文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210309175044110.png" alt="image-20210309175044110">-</p>
<p>然后修改用户和组为<strong>nginx</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309175142101.png" alt="image-20210309175142101">-</p>
<p>最后启动php-fpm：</p>
<p><img src="/2021/08/25/16-07-33/image-20210309175248991.png" alt="image-20210309175248991">-</p>
<p>然后修改hr配置文件，调用<strong>php-fpm</strong>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.hrhaha.com;</span><br><span class="line">        default_type &#x27;text/html&#x27;;</span><br><span class="line">        charset gb2312;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/hr/;</span><br><span class="line">            index index.html index.php;</span><br><span class="line">           # auth_basic &quot;secret&quot;;</span><br><span class="line">           # auth_basic_user_file passwd.db;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php$ &#123;  # 这里是正则匹配</span><br><span class="line">            root           html/hr/;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            include        fastcgi.conf;  # 这个文件在conf下是有的</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个子配置文件也是可以的：</p>
<p><img src="/2021/08/25/16-07-33/image-20210312110648972.png" alt="image-20210312110648972">-</p>
<p>上面的 ~.php$ 是<strong>正则匹配</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~      区分大小写的匹配</span><br><span class="line">~*     不区分大小写</span><br><span class="line">！~    对区分大小写的匹配进行取反</span><br><span class="line">！~*   对不区分大小写配进行取反</span><br><span class="line"><span class="meta">$</span><span class="bash">     表示以什么结尾（.php）</span></span><br><span class="line">\	  表示转义（转义 &quot;.&quot;）</span><br></pre></td></tr></table></figure>

<!--注意记得把主配置文件中的关于php-fpm配置删了-->

<!--然后重启，生效，php文件成功被执行！--></li>
<li></li>
</ol>
<h4 id="9-1-8-yum安装nginx"><a href="#9-1-8-yum安装nginx" class="headerlink" title="9.1.8 yum安装nginx"></a>9.1.8 yum安装nginx</h4><p>Nginx服务名称：<strong>nginx</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210310112925907.png" alt="image-20210310112925907">-</p>
<p>查看nginx文件列表：<code>rpm -ql nginx</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210310113201155.png" alt="image-20210310113201155">-</p>
<p>从上面可以看到：</p>
<p>Nginx服务的默认站点：**/usr/share/nginx/html**</p>
<p><img src="/2021/08/25/16-07-33/image-20210310113325398.png" alt="image-20210310113325398">-</p>
<p>Nginx服务的主配置文件：**/etc/nginx/nginx.conf**</p>
<p>主配置文件包含三个部份：<strong>全局配置、I/O事件配置、HTTP配置</strong></p>
<p>跟上面源代码安装的一样！这里就不再多讲，试一下<strong>访问状态统计</strong>前面那个失败了的，在这里弄一下，看看能不能</p>
<p><img src="/2021/08/25/16-07-33/image-20210310114116213.png" alt="image-20210310114116213">-</p>
<p><strong>成功了，下面是具体的代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">                stub_status on;  # 只需要添加这句即可</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-1-8-1-Nginx服务优化"><a href="#9-1-8-1-Nginx服务优化" class="headerlink" title="9.1.8.1 Nginx服务优化"></a>9.1.8.1 Nginx服务优化</h5><p><strong>1、隐藏版本号</strong></p>
<p>首先把404页面注释了，就可以看到版本号了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> error_page 404 /404.html;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> location = /404.html &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这3行的位置不用多说把，是在server中，默认就有</span></span><br></pre></td></tr></table></figure>

<p>然后重启之后，随便访问一个不存在的位置，即可查看到版本号：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310114838991.png" alt="image-20210310114838991">-</p>
<p>然后在配置文件中添加一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	include             /etc/nginx/mime.types;  # 默认有</span><br><span class="line">    default_type        application/octet-stream; # 默认有</span><br><span class="line">    server_tokens off;  # 主要是添加这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启后，再次打开一个错误网页：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310115109529.png" alt="image-20210310115109529">-</p>
<p>可以发现版本号没了！</p>
<p>也可以通过按F12查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310144707944.png" alt="image-20210310144707944"></p>
<p><strong>2、修改用户与组</strong></p>
<p>注意如果使用的是源码安装的话，默认的用户和组都是nobody（往上翻），但是用yum安装，默认是用户nginx</p>
<p><img src="/2021/08/25/16-07-33/image-20210310115908273.png" alt="image-20210310115908273">-</p>
<!--若是nobody，则需要手动创建一个nginx（nologin状态）的账户，然后进行一些修改-->

<p><strong>3、设置网页缓存时间</strong></p>
<p>​    当Nginx将网页数据返回给用户端后，可设置缓存时间，以便日后进行相同内容的请求时直接返回，避免重复请求，加快访问速度，一般只针对静态资源进行设置，对动态网页不用设置缓存时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location ~\.(gif|jpg|jepg|png|bmp|ico)$ &#123;</span><br><span class="line">		root html;</span><br><span class="line">     	expires 1d; # 1d 表示1天</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<!--这种缓存方式只能在用户不对浏览器强制刷新的情况下生效，如果用户通过url来进行访问，是可以访问到缓存的。-->

<p>上面设置的好像没管用，我直接放到了这里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">                expires 1d;  <span class="comment"># 1天</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210310121256513.png" alt="image-20210310121256513"></p>
<p>可以看到Cash-Control后面的86400单位是秒，然后下面的expires表示到期时间，也就是一天后，</p>
<p><img src="/2021/08/25/16-07-33/image-20210310121142011.png" alt="image-20210310121142011">-</p>
<p><strong>4、日志分割</strong></p>
<p>​    Nginx没有类似Apache的cronlog日志分割处理能力，但可以通过Nginx的信号控制功能脚本来实现日志的自动切割（<strong>注意，Nginx安装后，已经做好了日志轮替的配置</strong>），下图是Apache的日志分割：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310121624529.png" alt="image-20210310121624529">-</p>
<p><strong>直接看下面的日志轮替，具体操作都在那！</strong></p>
<p><strong>5、设置连接超时</strong></p>
<p>​    在企业网站中，为了避免同一个客户长时间占用连接，造成资源浪费，可设置相应的连平超时参数，实现对连接访问时间的控制。</p>
<p>首先进入主配置文件：<code>vim /etc/nginx/nginx.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keepalive_timeout   30 30;    # KeepAlive 的超时时间</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数1指定了客户端与服务器 keep-alive的超时时间，值为0将禁用 keep-alive功能。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数1值设置为0禁用keep-alive，表现为http响应头 Connection: close</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数2(可选)在HTTP响应头<span class="string">&quot;Keep-Alive: timeout=time&quot;</span> 字段中设置一个值</span></span><br><span class="line">client_header_timeout 80;  # 等待客户发送请求头的超时时间</span><br><span class="line">client_body_timeout 80;    # 请求体读超时时间</span><br></pre></td></tr></table></figure>

<p>​    HTTP 有一个 KeepAlive 模式，它告诉 webserver 在处理完一个请求后保持这个 TCP 连接的打开状态。若接收到来自客户端的其它请求，服务端会利用这个未被关闭的连接，而不需要再建立一个连接。KeepAlive 在一段时间内保持打开状态，它们会在这段时间内占用资源。占用过多就会影响性能。Nginx 使用 <strong>keepalive_timeout</strong> 来指定 KeepAlive 的超时时间（timeout）。指定每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以可以设定为 60 秒。若将它设置为 0，就禁止了 keepalive 连接    </p>
<p><strong>client_body_timeout</strong>：指定客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）</p>
<p><strong>client_header_timeout</strong>：客户端向服务端发送一个完整的 request header 的超时时间。如果客户端在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。</p>
<p><img src="/2021/08/25/16-07-33/image-20210310145342071.png" alt="image-20210310145342071"></p>
<h5 id="9-1-8-2-Nginx深入优化"><a href="#9-1-8-2-Nginx深入优化" class="headerlink" title="9.1.8.2 Nginx深入优化"></a>9.1.8.2 Nginx深入优化</h5><p><strong>1、更改进程数</strong></p>
<p>​    在高并发环境中，需要启动更多的Nginx进程以保证快速响应，用以处理用户的请求，避免造成阻塞。使用<code>ps aux | grep nginx</code>命令可以查看Nginx运行进程的个数。</p>
<p><img src="/2021/08/25/16-07-33/image-20210310150120621.png" alt="image-20210310150120621">-</p>
<p>可以看到，我这台机器上，启动用了一个主进程（master process），两个子进程（worker process）</p>
<p>进入配置文件：<code>vim /etc/nginx/nginx.conf</code></p>
<p>修改进程数为1：<strong>worker_processes:1;</strong></p>
<p>效果如下图：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310150349476.png" alt="image-20210310150349476">-</p>
<p>nginx默认是没有开启利用多核cpu的配置的。需要通过增加<strong>worker_cpu_affinity</strong>配置参数来充分利用多核cpu，cpu是任务处理，当计算最费时的资源的时候，cpu核使用上的越多，性能就越好</p>
<p>首先查看本机的CPU核心数：<code>cat /proc/cpuinfo</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">physical id：物理CPU的唯一标识ID</span><br><span class="line">core id：每个物理CPU中内核的唯一标识ID</span><br><span class="line">processor：当前逻辑CPU的唯一标识</span><br><span class="line">siblings：同一个物理CPU中逻辑CPU数量</span><br><span class="line">cpu cores：同一个物理CPU中内核数量</span><br><span class="line">总核数 = 物理CPU个数 <span class="emphasis">* 每颗物理CPU的核数 </span></span><br><span class="line"><span class="emphasis">总逻辑CPU数 = 物理CPU个数 *</span> 每颗物理CPU的核数 <span class="emphasis">* 超线程数</span></span><br></pre></td></tr></table></figure>

<p>通过上面的公式即可计算出，因为我是用的虚拟机，也可去设置里面看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310151132884.png" alt="image-20210310151132884">-</p>
<p>2核cpu，开启2个进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes     2;</span><br><span class="line">worker_cpu_affinity 01 10;</span><br></pre></td></tr></table></figure>

<p>在配置文件设置后，具体效果如下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310151653551.png" alt="image-20210310151653551">-</p>
<p>2核cpu，开启4个进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes     4;</span><br><span class="line">worker_cpu_affinity 01 10 01 10;</span><br></pre></td></tr></table></figure>

<p>4个cpu，开启4个进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes     4;</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br></pre></td></tr></table></figure>

<p>4核cpu，开启2个进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes     2;</span><br><span class="line">worker_cpu_affinity 0101 1010;</span><br></pre></td></tr></table></figure>

<p><strong>2、配置网页压缩</strong></p>
<p>Nginx优化之gzip压缩提升网站速度，<code>vim /etc/nginx/nginx.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gzip配置的常用参数</span></span><br><span class="line">gzip on|off; #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K| 16 8K; #缓冲(压缩在内存中缓冲几块? 每块多大?)</span><br><span class="line">gzip_comp_level [1-9]; #推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源)</span><br><span class="line">gzip_disable; #正则匹配UA 什么样的Uri不进行gzip</span><br><span class="line">gzip_min_length 200; # 开始压缩的最小长度(再小就不要压缩了,意义不在)</span><br><span class="line">gzip_http_version 1.0|1.1; # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)</span><br><span class="line">gzip_proxied; # 设置请求者代理服务器,该如何缓存内容</span><br><span class="line">gzip_types text/css application/xml; # 对哪些类型的文件用压缩 如txt,xml,html ,css</span><br><span class="line">gzip_vary on|off; # 是否传输gzip压缩标志</span><br></pre></td></tr></table></figure>

<p>具体配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_buffers 32 4k;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_min_length 100;</span><br><span class="line">gzip_types text/css image/png text/html application/xml;</span><br><span class="line">gzip_vary on;</span><br></pre></td></tr></table></figure>

<p><strong>没开gzip的时间</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310164232847.png" alt="image-20210310164232847"></p>
<p><strong>开了之后</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310164457008.png" alt="image-20210310164457008"></p>
<p><img src="/2021/08/25/16-07-33/image-20210310164523464.png" alt="image-20210310164523464"></p>
<p><strong>其实，根本看不出来，因为时间都太短了！！！hhhhhh shit</strong></p>
<p><strong>3、配置防盗链</strong></p>
<p>​    具体原理就是：我网站有一张图片，然后其他人复制了图片链接，插入到了他的网站里面，然后通过防盗链，对方插入的网页不会显示这张图片，而是显示盗链</p>
<p>在主配置文件中加入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location ~ \.(jpg|png|gif|jpeg)$ &#123;</span><br><span class="line">                valid_referers 192.168.21.132;</span><br><span class="line">                if ($invalid_referer) &#123;</span><br><span class="line">                        return 403;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我没弄出来，可以参考一下：<a href="https://blog.csdn.net/qq_42303254/article/details/89576429">https://blog.csdn.net/qq_42303254/article/details/89576429</a></p>
<p>4、FPM参数优化</p>
<p>fpm就是用来运行php代码的模块，FPM进程有两种方式产生：</p>
<pre><code>   Static：产生固定的数据的fpm进程
   
   Dynamic：根据服务器的内存与服务负载进行动态调整
</code></pre>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pm.max_children       <span class="comment"># 指定启动的进程的最大的数量</span></span><br><span class="line">pm.start.servers      <span class="comment"># 动态方式下初始的ftpm进程数量</span></span><br><span class="line">pm.min_spare_servers  <span class="comment"># 动态方式下最小的ftpm进程数量</span></span><br><span class="line">pm_max_spare_servers  <span class="comment"># 动态方式下最大的ftpm进程数量</span></span><br></pre></td></tr></table></figure>

<p><strong>具体的内容就不操作了，直接把代码放到主配置文件即可</strong></p>
<h3 id="9-2-文件系统"><a href="#9-2-文件系统" class="headerlink" title="9.2 文件系统"></a>9.2 文件系统</h3><h4 id="9-2-1-硬盘结构"><a href="#9-2-1-硬盘结构" class="headerlink" title="9.2.1 硬盘结构"></a>9.2.1 硬盘结构</h4><h5 id="1、硬盘的逻辑结构"><a href="#1、硬盘的逻辑结构" class="headerlink" title="1、硬盘的逻辑结构"></a>1、<strong>硬盘的逻辑结构</strong></h5><p><img src="/2021/08/25/16-07-33/image-20210303204922369.png" alt="image-20210303204922369">-<img src="/2021/08/25/16-07-33/image-20210303204940311.png" alt="image-20210303204940311">-</p>
<p>​    每个扇区的大小是固定的，为 <strong>512Byte</strong>。扇区也是磁盘的最小存贮单位</p>
<p>​    硬盘的大小是使用“<strong>磁头数×柱面数×扇区数×每个扇区的大小</strong>”这样的公式来计算的</p>
<h5 id="2、硬盘的接口"><a href="#2、硬盘的接口" class="headerlink" title="2、硬盘的接口"></a>2、<strong>硬盘的接口</strong></h5><ol>
<li><p><strong>IDE 硬盘接口</strong>（Integrated Drive Electronics，并口，即电子集成驱动器）</p>
<p>也称作“ATA 硬盘”或“PATA 硬盘”，是早期机械硬盘的主要接口，ATA133 硬盘的理论 速度可以达到 133MB/s （此速度为理论平均值），IDE 硬盘接口</p>
</li>
<li><p><strong>SATA 接口</strong>（Serial ATA，串口）</p>
<p>是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是 SATA 三代，理论传输速度达到 600MB/s（此速度为理论平均值）</p>
</li>
<li><p><strong>SCSI 接口</strong>（Small Computer System Interface，小型计算机系统接口）</p>
<p>广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU 占用率低及支持热插拔等优 点，理论传输速度达到320MB/s</p>
</li>
</ol>
<h4 id="9-2-2-文件系统"><a href="#9-2-2-文件系统" class="headerlink" title="9.2.2 文件系统"></a>9.2.2 文件系统</h4><h5 id="1、Linux文件系统的特性"><a href="#1、Linux文件系统的特性" class="headerlink" title="1、Linux文件系统的特性"></a>1、Linux文件系统的特性</h5><ul>
<li><p><strong>super block（超级块）</strong></p>
<p>记录整个文件系统的信息，包括 block 与 inode 的总量，已经使用的 inode 和 block 的 数量，未使用的 inode 和 block 的数量，block 与 inode 的大小，文件系统的挂载时间，最近 一次的写入时间，最近一次的磁盘检验时间等。</p>
</li>
<li><p><strong>data block（数据块）</strong></p>
<p>用来实际保存数据的（柜子的隔断），block 的大小（1KB、2KB 或 4KB）和数量在格式化后 就已经决定，不能改变，除非重新格式化（制作柜子的时候，隔断大小就已经决定，不能更改， 除非重新制作柜子）。每个 blcok 只能保存一个文件的数据，要是文件数据小于一个 block 块，那么这个 block 的剩余空间不能被其他文件是要；要是文件数据大于一个 block 块，则占 用多个 block 块。Windows 中磁盘碎片整理工具的原理就是把一个文件占用的多个 block 块尽 量整理到一起，这样可以加快读写速度。</p>
</li>
<li><p><strong>inode（i节点）</strong></p>
<p>用来记录文件的权限（r、w、x），文件的所有者和属组，文件的大小，文件的状态改变时 间（ctime），文件的最近一次读取时间（atime），文件的最近一次修改时间（mtime），文件的 数据真正保存的 block 编号。每个文件需要占用一个 inode。</p>
</li>
</ul>
<h5 id="2、Linux常见文件系统"><a href="#2、Linux常见文件系统" class="headerlink" title="2、Linux常见文件系统"></a>2、Linux常见文件系统</h5><table>
<thead>
<tr>
<th align="center">文件系统</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ext</td>
<td align="center">Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用</td>
</tr>
<tr>
<td align="center">ext2</td>
<td align="center">是 ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 ext2 文件系统。于 1993 年发布，支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024×1024KB）</td>
</tr>
<tr>
<td align="center">ext3</td>
<td align="center">是 ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统 的可靠性。支持最大 16TB 的分区和最大 2TB 的文件</td>
</tr>
<tr>
<td align="center">ext4</td>
<td align="center">是 ext3 文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可 以说是翻天覆地的，比如向下兼容 ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、 Extents 连续数据块概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模 式、在线碎片整理、inode 增强、默认启用 barrier 等。它是 CentOS6.x 的默认文件系统</td>
</tr>
<tr>
<td align="center">xfs</td>
<td align="center">XFS 最早针对 IRIX 操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩 溃的情况下保证文件系统数据的一致性。它是一个 64 位的文件系统，后来进行开源并且移植到了 Linux 操作系统中，目前 CentOS 7.x 将 XFS+LVM 作为默认的文件系统。据官方所称，XFS 对于 大文件的读写性能较好。</td>
</tr>
<tr>
<td align="center">swap</td>
<td align="center">swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存），当内存不够用 时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必 需分区。</td>
</tr>
<tr>
<td align="center">NFS</td>
<td align="center">NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件 共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td>
</tr>
<tr>
<td align="center">iso9660</td>
<td align="center">光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统</td>
</tr>
<tr>
<td align="center">fat</td>
<td align="center">就是 Windows 下的 fat16 文件系统，在 Linux 中识别为 fat</td>
</tr>
<tr>
<td align="center">vfat</td>
<td align="center">就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件</td>
</tr>
<tr>
<td align="center">NTFS</td>
<td align="center">就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识 别，则需要重新编译内核才能支持。它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的 分区和最大 64GB 的文件</td>
</tr>
<tr>
<td align="center">ufs</td>
<td align="center">Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统</td>
</tr>
<tr>
<td align="center">proc</td>
<td align="center">Linux 中基于内存的虚拟文件系统，用来管理内存存储目录/proc</td>
</tr>
<tr>
<td align="center">sysfs</td>
<td align="center">和 proc 一样，也是基于内存的虚拟文件系统，用来管理内存存储目录/sysfs</td>
</tr>
<tr>
<td align="center">tmpfs</td>
<td align="center">也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区</td>
</tr>
</tbody></table>
<h4 id="9-2-3-分区与挂载"><a href="#9-2-3-分区与挂载" class="headerlink" title="9.2.3 分区与挂载"></a>9.2.3 分区与挂载</h4><h5 id="1、磁盘在Linux系统中的表示方法"><a href="#1、磁盘在Linux系统中的表示方法" class="headerlink" title="1、磁盘在Linux系统中的表示方法"></a>1、磁盘在Linux系统中的表示方法</h5><ul>
<li><p>IDE接口的硬盘在Linux系统中的表示方法</p>
<p>第一块硬盘：hda 第一块的分区：hda1 hda2 hda3 ……. </p>
<p>第二块硬盘：hdb 第二块硬盘的分区：hdb1 hdb2 hdb3 …………</p>
</li>
<li><p>SATA接口/SCSI接口/USB接口的硬盘在Linux系统中的表示方法</p>
<p>第一块硬盘：sda 第一块的分区：sda1 sda2 shda3 …….</p>
<p>第二块硬盘：sdb 第二块硬盘的分区：sdb1 sdb2  sdb3 ………… </p>
</li>
</ul>
<!--所有磁盘设备及分区都以文件的形式存储在/dev/,但是这些文件不能直接使用，如果要往这些分区内写入数据就需要挂载分区-->

<h5 id="2、挂载点"><a href="#2、挂载点" class="headerlink" title="2、挂载点"></a>2、挂载点</h5><p>​    <img src="/2021/08/25/16-07-33/image-20210303212653595.png" alt="image-20210303212653595">-</p>
<p>​    所谓的<strong>挂载点就是</strong>文件系统中存在的<strong>一个目录</strong>，通常情况下，创建在**/mnt目录<strong>下，挂载成功后，访问挂载点就是访问新的存储设备。 <strong>挂载点应该是空目录</strong>，否则原来该挂载点中存在的文件将</strong>会被隐藏<strong>。而且，挂载点在实施挂载操作</strong>之前**就应该存在。</p>
<h5 id="3、文件系统挂载"><a href="#3、文件系统挂载" class="headerlink" title="3、文件系统挂载"></a>3、文件系统挂载</h5><h6 id="3-1-挂载文件系统"><a href="#3-1-挂载文件系统" class="headerlink" title="3.1 挂载文件系统"></a>3.1 挂载文件系统</h6><p>​    <strong>挂载</strong>由<strong>mount命令</strong>来完成，可以灵活的挂载各种类型的文件系统</p>
<p>​    命令格式：<strong>mount [选项] [设备名] [挂载点]</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-t fstype</td>
<td align="center">指定要挂载的文件系统的类型，如果不清楚，可以使用-t auto让系统 自己选择最合适的文件系统类型挂载。</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">以只读的方式挂载文件系统</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">以读写的方式挂载文件系统，默认选项</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="center">设置挂载属性</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">挂载/etc/fstab文件中记录的设备</td>
</tr>
</tbody></table>
<h6 id="3-2-卸载文件系统"><a href="#3-2-卸载文件系统" class="headerlink" title="3.2 卸载文件系统"></a>3.2 卸载文件系统</h6><p>​    文件系统可以被挂载，不用时可以被卸载。<strong>卸载</strong>文件系统的<strong>命令是umount</strong>，这个命令可以把文件系统从Linux系统中的挂载点上分离，将原来建立的文件系统和挂载点的连接断掉。</p>
<p>​    命令格式：<strong>umount [设备名或者挂载点]</strong></p>
<p>​    在卸载一个文件系统的时候，需要指定要卸载的文件系统的<strong>挂载点或者设备名</strong></p>
<p>​    例如：</p>
<p>​    #umount /dev/sdb1 //指定<strong>设备名</strong>卸载 </p>
<p>​    #umount /mnt/sdb1 //指定<strong>挂载点</strong>卸载</p>
<p>​    如果卸载文件系统提示：“busy状态，不可卸载时”，使用<strong>fuser命令</strong>查看正在使用该文件系 统的用户信息。</p>
<p>​    命令格式：<strong>fuser [options] 文件系统名或者文件名</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示所有在命令行中指定的文件系统信息。默认情况下，至少被一个进程访问的文件才 会被显示</td>
</tr>
<tr>
<td align="center">-k</td>
<td align="center">杀死访问文件的进程</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">在杀死使用文件的用户进程之前，提示确认</td>
</tr>
<tr>
<td align="center">-u</td>
<td align="center">显示使用文件系统的进程的所有者信息</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">按进程查看命令ps的显示模式，显示文件的使用者信息，包括PID、USER、COMMAND等</td>
</tr>
</tbody></table>
<p>​    例如，查看哪个进程打开了当前目录下的cdrom文件夹：<code>fuser /mnt/cdrom</code></p>
<p>​    <!--注意：使用mount挂载不是永久挂载，重启之后就没了--></p>
<h6 id="3-3-文件系统的自动挂载"><a href="#3-3-文件系统的自动挂载" class="headerlink" title="3.3 文件系统的自动挂载"></a>3.3 文件系统的自动挂载</h6><p>编辑配置文件：<code>vim /etc/fstab</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303214148621.png" alt="image-20210303214148621">-</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">设备文件</td>
<td align="center">需要挂载的设备文件名，一般是设备的完整路径，也可以用UUID</td>
</tr>
<tr>
<td align="center">挂载目录</td>
<td align="center">挂载点，必须是一个目录，而且必须用绝对路径，需要提前创建好。 对于交换分区，这个字段定义为swap</td>
</tr>
<tr>
<td align="center">格式类型</td>
<td align="center">文件系统的类型。如果是ext3文件系统，则写成ext3；如果是FAT32文件系统，则 写成vfat；如果是光盘，可以写成auto由系统自动检测或iso9660</td>
</tr>
<tr>
<td align="center">权限选项</td>
<td align="center">挂载选项。一般都是采用“defaults”，若设置为默认，默认权限有：rw、suid、dev、exec、auto、nouser、async</td>
</tr>
<tr>
<td align="center">是否备份</td>
<td align="center">文件系统是否需要dump备份，1表示需要，0表示忽略</td>
</tr>
<tr>
<td align="center">是否自检</td>
<td align="center">在系统启动时是否检查这个文件系统以及检查的顺序，0表示不检查，1表示优先检查，2表示其次检查</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">async/sync</td>
<td align="center">是否同步运行，默认为async(异步)</td>
</tr>
<tr>
<td align="center">auto/noauto</td>
<td align="center">执行mount -o时，此文件是否被自动挂载。默认auto</td>
</tr>
<tr>
<td align="center">rw/ro</td>
<td align="center">是否以只读(ro)或（rw）模式挂载</td>
</tr>
<tr>
<td align="center">exec/noexec</td>
<td align="center">此文件系统是否能够进行”执行”操作</td>
</tr>
<tr>
<td align="center">user/nouser</td>
<td align="center">是否允许用户使用mount命令挂载</td>
</tr>
<tr>
<td align="center">suid/nosuid</td>
<td align="center">是否允许suid存在</td>
</tr>
<tr>
<td align="center">usrquota</td>
<td align="center">启动文件系统支持磁盘配额</td>
</tr>
<tr>
<td align="center">grpquota</td>
<td align="center">启动文件系统对群组磁盘配额模式的支持</td>
</tr>
<tr>
<td align="center">defaults</td>
<td align="center">同时具有rw,suid,exec,auto,nouser,async等默认设置</td>
</tr>
</tbody></table>
<p>下面演示怎么将新添加的 sdb1永久挂载：</p>
<p>在文件的最后新增一行：**/dev/sdb1    /mnt/sdb1    ext4    defaults 0 0**</p>
<p><img src="/2021/08/25/16-07-33/image-20210305130012186.png" alt="image-20210305130012186">-</p>
<h5 id="4、常用的硬盘管理命令"><a href="#4、常用的硬盘管理命令" class="headerlink" title="4、常用的硬盘管理命令"></a>4、常用的硬盘管理命令</h5><ol>
<li><p>df – 是用于统计空间大小，统计的剩余空是准确的</p>
<p><img src="/2021/08/25/16-07-33/image-20210303220837756.png" alt="image-20210303220837756">-</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc，因为是挂载在 内存中，所以占用量都是 0</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">单位不再只用 KB，而是换算成习惯单位</td>
</tr>
<tr>
<td align="center">-T</td>
<td align="center">多出了文件系统类型一列</td>
</tr>
</tbody></table>
</li>
<li><p>dd – 复制</p>
</li>
<li><p>du – 统计文件大小，统计的文件大小是<strong>准确</strong>的（ls不准确）</p>
<p>格式：du [选项] [目录或文件名]</p>
<p><img src="/2021/08/25/16-07-33/image-20210303221035956.png" alt="image-20210303221035956">-</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">使用习惯单位显示磁盘占用量，如 KB，MB 或 GB 等</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">统计总占用量，而不列出子目录和子文件的占用量</td>
</tr>
</tbody></table>
<p><code>lsof | grep delete</code>d 查看被删除的文件，然后一个进程一个进程的手工 <strong>kill</strong> 也是可以的</p>
<p><img src="/2021/08/25/16-07-33/image-20210303220409795.png" alt="image-20210303220409795">-</p>
</li>
<li><p>fsck – 文件系统修复命令</p>
<p><img src="/2021/08/25/16-07-33/image-20210303220609797.png" alt="image-20210303220609797">-</p>
<!--自动修复--></li>
<li><p>dumpe2fs – 显示磁盘状态</p>
<p><img src="/2021/08/25/16-07-33/image-20210303220727124.png" alt="image-20210303220727124">-</p>
</li>
</ol>
<h5 id="5、磁盘分区与挂载"><a href="#5、磁盘分区与挂载" class="headerlink" title="5、磁盘分区与挂载"></a>5、磁盘分区与挂载</h5><p>大概流程就是：分区（fdisk）、格式化（mkfs）、挂载（mount）</p>
<h6 id="5-1-MBR-（主引导记录）分区表"><a href="#5-1-MBR-（主引导记录）分区表" class="headerlink" title="5.1 MBR （主引导记录）分区表"></a>5.1 MBR （主引导记录）分区表</h6><ul>
<li>最多可以分为<strong>四个主分区</strong>（含扩展分区：只能有一个，将剩余的所有空间包含在内）</li>
<li>主分区和扩展分区的编号：1-4为主分区和扩展分区的编号</li>
<li>扩展分区不能直接使用，必须在扩展分区上建立逻辑分区并格式化后才能使用</li>
<li>逻辑分区编号从<strong>5</strong>开始</li>
</ul>
<h6 id="5-2-分区-格式化-挂载"><a href="#5-2-分区-格式化-挂载" class="headerlink" title="5.2 分区+格式化+挂载"></a>5.2 分区+格式化+挂载</h6><ul>
<li><p>对新加的磁盘进行<strong>分区</strong></p>
<p>格式：<strong>fdisk 磁盘设备名</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210303221546601.png" alt="image-20210303221546601">-</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m</td>
<td align="center">查看全部可用的参数</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">添加新的分区</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">删除某个分区信息</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">列出所有可用的分区类型</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">改变某个分区的类型</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">查看分区信息</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">保存并退出</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">不保存直接退出</td>
</tr>
</tbody></table>
<!--注意用fdisk分区，只能对小于1T的硬盘进行-->

<p>注意，在向虚拟机添加了硬盘之后，不必重启，可以使用下面这种方法显示出添加的硬盘：</p>
<p>1、转到这个目录：<code>cd /sys/class/scsi_host/</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210321205733748.png" alt="image-20210321205733748"></p>
<p>2、执行下面磁盘扫描：</p>
<p>​    <code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan</code></p>
<p>​    <code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host1/scan</code></p>
<p>​    <code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host2/scan</code></p>
<p>3、使用 <code>fdisk -l</code> 就可以查看到新增加的磁盘</p>
</li>
<li><p>对磁盘进行<strong>格式化</strong></p>
<p>格式：<strong>mkfs -t 分区类型(ext2 ext3 ext4) 磁盘分区名</strong> </p>
<p>例如：<code>mkfs -t ext4 /dev/sdb1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305130535470.png" alt="image-20210305130535470">-</p>
<!---t 是指定格式化的类型--></li>
<li><p>新建挂载点，并将分区进行挂载</p>
<p>格式：<strong>mount [-t 文件系统类型] 设备分区名 挂载点</strong> </p>
<p>例如：<code>mount -t ext4 /dev/sdb1 /mnt/sdb1</code> </p>
<p>先在/mnt目录下创建一个文件夹：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305130715949.png" alt="image-20210305130715949">-</p>
<p>然后将sdb1挂载到这个文件夹上：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305130751234.png" alt="image-20210305130751234">-</p>
<p>如何查看已经挂载成功：<code>mount | grep sdb1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305130807841.png" alt="image-20210305130807841">-</p>
<p>取消挂载格式：<strong>umount 挂载点</strong></p>
</li>
</ul>
<h6 id="5-3-parted-命令"><a href="#5-3-parted-命令" class="headerlink" title="5.3 parted 命令"></a>5.3 parted 命令</h6><p>​    通常划分分区工具我们<strong>用的比较多是fdisk命令</strong>，但是现在由于磁盘越来越廉价，而且磁盘空 间越来越大。而fdisk工具他对分区是<strong>有大小限制</strong>的，它只能划分<strong>小于2T</strong>的磁盘。现在的磁盘空间 已经远远大于2T，有两个方法来解决这个问题：其一是通过<strong>卷管理</strong>来实现，其二就是通过<strong>Parted 工具</strong>来实现对2T磁盘进行分区操作。</p>
<p>​     GPT格式的磁盘相当于原来MBR磁盘中原来保留4个partition table的4*16个字节，只留第一 个16个字节，类似于扩展分区，真正的partition table在512字节之后，<strong>GPT分区方式没有四个主 分区的限制</strong>，最多可达到<strong>128个主分区</strong>。</p>
<ul>
<li><p>命令格式：parted [选项]… [设备 [命令 [参数]</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-h –help</td>
<td align="center">显示此求助信息</td>
</tr>
<tr>
<td align="center">-l –list</td>
<td align="center">列出所有设别的分区信息</td>
</tr>
<tr>
<td align="center">-i –interactive</td>
<td align="center">在必要时，提示用户</td>
</tr>
<tr>
<td align="center">-s –script</td>
<td align="center">从不提示用户</td>
</tr>
<tr>
<td align="center">-v –version</td>
<td align="center">显示版本</td>
</tr>
</tbody></table>
</li>
<li><p>parted 交互模式</p>
<p>格式：<strong>parted 分区设备文件名</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210303222909093.png" alt="image-20210303222909093">-</p>
<p>这里是等待输入parted交互命令的位置，相关<strong>交互命令</strong>如下表所示：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303222959769.png" alt="image-20210303222959769">-</p>
</li>
<li><p>查看分区</p>
<p><img src="/2021/08/25/16-07-33/image-20210303223233613.png" alt="image-20210303223233613">-</p>
</li>
<li><p>修改分区表</p>
<p>​    注意前面所采用的是 <strong>MBR</strong> 分区表，现在将要修改的是 <strong>GPT</strong> 分区表，区别就是GPT能支持更大的硬盘和能够分更多的主分区</p>
<p><img src="/2021/08/25/16-07-33/image-20210305132330899.png" alt="image-20210305132330899">-</p>
<!--注意：sdb分完区后，变成了两个/dev/sdb和/dev/sdb1，前面那个是硬盘，后面的是分区-->

<p>现在新添加一块2G硬盘：/dev/sd<strong>c</strong></p>
<p>注意：硬盘顺序：<strong>a、b、c</strong></p>
<p>前面的 /dev/sda 和 /dev/sdb 都是<strong>MBR</strong>类型的分区表</p>
<p><img src="/2021/08/25/16-07-33/image-20210305132149867.png" alt="image-20210305132149867">-</p>
<p>下面使用 /dev/sdc 这块硬盘：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305132755964.png" alt="image-20210305132755964">-</p>
<p>因为这个是<strong>修改分区表</strong>操作，所以需要先给这块硬盘分个区，才会有分区表，而且需要先采用MBR分区表，然后修改为GPT分区表：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305133201740.png" alt="image-20210305133201740">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305133323585.png" alt="image-20210305133323585">-</p>
<p>下面修改<strong>分区表为GPT</strong>：<code>parted /dev/sdc</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305133516085.png" alt="image-20210305133516085">-</p>
<!--注意：选的硬盘是 /dev/sdc 而不是/dev/sdc1，因为分区表是存放在 /dev/sdc 下，我们修改的是分区表-->

<p>查看一下没改变分区表之前的信息：<code>print</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305134121272.png" alt="image-20210305134121272">-</p>
<p>修改后如下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305133702664.png" alt="image-20210305133702664">-</p>
<p>看到 <strong>partition table: gpt</strong> 说明已经修改成功！修改分区表后原有分区和分区中的数据都会消失，而且需要重启系统才会生效；</p>
<p>注意，如果在/etc/fstab 文件中添加了挂载信息， 一定要把/etc/fstab 文件中和原有分区的内容删除掉，才能重启动。要不系统启动就一定会报错的</p>
<p>因为修改分区表后，数据都被删除了，所以接下来需要<strong>建立分区</strong>！</p>
</li>
<li><p>建立分区</p>
<p>输入：<code>mkpart</code></p>
<p>起始点：因为真正的partition table在512字节之后，所以这里可以输入512B</p>
</li>
<li><p>格式化分区</p>
</li>
<li><p>调整分区大小</p>
</li>
<li><p>删除分区</p>
</li>
</ul>
<h6 id="5-4-gparted-命令"><a href="#5-4-gparted-命令" class="headerlink" title="5.4 gparted 命令"></a>5.4 gparted 命令</h6><p>​    就是一个带图形界面的parted，需要在带有桌面的系统上运行！</p>
<h6 id="5-5-分配-swap-分区"><a href="#5-5-分配-swap-分区" class="headerlink" title="5.5 分配 swap 分区"></a>5.5 分配 swap 分区</h6><ul>
<li><p>修改分区ID</p>
<p>使用fdisk命令进行分区，并修改为swap 分区 ID为82</p>
<p>格式：<code>fdisk 分区设备文件名</code></p>
</li>
<li><p>格式化 swap 分区</p>
<p>格式：<code>mkswap 分区设备文件名</code> </p>
</li>
<li><p>使用 swap 分区</p>
<p>格式：<code>swapon 分区设备文件名</code></p>
<p>然后使用 <code>free -m</code> 查看</p>
</li>
<li><p>禁用 swap 分区</p>
<p>格式：<code>swapoff 分区设备文件名</code></p>
</li>
</ul>
<p><strong>CentOS7，LVM根分区扩容步骤</strong>：</p>
<p>​    <a href="https://www.jianshu.com/p/273daea17b2">https://www.jianshu.com/p/273daea17b2</a></p>
<h3 id="9-3-磁盘阵列配置"><a href="#9-3-磁盘阵列配置" class="headerlink" title="9.3 磁盘阵列配置"></a>9.3 磁盘阵列配置</h3><h4 id="1、RAID简介"><a href="#1、RAID简介" class="headerlink" title="1、RAID简介"></a>1、RAID简介</h4><p>（RAID）独立硬盘冗余阵列（<strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>nexpensive <strong>D</strong>isks）</p>
<p>磁盘阵列分为：硬件阵列和软件阵列，由于买不起硬件，所有下面操作都是基于软件阵列</p>
<p>RAID分为：RAID0、RAID1、RAID5、RAID10（RAID01）</p>
<p>==RAID0==：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318212632845.png" alt="image-20210318212632845">-</p>
<p><strong>说明</strong>：RAID 0又称为Stripe或Striping，它代表了所有RAID级别中<u>最高的存储性能</u>。RAID 0提高存储性能的原理是把连续的数据分散到多个磁盘上存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能</p>
<p><strong>工作原理</strong>：系统向三个磁盘组成的逻辑硬盘（RAID0 磁盘组）发出的I/O数据请求被转化为3项操作，其中的每一项操作都对应于一块物理硬盘。通过建立RAID 0，原先顺序的数据请求被分散到所有的三块硬盘中同时执行。从理论上讲，三块硬盘的并行操作使同一时间内磁盘读写速度提升了3倍。 但由于总线带宽等多种因素的影响，实际的提升速率肯定会低于理论值，但是，大量数据并行传输与串行传输比较，提速效果显著显然毋庸置疑</p>
<p><strong>优缺点</strong>：读写性能是所有RAID级别中最高的。RAID 0的缺点是不提供数据冗余，因此一旦用户数据损坏，损坏的数据将无法得到恢复。RAID0运行时只要其中任一块硬盘出现问题就会导致整个数据的故障。一般不建议企业用户单独使用</p>
<p><strong>总结</strong>：</p>
<p>磁盘空间使用率：100%，故成本最低</p>
<p>读性能：N*单块磁盘的读性能</p>
<p>写性能：N*单块磁盘的写性能</p>
<p>冗余：无，任何一块磁盘损坏都将导致数据不可用</p>
<p>==RAID1==：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318212607908.png" alt="image-20210318212607908">-</p>
<p><strong>说明</strong>：RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中<u>单位成本最高的</u>，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据</p>
<p><strong>工作原理</strong>：RAID1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。RAID1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAID0磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID1磁盘阵列一般支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。在这里，需要注意的是，读只能在一块磁盘上进行，并不会进行并行读取，性能取决于硬盘中较快的一块。写的话通常比单块磁盘要慢，虽然是并行写，即对两块磁盘的写入是同时进行的，但因为要比较两块硬盘中的数据，所以性能比单块磁盘慢</p>
<p><strong>优缺点</strong>：RAID1通过硬盘数据镜像实现数据的冗余，保护数据安全，在两块盘上产生互为备份的数据，当原始数据繁忙时，可直接从镜像备份中读取数据，因此RAID1可以提供读取性能。RAID1是硬盘中单位成本最高的，但提供了很高的数据安全性和可用性，当一个硬盘失效时，系统可以自动切换到镜像硬盘上读/写，并且不需要重组失效的数据</p>
<p><strong>总结</strong>：</p>
<p>磁盘空间使用率：50%，故成本最高</p>
<p>读性能：只能在一个磁盘上读取，取决于磁盘中较快的那块盘</p>
<p>写性能：两块磁盘都要写入，虽然是并行写入，但因为要比对，故性能单块磁盘慢。</p>
<p>冗余：只要系统中任何一对镜像盘中有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行</p>
<p>==RAID5==：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318212449754.png" alt="image-20210318212449754">-</p>
<p><strong>说明</strong>：RAID 5是RAID 0和RAID 1的折中方案。RAID 5具有和RAID0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前运用较多的一种解决方案</p>
<p><strong>工作原理</strong>：RAID5把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上，其中任意N-1块磁盘上都存储完整的数据，也就是说有相当于一块磁盘容量的空间用于存储奇偶校验信息。因此当RAID5的一个磁盘发生损坏后，不会影响数据的完整性，从而保证了数据安全。当损坏的磁盘被替换后，RAID还会自动利用剩下奇偶校验信息去重建此磁盘上的数据，来保持RAID5的高可靠性。</p>
<p><strong>优缺点</strong>：做raid 5阵列所有磁盘容量必须一样大，当容量不同时，会以最小的容量为准。 最好硬盘转速一样，否则会影响性能，而且可用空间=磁盘数n-1，Raid 5 没有独立的奇偶校验盘，所有校验信息分散放在所有磁盘上， 只占用一个磁盘的容量</p>
<p><strong>总结</strong>：</p>
<p>磁盘空间利用率：(N-1)/N，即只浪费一块磁盘用于奇偶校验</p>
<p>读性能：(n-1)*单块磁盘的读性能，接近RAID0的读性能</p>
<p>写性能：比单块磁盘的写性能要差</p>
<p>冗余：只允许一块磁盘损坏</p>
<p>==RAID10==：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318212430557.png" alt="image-20210318212430557">-</p>
<p><strong>说明</strong>：RAID10也被称为镜象阵列条带。象RAID0一样，数据跨磁盘抽取；象RAID1一样，每个磁盘都有一个镜象磁盘, 所以RAID 10的另一种会说法是 RAID 0+1。RAID10提供100%的数据冗余，支持更大的卷尺寸，但价格也相对较高。对大多数只要求具有冗余度而不必考虑价格的应用来说，RAID10提供最好的性能。使用RAID10，可以获得更好的可靠性，因为即使两个物理驱动器发生故障（每个阵列中一个），数据仍然可以得到保护。RAID10需要4 + 2*N 个磁盘驱动器（N &gt;=0)， 而且只能使用其中一半(或更小, 如果磁盘大小不一)的磁盘用量, 例如 4 个 250G 的硬盘使用RAID10 阵列， 实际容量是 500G</p>
<p><strong>工作原理</strong>：Raid10其实结构非常简单，首先创建2个独立的Raid1，然后将这两个独立的Raid1组成一个Raid0，当往这个逻辑Raid中写数据时，数据被有序的写入两个Raid1中。磁盘1和磁盘2组成一个Raid1，磁盘3和磁盘4又组成另外一个Raid1;这两个Raid1组成了一个新的Raid0。如写在硬盘1上的数据1、3、5、7，写在硬盘2中则为数据1、3、5、7，硬盘中的数据为0、2、4、6，硬盘4中的数据则为0、2、4、6，因此数据在这四个硬盘上组合成Raid10，且具有raid0和raid1两者的特性。</p>
<p><strong>优缺点</strong>：虽然Raid10方案造成了50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性，并且当同时损坏的磁盘不在同一Raid1中，就能保证数据安全性。假如磁盘中的某一块盘坏了，整个逻辑磁盘仍能正常工作的。当我们需要恢复RAID10中损坏的磁盘时，只需要更换新的硬盘，按照RAID10的工作原理来进行数据恢复，恢复数据过程中系统仍能正常工作。原先的数据会同步恢复到更换的硬盘中</p>
<p><strong>总结</strong>：</p>
<p>磁盘空间利用率：50%</p>
<p>读性能：N/2*单块硬盘的读性能</p>
<p>写性能：N/2*单块硬盘的写性能</p>
<p>冗余：只要一对镜像盘中有一块磁盘可以使用就没问题</p>
<h4 id="2、实现磁盘阵列"><a href="#2、实现磁盘阵列" class="headerlink" title="2、实现磁盘阵列"></a>2、实现磁盘阵列</h4><p>安装 mdadm 工具：<code>yum install -y mdadm</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318213207468.png" alt="image-20210318213207468">-</p>
<h5 id="2-1-RAID0"><a href="#2-1-RAID0" class="headerlink" title="2.1 RAID0"></a>2.1 RAID0</h5><p><strong>流程</strong>：==添加硬盘 ——-&gt;&gt;&gt;&gt;&gt; 分区 ——-&gt;&gt;&gt;&gt;&gt; 创建RAID0 ——-&gt;&gt;&gt;&gt;&gt; 格式化 ——-&gt;&gt;&gt;&gt;&gt; 挂载==</p>
<p><strong>添加两块硬盘</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318213712493.png" alt="image-20210318213712493">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318214017789.png" alt="image-20210318214017789">-</p>
<p><strong>分区</strong>：<code>fdisk /dev/sdb</code> 和 <code>fdisk /dev/sdc</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318215512689.png" alt="image-20210318215512689">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318215323473.png" alt="image-20210318215323473">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318215935625.png" alt="image-20210318215935625">-</p>
<p><strong>创建RAID0</strong>：<code>mdadm -Cv /dev/md0 -a yes -n 2 -l 0 /dev/sdb1 /dev/sdc1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdadm -Cv 阵列磁盘名 -a yes -n 2 -l 0 分区1 分区2 .....</span><br><span class="line"><span class="meta">#</span><span class="bash"> C代表创建操作，-v显示创建过程，-a yes检查RAID名称，-n(name)是用到硬盘个数，-l(level)定义RAID的级别而后面写上要增加整列的硬盘名称</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210318220506902.png" alt="image-20210318220506902">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318220542774.png" alt="image-20210318220542774">-</p>
<p><strong>格式化</strong>：<code>mkfs -t ext4 /dev/md0</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318221008679.png" alt="image-20210318221008679">-</p>
<p><strong>挂载分区</strong>：<code>mkdir /mnt/md0</code> ——-&gt;&gt;&gt;&gt;&gt; <code>mount /dev/md0 /mnt/md0</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319214253562.png" alt="image-20210319214253562">-</p>
<p>成功了！</p>
<p>由于RAID0是速度最快的，下面来实测一下，看看传输数据的速度有没有变快：</p>
<p>首先生成一个1G的大文件：<code>dd if=/dev/zero of=file bs=1M count=1000</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319215721176.png" alt="image-20210319215721176">-</p>
<p>然后使用 <strong>time</strong> 命令来记录cp消耗的时间：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319222441898.png" alt="image-20210319222441898">-</p>
<p>这里可以看到只用了不到3秒！</p>
<p>下面来看看不是RAID0所消耗的时间：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319222538622.png" alt="image-20210319222538622">-</p>
<p><strong>对比简直惊人，居然差距这么大！！！</strong></p>
<!--说明，一般情况下，real=user+sys-->

<h5 id="2-2-RAID1"><a href="#2-2-RAID1" class="headerlink" title="2.2 RAID1"></a>2.2 RAID1</h5><p><strong>流程</strong>：==添加硬盘 ——-&gt;&gt;&gt;&gt;&gt; 分区 ——-&gt;&gt;&gt;&gt;&gt; 创建RAID1 ——-&gt;&gt;&gt;&gt;&gt; 格式化 ——-&gt;&gt;&gt;&gt;&gt; 挂载==</p>
<p><strong>添加硬盘</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319223551288.png" alt="image-20210319223551288">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319223721781.png" alt="image-20210319223721781">-</p>
<p><strong>分区</strong>：<code>fdisk /dev/sdb</code> 和 <code>fdisk /dev/sdc</code></p>
<p><strong>创建RAID1</strong>：<code>mdadm -Cv /dev/md1 -a yes -n 2 -l 1 /dev/sdb1 /dev/sdc1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319224046568.png" alt="image-20210319224046568">-</p>
<p><strong>格式化</strong>：<code>mkfs -t ext4 /dev/md1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319224307541.png" alt="image-20210319224307541">-</p>
<p><strong>挂载</strong>：<code>mkdir /mnt/md1</code> ——-&gt;&gt;&gt;&gt;&gt; <code>mount /dev/md1 /mnt/md1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319224412879.png" alt="image-20210319224412879">-</p>
<p>由于两块磁盘都要写入，虽然是并行写入，但因为要比对，故性能单块磁盘慢，下面来测试一下cp的速度：</p>
<p>先放上面测试的速度：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319222538622.png" alt="image-20210319222538622">-</p>
<p>下面开始：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319230700163.png" alt="image-20210319230700163">-</p>
<p>还是很快啊？shit看不出区别啊，感觉跟RAID0差不多啊？？？还是比RAID0慢了一点点！</p>
<p>查看一下磁盘阵列：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319231149379.png" alt="image-20210319231149379">-</p>
<p>下面来模拟一个磁盘损坏，查看结果：</p>
<p>还得添加一块硬盘，操作方法同上！</p>
<p><img src="/2021/08/25/16-07-33/image-20210319231236860.png" alt="image-20210319231236860">-</p>
<p>然后分区，格式化，格式化之后使用：<code>mdadm /dev/md1 -a /dev/sdd1</code> 来加入磁盘</p>
<p><img src="/2021/08/25/16-07-33/image-20210319231529589.png" alt="image-20210319231529589">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319231546156.png" alt="image-20210319231546156">-</p>
<p>先进到这个目录下创建一点文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319231843564.png" alt="image-20210319231843564">-</p>
<p>下面开始模拟损坏：<code>mdadm /dev/md1 -f /dev/sdc1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319231937799.png" alt="image-20210319231937799">-</p>
<p>然后查看一下磁盘阵列：<code>mdadm -D /dev/md1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319232013837.png" alt="image-20210319232013837">-</p>
<p>然后进到该目录下，查看刚刚创建的文件是否还在：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319232045203.png" alt="image-20210319232045203">-</p>
<p>没毛病老铁！</p>
<h5 id="2-3-RAID10"><a href="#2-3-RAID10" class="headerlink" title="2.3 RAID10"></a>2.3 RAID10</h5><p>首先创建2个独立的<strong>Raid1</strong>，然后将这两个独立的Raid1组成一个<strong>Raid0</strong></p>
<p><strong>流程</strong>：</p>
<p>​    ==添加硬盘 ——&gt;&gt;&gt;&gt;&gt; 分区 ——&gt;&gt;&gt;&gt;&gt; 创建RAID1 ——&gt;&gt;&gt;&gt;&gt;  创建RAID0 ——&gt;&gt;&gt;&gt;&gt; 格式化 ——&gt;&gt;&gt;&gt;&gt; 挂载==</p>
<p><strong>添加硬盘</strong>：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321141753212.png" alt="image-20210321141753212">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321141907471.png" alt="image-20210321141907471">-</p>
<p><strong>分区</strong>：</p>
<p>​    <code>fdisk /dev/sdb</code> 和 <code>fdisk /dev/sdc</code>：<code>fdisk /dev/sdd</code> 和 <code>fdisk /dev/sde</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321142227360.png" alt="image-20210321142227360">-</p>
<p><strong>创建RAID10</strong>：</p>
<p>​    <code>mdadm -Cv /dev/md10 -a yes -n 4 -l 10 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210321150434295.png" alt="image-20210321150434295">-</p>
<p><strong>格式化</strong>：</p>
<p>​    <code>mkfs -t ext4 /dev/md10</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321150604158.png" alt="image-20210321150604158">-</p>
<p><strong>挂载</strong>：</p>
<p>​    <code>mkdir /mnt/md10</code> ——-&gt;&gt;&gt;&gt;&gt; <code>mount /dev/md10 /mnt/md10 </code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321150744551.png" alt="image-20210321150744551">-</p>
<p><strong>测试速度</strong>：</p>
<p>​    这里还是拷贝1G文件来作为对比，这里比较的是RAID0、RAID1和不做磁盘阵列的速度：</p>
<p>​    RAID0的速度：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210319222441898.png" alt="image-20210319222441898">-</p>
<p>​    RAID1的速度：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210319230700163.png" alt="image-20210319230700163">-</p>
<p>​    RAID10的速度：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321150834843.png" alt="image-20210321150834843">-</p>
<p>​    不做磁盘阵列的速度：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210319222538622.png" alt="image-20210319222538622">-</p>
<p><strong>测试数据安全</strong>：</p>
<p>​    创建几个文件进去：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321150934663.png" alt="image-20210321150934663">-</p>
<p>​    模拟磁盘损坏：<code>mdadm /dev/md10 -f /dev/sdc1</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321151125870.png" alt="image-20210321151125870">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321151109835.png" alt="image-20210321151109835"></p>
<p>​    查看一下文件还在否：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210321151200929.png" alt="image-20210321151200929">-</p>
<p>​    从结果可以看出，RAID10的速度是很快的，而且还具备单磁盘损坏的数据安全性，兼具了RAID1和RAID0的优点！</p>
<h3 id="9-4-搭建-samba-服务器"><a href="#9-4-搭建-samba-服务器" class="headerlink" title="9.4 搭建 samba 服务器"></a>9.4 搭建 samba 服务器</h3><p>​    Samba是在Linux系统上实现SMB（Session MessageBlock）协议的一个免费软件，以实现Linux之间、Linux与windows之间的文件共享和打印机服务共享。</p>
<p>​    samba有两个主要的进程<strong>smbd</strong>和<strong>nmbd</strong></p>
<p>​    smbd进程提供了文件和打印服务</p>
<p>​    nmbd提供了NetBIOS名称服务和浏览支持，帮助SMB客户定位服务器，处理所有基于UDP的协议</p>
<p><strong>具体操作</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙添加samba服务</span></span><br><span class="line">firewall-cmd --permanent --add-service=samba</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 selinux 机制</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-----------------------------------</span></span><br><span class="line">mkdir /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">mkdir /etc/yum.repos.d/bak &amp;&gt; /dev/null</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">mount /dev/sr0 /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/dvd.repo</span><br><span class="line">[dvd]</span><br><span class="line">name=centos7</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enable=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line">echo &quot;配置本地镜像成功！&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">-----------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装samba服务端</span></span><br><span class="line">yum install -y samba samba-client 1&gt; /dev/null</span><br><span class="line">systemctl start smb.service nmb.service 1&gt; /dev/null</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个用来共享的文件夹</span></span><br><span class="line">DIR_SHARE=/mnt/share_for_samba</span><br><span class="line">mkdir $&#123;DIR_SHARE&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个用户组，并赋予这个组访问共享文件夹的权限</span></span><br><span class="line">G_SHARE=share_group</span><br><span class="line">groupadd $&#123;G_SHARE&#125;</span><br><span class="line">chgrp $&#123;G_SHARE&#125; $&#123;DIR_SHARE&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个用户，隶属于 share_group 组</span></span><br><span class="line">U_1=worker_1</span><br><span class="line">useradd -g $&#123;G_SHARE&#125; $&#123;U_1&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为 worker_1 设置密码</span></span><br><span class="line">echo 123 | passwd --stdin $&#123;U_1&#125; &amp;&gt; /dev/null</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 worker_1 到 samba 服务器中</span></span><br><span class="line">smbpasswd -a $&#123;U_1&#125; &lt;&lt; EOF</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">EOF</span><br><span class="line">echo &quot;samba用户添加成功：worker_1&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 [global] 后添加一行map to guest = Bad User，允许匿名用户访问</span></span><br><span class="line">SMBCONF=/etc/samba/smb.conf</span><br><span class="line">sed -i &#x27;/\[global\]/a \\tmap to guest = Bad User&#x27; $&#123;SMBCONF&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">cat &lt;&lt; EOF &gt;&gt; $&#123;SMBCONF&#125;</span><br><span class="line">[public]</span><br><span class="line">        comment = public</span><br><span class="line">        path = $&#123;DIR_SHARE&#125;</span><br><span class="line">        public = yes</span><br><span class="line">        writable = yes</span><br><span class="line">        valid users = @$&#123;G_SHARE&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;samba服务器搭建完成，请输入 -&gt;&gt;&gt; smbclient -L localhost &lt;&lt;&lt;- 查看服务器有哪些共享文件夹&quot;</span></span></span><br><span class="line">echo &quot;请输入 -&gt;&gt;&gt; smbclient -U 用户名 //localhost/共享文件夹 &lt;&lt;&lt;- 来访问samba服务器&quot;</span><br></pre></td></tr></table></figure>

<p>若想<strong>在linux访问Windows的目录</strong>：</p>
<p>1、先在Windows上创建共享文件夹：</p>
<p>​    右击文件夹或文件，选择属性，然后点击共享点击高级共享，勾选共享此文件夹，然后点击确定</p>
<p>2、在Linux上挂载：</p>
<p>​    mount -t cifs -o username=XXX,password=XXX //Windows的IP地址/这里看一下刚刚设置共享文件夹那显示的网络路径 /挂载点</p>
<p>3、就可以访问了！，如果还是不行，则请百度解决：<a href="https://blog.51cto.com/13687537/2152262">https://blog.51cto.com/13687537/2152262</a></p>
<h3 id="9-5-搭建-NFS-服务器"><a href="#9-5-搭建-NFS-服务器" class="headerlink" title="9.5 搭建 NFS 服务器"></a>9.5 搭建 NFS 服务器</h3><p>​    NFS（Network File System，网络文件系统）是由Sun公司于1984年开发出来，主要用于UNIX/Linux系统之间的文件共享。它采用<strong>客户端/服务器</strong>工作模式，在NFS服务器上将某个目录设置为<strong>共享目录</strong>，然后在客户端可以将这个目录<strong>挂载</strong>到本地使用</p>
<p>在NFS服务器上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙添加nfs服务</span></span><br><span class="line">firewall-cmd --permanent --add-service=nfs</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装所需软件包：</span></span><br><span class="line">yum install -y nfs-utils </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑文件</span></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/exports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式： 共享的文件夹 需要访问的主机（权限）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rw 可读写，ro 只读</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sync 同步模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fsid=0 表示将 /mnt/cdrom 整个目录包装成根目录</span></span><br><span class="line">/mnt/cdrom /mnt/cdrom 192.168.2.117(rw,sync,fsid=0)</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用exportfs命令，当改变/etc/exports配置文件后，不用重启nfs服务直接用这个exportfs即可，它的常用选项为[-aruv].</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a ：全部挂载或者卸载；</span>      </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r ：重新挂载；</span>      </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u ：卸载某一个目录；</span>      </span><br><span class="line"><span class="meta">#</span><span class="bash"> -v ：显示共享的目录；</span></span><br><span class="line">exportfs -arv</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">systemctl start rpcbind nfs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认NFS服务器启动成功：</span>   </span><br><span class="line"><span class="meta">#</span><span class="bash"> rpcinfo -p</span>  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过查看service列中是否有nfs服务来确认NFS是否启动。</span></span><br><span class="line">showmount -e localhost</span><br><span class="line"></span><br><span class="line">echo &quot;配置 nfs 完成！&quot;</span><br></pre></td></tr></table></figure>

<p>在NFS客户机上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">echo &quot;正在创建挂载点！&quot;</span><br><span class="line">mkdir -p /root/nfs/h1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">echo &quot;开始挂载！&quot;</span><br><span class="line">mount -t nfs 192.168.2.116:/mnt/cdrom /root/nfs/h1</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;挂载成功！&quot;</span></span></span><br><span class="line">df -Th</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若服务器重新设置过，保存后，重新挂载</span></span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure>



<h2 id="第十章-系统管理篇"><a href="#第十章-系统管理篇" class="headerlink" title="第十章 系统管理篇"></a>第十章 系统管理篇</h2><h3 id="10-1-进程管理"><a href="#10-1-进程管理" class="headerlink" title="10.1 进程管理"></a>10.1 进程管理</h3><h4 id="10-1-1-进程简介"><a href="#10-1-1-进程简介" class="headerlink" title="10.1.1 进程简介"></a>10.1.1 进程简介</h4><p>​    进程是一个正在执行的命令或程序，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p>
<h4 id="10-1-2-进程管理的作用"><a href="#10-1-2-进程管理的作用" class="headerlink" title="10.1.2 进程管理的作用"></a>10.1.2 进程管理的作用</h4><ol>
<li>判断服务器健康状态</li>
<li>查看系统中所有进程</li>
<li>杀死进程</li>
</ol>
<h4 id="10-1-3-查看系统中所有的进程"><a href="#10-1-3-查看系统中所有的进程" class="headerlink" title="10.1.3 查看系统中所有的进程"></a>10.1.3 查看系统中所有的进程</h4><p>​    <strong>命令1：<code>ps -aux</code></strong></p>
<p>​    <strong>作用：查看系统中所有进程，使用<u>BSD操作系统</u>格式（常用）</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210203213405615.png" alt="image-20210203213405615">-</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ps -a</td>
<td align="center">显示当前终端的所有进程信息</td>
</tr>
<tr>
<td align="center">ps -u</td>
<td align="center">以用户的格式显示进程信息</td>
</tr>
<tr>
<td align="center">ps -x</td>
<td align="center">显示后台进程运行的参数</td>
</tr>
<tr>
<td align="center">ps -q 进程PID</td>
<td align="center">通过进程号查询对于的进程名</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">USER</td>
<td align="center">该进程是由哪个用户产生的</td>
</tr>
<tr>
<td align="center">PID</td>
<td align="center">进程的ID号</td>
</tr>
<tr>
<td align="center">%CPU</td>
<td align="center">该进程占用CPU资源的百分比</td>
</tr>
<tr>
<td align="center">%MEM</td>
<td align="center">该进程占用物理内存的百分比</td>
</tr>
<tr>
<td align="center">VSZ</td>
<td align="center">该进程占用虚拟内存的大小，单位KB</td>
</tr>
<tr>
<td align="center">RSS</td>
<td align="center">该进程占用实际物理内存的大小，单位KB</td>
</tr>
<tr>
<td align="center">TTY</td>
<td align="center">该进程是在哪个终端中运行的；<strong>tty1-tty6</strong>代表本地控制台终端；tty7代表本地图形终端；<strong>pts/0-255</strong>代表虚拟终端</td>
</tr>
<tr>
<td align="center">START</td>
<td align="center">进程状态：<strong>R 运行</strong>、<strong>S 睡眠</strong>、<strong>T 停滞状态</strong>、<strong>s 包含子进程</strong>、**+ 位于后台**</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">该进程占用CPU的运算时间，注意不是系统时间</td>
</tr>
<tr>
<td align="center">COMMAND</td>
<td align="center">产生此进程的命令名</td>
</tr>
</tbody></table>
<p>​    <strong>命令2：<code>ps  -le</code></strong></p>
<p>​    <strong>作用：查看系统中所有进程，使用<u>Linux操作系统</u>格式</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210203213607374.png" alt="image-20210203213607374">-</p>
<h4 id="10-1-4-查看系统健康状态"><a href="#10-1-4-查看系统健康状态" class="headerlink" title="10.1.4 查看系统健康状态"></a>10.1.4 查看系统健康状态</h4><p>​    命令：<strong>top</strong></p>
<p>​    选项：-d 秒数，指定top命令每隔几秒更新，<strong>默认是3秒</strong></p>
<p>​    <strong>在top命令的<u>交互模式中</u>可以执行的命令：</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">？或 h</td>
<td align="center">显示交互模式的帮助</td>
</tr>
<tr>
<td align="center">P：（大写）</td>
<td align="center">以CPU使用率排序，默认就是这个</td>
</tr>
<tr>
<td align="center">M：</td>
<td align="center">以内存的使用率排序</td>
</tr>
<tr>
<td align="center">N：</td>
<td align="center">以PID排序</td>
</tr>
<tr>
<td align="center">q：</td>
<td align="center">退出top</td>
</tr>
</tbody></table>
<p>​    <img src="/2021/08/25/16-07-33/image-20210203221857033.png" alt="image-20210203221857033"></p>
<p><strong>第一行为<u>任务队列</u>信息：</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">22：18：37</td>
<td align="center">系统当前时间</td>
</tr>
<tr>
<td align="center">up 2：24</td>
<td align="center">系统的运行时间，以运行2小时24分钟</td>
</tr>
<tr>
<td align="center">2 users</td>
<td align="center">当前登录了两个用户</td>
</tr>
<tr>
<td align="center">load average：0.00，0.01，0.05</td>
<td align="center">系统在之前的1分钟、5分钟、15分钟的平均负载。一般小于1时负载小，大于1时负载大。</td>
</tr>
</tbody></table>
<p><strong>第二行为<u>进程</u>信息：</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tasks：99 total</td>
<td align="center">系统中的进程总数</td>
</tr>
<tr>
<td align="center">1 running</td>
<td align="center">正在运行的进程数</td>
</tr>
<tr>
<td align="center">98 sleeping</td>
<td align="center">睡眠的进程</td>
</tr>
<tr>
<td align="center">0 stopped</td>
<td align="center">正在停止的进程</td>
</tr>
<tr>
<td align="center">0 zombie</td>
<td align="center">僵尸进程。如果不是0，需要手工检查僵尸进程</td>
</tr>
</tbody></table>
<p><strong>第三行为<u>CPU</u>信息：</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.0 us</td>
<td align="center">用户模式占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.3 sy</td>
<td align="center">系统模式占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.0 ni</td>
<td align="center">改变过优先级的用户进程占用的CPU百分比</td>
</tr>
<tr>
<td align="center">99.7 id</td>
<td align="center">空闲CPU的百分比</td>
</tr>
<tr>
<td align="center">0.0 wa</td>
<td align="center">等待输入/输出的进程的占用CPU百分比</td>
</tr>
<tr>
<td align="center">0.0 hi</td>
<td align="center">硬中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.0 si</td>
<td align="center">软中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.0 st（steal time）</td>
<td align="center">虚拟时间百分比，就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。</td>
</tr>
</tbody></table>
<p><strong>第四行为<u>物理内存</u>信息：</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">995676 total</td>
<td align="center">物理内存的总量，单位KB</td>
</tr>
<tr>
<td align="center">700420 free</td>
<td align="center">空闲的物理内存数量</td>
</tr>
<tr>
<td align="center">167808 used</td>
<td align="center">已使用的物理内存数量</td>
</tr>
<tr>
<td align="center">127448 buff/cache</td>
<td align="center">作为缓冲的内存数量</td>
</tr>
</tbody></table>
<p><strong>第五行为<u>交换分区（swap）</u>信息：</strong></p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">630780 total</td>
<td align="center">交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td align="center">630780 free</td>
<td align="center">空闲的交换分区大小</td>
</tr>
<tr>
<td align="center">0 used</td>
<td align="center">已使用的交换分区大小</td>
</tr>
<tr>
<td align="center">688876 avail Mem</td>
<td align="center">作为缓存的交换分区大小</td>
</tr>
</tbody></table>
<h4 id="10-1-5-查看进程树"><a href="#10-1-5-查看进程树" class="headerlink" title="10.1.5 查看进程树"></a>10.1.5 查看进程树</h4><p>​    命令：pstree</p>
<p>​    选项：-p 显示进程的PID</p>
<p>​               -u 显示进程的所属用户</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210203224112375.png" alt="image-20210203224112375">-</p>
<p>​    <u><code>tree 目录</code>：可以以树形结构查看一个目录</u></p>
<h4 id="10-1-6-终止进程"><a href="#10-1-6-终止进程" class="headerlink" title="10.1.6 终止进程"></a>10.1.6 终止进程</h4><ol>
<li><p>kill – 终止一个进程</p>
<p><u>kill 所在路径：/usr/bin/kill</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204102511203.png" alt="image-20210204102511203">-</p>
<!--"-l 查看可用的进程信号"--></li>
</ol>
<table>
<thead>
<tr>
<th align="center">信号代号</th>
<th align="center">信号名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIGHUP</td>
<td align="center">该信号让进程立即关闭，然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGINT</td>
<td align="center">程序终止信号，用户终止前台进程。相当于输入 <strong>ctrl+c</strong> 快捷键</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">SIGPPE</td>
<td align="center">在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SIGKILL</td>
<td align="center">用来立即结束程序的运行，本信号不能被阻塞、处理和忽略，一般用于强制终止进程</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SIGALRM</td>
<td align="center">时钟定时信号，计算的是实际的时间或时钟时间。alarm函数使用该信号</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SIGTERM</td>
<td align="center">正常结束进程的信号，kill命令的默认信号，有时如果进程已经发生问题，这个信号是无法正常终止进程的，才会场时SIGKILL信号，也就是信号9</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">SIGONT</td>
<td align="center">该信号可以让暂停的进程回复执行，本信号不能被阻断</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">SIGSTOP</td>
<td align="center">该信号可以暂停前台进程，相当于输入ctrl+z快捷键，本信号不能被阻断</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210204103931806.png" alt="image-20210204103931806">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204104025110.png" alt="image-20210204104025110">-</p>
<p>-<!--“-9 对应的就是杀死该进程”--></p>
<ol>
<li><p>killall – 按照进程名杀死进程</p>
<p><u>killall 所在路径：/usr/bin/killall</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204110205856.png" alt="image-20210204110205856">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204110242547.png" alt="image-20210204110242547">-</p>
<!--“-i 交互式，询问是否要杀死某个进程、-I（大i）忽略进程名的大小写”-->

<!--输入的是进程名不是PID-->

<!--与 kill 不同的是它会杀死指定名字的所有进程--></li>
<li><p>pkill – 按照进程名杀死进程</p>
<p><u>pkill 所在路径：/usr/bin/pkill</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204110827575.png" alt="image-20210204110827575">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204110859823.png" alt="image-20210204110859823">-</p>
<!--用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程，类似于 killall 命令-->

<p><img src="/2021/08/25/16-07-33/image-20210204111233219.png" alt="image-20210204111233219">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204111306666.png" alt="image-20210204111306666">-</p>
<!--强制杀死从pts/0虚拟终端登录的进程："pkill -t -9 pts/0"--></li>
</ol>
<h4 id="10-1-7-进程管理"><a href="#10-1-7-进程管理" class="headerlink" title="10.1.7 进程管理"></a>10.1.7 进程管理</h4><ol>
<li><p>nice – 启动程序时指定进程优先级</p>
<p>说明：以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）</p>
<p>例如，将ls的优先序加1并执行：<code>nice -n 1 ls</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319132159975.png" alt="image-20210319132159975">-</p>
</li>
<li><p>renice – 调整现有进程的优先级</p>
<p><code>renice +1 PID</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319132528207.png" alt="image-20210319132528207">-</p>
</li>
<li><p>gprof – 分析程序的性能</p>
<p>参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/150527364">https://zhuanlan.zhihu.com/p/150527364</a></p>
</li>
<li></li>
</ol>
<h3 id="10-2-工作管理"><a href="#10-2-工作管理" class="headerlink" title="10.2 工作管理"></a>10.2 工作管理</h3><h3 id="10-3-系统资源查看"><a href="#10-3-系统资源查看" class="headerlink" title="10.3 系统资源查看"></a>10.3 系统资源查看</h3><ol>
<li><p>vmstat – 监控系统资源</p>
<p><u>vmstat 所在路径：/usr/bin/vmstat</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204113151457.png" alt="image-20210204113151457">-</p>
<!--格式：vmstat [刷新延时 刷新次数]-->

<!--默认只显示两行--></li>
<li><p>dmesg – 开机时的内核检测信息</p>
<p><u>dmesg 所在路径：/usr/bin/dmesg</u> </p>
<p><img src="/2021/08/25/16-07-33/image-20210204114359893.png" alt="image-20210204114359893">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204114520093.png" alt="image-20210204114520093">-</p>
<!--并利用 grep 从中查询带有CPU的行--></li>
<li><p>free – 查看内存使用状态</p>
<p><u>free 所在路径：/usr/bin/free</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204114912814.png" alt="image-20210204114912814">-</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-b</td>
<td align="center">以字节为单位显示</td>
</tr>
<tr>
<td align="center">-k</td>
<td align="center">以KB为单位显示（默认）</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">以MB为单位显示</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">以GB为单位显示</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210204115111346.png" alt="image-20210204115111346">-</p>
<!--注意：man free后看到描述那一栏，其中有写"The information is gathered by parsing /proc/meminfo"-->

<p>所以我们完全可以使用 <code>cat /proc/meminfo</code> 来查看内存信息，类似于下面的查看CPU信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210307144247681.png" alt="image-20210307144247681">-</p>
</li>
<li><p>cat /proc/cpuinfo – 查看CPU信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210204115334542.png" alt="image-20210204115334542">-</p>
</li>
<li><p>uptime – 显示top命令的第一行</p>
<p><u>uptime  所在路径：/usr/bin/uptime</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204115436703.png" alt="image-20210204115436703">-</p>
<!--w命令第一行也是这个--></li>
<li><p>uname – 查看系统与内核相关信息</p>
<p><u>uname 所在路径：/usr/bin/uname</u></p>
<p><img src="/2021/08/25/16-07-33/image-20210204115536311.png" alt="image-20210204115536311">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204115619146.png" alt="image-20210204115619146">-</p>
</li>
<li><p>file /bin/ls – 判断当前系统的位数</p>
<p><img src="/2021/08/25/16-07-33/image-20210204115701062.png" alt="image-20210204115701062">-</p>
</li>
<li><p><del>lsb_release -a~~~~不能用</del></p>
<p>cat /etc/centos-release – 查询当前Linux系统的发行版本</p>
<p><img src="/2021/08/25/16-07-33/image-20210204112207818.png" alt="image-20210204112207818">-</p>
</li>
<li><p>time – 检测一个命令运行时间以及资源（CPU、内存、I/O等）使用情况</p>
<p><img src="/2021/08/25/16-07-33/image-20210319131633501.png" alt="image-20210319131633501">-</p>
</li>
<li><p>lsof – 列出进程打开或使用的文件信息</p>
</li>
</ol>
<p>   lsof 所在路径：/usr/sbin/lsof</p>
<p>   <img src="/2021/08/25/16-07-33/image-20210204120228451.png" alt="image-20210204120228451"></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c 字符串</td>
<td align="center">只列出以字符串开头的进程打开的文件</td>
</tr>
<tr>
<td align="center">-u 用户名</td>
<td align="center">只列出某个用户的进程打开的文件</td>
</tr>
<tr>
<td align="center">-p PID</td>
<td align="center">列出某个PID进程打开的文件</td>
</tr>
</tbody></table>
<p>   <img src="/2021/08/25/16-07-33/image-20210204120531386.png" alt="image-20210204120531386"></p>
<p>   <img src="/2021/08/25/16-07-33/image-20210204120459444.png" alt="image-20210204120459444">-</p>
   <!--因为在sbin下，所有只能由管理员运行此命令-->

<h3 id="10-4-系统定时任务"><a href="#10-4-系统定时任务" class="headerlink" title="10.4 系统定时任务"></a>10.4 系统定时任务</h3><h4 id="10-4-1-crontab"><a href="#10-4-1-crontab" class="headerlink" title="10.4.1 crontab"></a>10.4.1 crontab</h4><p><img src="/2021/08/25/16-07-33/image-20210204130009022.png" alt="image-20210204130009022">-</p>
<p>​    <strong>crontab 进行定时任务的设置</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e</td>
<td align="center">编辑crontab定时任务</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">查询crontab任务</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">删除当前用户的所有crontab任务</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">范围</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一个*</td>
<td align="center">0-59</td>
<td align="center">第几分钟</td>
</tr>
<tr>
<td align="center">第二个*</td>
<td align="center">0-23</td>
<td align="center">第几小时</td>
</tr>
<tr>
<td align="center">第三个*</td>
<td align="center">1-31</td>
<td align="center">第几天</td>
</tr>
<tr>
<td align="center">第四个*</td>
<td align="center">1-12</td>
<td align="center">第几月</td>
</tr>
<tr>
<td align="center">第五个*</td>
<td align="center">0-7（0、7都代表星期日）</td>
<td align="center">星期几</td>
</tr>
</tbody></table>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204130321382.png" alt="image-20210204130321382">-</p>
<p>​    操作步骤：</p>
<p>​    <strong>格式：时间 操作</strong></p>
<p>​    1、先使用 <code>crontab -e</code> 写一个任务例如：“<code>*/1 * * * * ls -alh /etc/ &gt; /tmp/test_crontab.txt</code>”，然后保存，就会自动执行</p>
<p>​    <!--注意：上面的 ”/“ 表示每隔n单位时间, 如*/10 每隔10分钟，也要看放的位置，如果放到**小时**那，就是每隔10小时--></p>
<p>​    2、查看文件内容 <code>head /tmp/test_crontab.txt</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210204131219235.png" alt="image-20210204131219235">-</p>
<p>​    <!--把/tmp/test_crontab.txt文件删了过一分钟还是会自动创建，如果文件存在则会覆盖里面的内容--></p>
<h4 id="10-4-2-at"><a href="#10-4-2-at" class="headerlink" title="10.4.2 at"></a>10.4.2 at</h4><p>​    <strong>crontab是一直执行，at是一次性的计划任务</strong></p>
<p>​    <strong>at的守护进程atd会以后台模式运行，检查作业队列来运行</strong></p>
<p>​    <strong>在使用at命令的时候，一定要保证atd进程的启动：<code>ps -ef | grep atd</code></strong></p>
<p>​    <strong>安装at命令：<code>yum install -y at</code></strong></p>
<p>​    <strong>启动atd进程：<code>systemctl start atd.service</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204141202667.png" alt="image-20210204141202667">-</p>
<p>​    <strong>执行at命令：2天后的下午5点执行：<code>ls  /home</code>, 两次ctrl + d 结束</strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204141831827.png" alt="image-20210204141831827">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204142053213.png" alt="image-20210204142053213">-</p>
<p>​    <strong>查看系统中待执行的job（工作任务）：<code>atq</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204142226537.png" alt="image-20210204142226537">-</p>
<p>​    <strong>删除已经设置好的任务：<code>atrm 编号</code></strong></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210204142438821.png" alt="image-20210204142438821">-</p>
<h3 id="10-5-系统加固"><a href="#10-5-系统加固" class="headerlink" title="10.5 系统加固"></a>10.5 系统加固</h3><p>10.5.1 用户账号和环境</p>
<p>10.5.2 系统访问认证和授权</p>
<p>10.5.3 核心调整</p>
<p>10.5.4 需要关闭的一些服务</p>
<p>10.5.5 SSH安全配置</p>
<p>10.5.6 封堵 openssl 的 Hearbleed 漏洞</p>
<p>10.5.7 开启防火墙策略</p>
<p>10.5.8 启动系统审计服务</p>
<p>10.5.9 部署完整性检查工具软件</p>
<p>10.5.10 部署系统监控环境</p>
<h2 id="第十一章-日志管理篇"><a href="#第十一章-日志管理篇" class="headerlink" title="第十一章 日志管理篇"></a>第十一章 日志管理篇</h2><p>​    Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。Centos7的日志守护进程为<strong>rsyslog</strong>，默认配置文件为 <strong>/etc/rsyslog.conf</strong>，任何希望生成日志的程序都可以向 syslog 发送信息。</p>
<p>​    Linux系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息，这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。完成这个过程的程序就是syslog。syslog可以根据日志的类别和优先级将日志保存到不同的文件中。例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。默认配置下，日志文件通常都保存在“/var/log”目录下.</p>
<h3 id="11-1-日志管理简介"><a href="#11-1-日志管理简介" class="headerlink" title="11.1 日志管理简介"></a>11.1 日志管理简介</h3><p>日志服务：rsyslogd</p>
<p><strong>rsyslogd的新特点：</strong></p>
<ol>
<li>基于TCP网络协议传输日志信息；</li>
<li>更安全的网络传输方式；</li>
<li>有日志消息的及时分析框架；</li>
<li>后台数据库；</li>
<li>配置文件中可以写简单的判断逻辑；</li>
<li>与syslog配置文件相兼容；</li>
</ol>
<p><strong>查看服务是否启动：<code>ps -aux | grep rsyslogd</code></strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210204153332686.png" alt="image-20210204153332686">-</p>
<p><strong>过滤下面这条信息：<code>ps -aux | grep rsyslogd | grep -v grep</code></strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210204171109336.png" alt="image-20210204171109336">-</p>
<!--"-v 反向匹配；从两条结果中挑选不包括grep的那一条"-->

<p><del>查看服务是否自启动：chkconfig –list | grep rsyslog</del></p>
<p><strong>查看服务是否自启动：<code>systemctl list-unit-files | grep rsyslog</code></strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210204170233175.png" alt="image-20210204170233175">-</p>
<table>
<thead>
<tr>
<th align="center">日志文件</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>/var/log/boot.log</strong></td>
<td align="center">系统启动日志</td>
</tr>
<tr>
<td align="center"><strong>/var/log/cron</strong></td>
<td align="center">记录了系统定时任务相关的日志</td>
</tr>
<tr>
<td align="center">/var/log/cups</td>
<td align="center">记录了打印信息的日志</td>
</tr>
<tr>
<td align="center">/var/log/dmesg</td>
<td align="center">记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td align="center">/var/log/btmp</td>
<td align="center">记录<strong>错误登录</strong>的日志。这个文件时二进制文件，不能直接使用vimj查看，需要使用<strong>lastb</strong>命令查看，方法：直接终端输入<strong>lastb</strong></td>
</tr>
<tr>
<td align="center"><strong>/var/log/lastlog</strong></td>
<td align="center">记录系统中所有用户最后一次的登陆时间的日志。这个文件也是二进制文件，不能直接用vim查看，需要使用<strong>lastlog</strong>命令查看，方法跟上面一样</td>
</tr>
<tr>
<td align="center"><strong>/var/log/maillog</strong></td>
<td align="center">记录邮件信息</td>
</tr>
<tr>
<td align="center"><strong>/var/log/message</strong></td>
<td align="center">包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。**<u>如果系统出现问题，首先检查的就应该时这个日志文件</u>**</td>
</tr>
<tr>
<td align="center">/var/log/wtmp</td>
<td align="center">包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。</td>
</tr>
<tr>
<td align="center"><strong>/var/log/secure</strong></td>
<td align="center">包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。</td>
</tr>
<tr>
<td align="center"><strong>/var/log/utmp</strong></td>
<td align="center">记录当前已经登录的用户的信息，这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息，不能直接用vim查看，需要使用<strong>lastlog</strong>命令查看，方法跟上面一样</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210204154428054.png" alt="image-20210204154428054">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204154450657.png" alt="image-20210204154450657">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319140125351.png" alt="image-20210319140125351">-</p>
<p>​    采用<strong>RPM</strong>方式安装的系统服务也会默认把日志记录在 /var/log/目录中（源码包安装的服务日志是在源码包指定目录中）。不过**<u>这些日志不是由rsyslogd服务来记录和管理的</u>**，而是各个服务使用自己的日志管理文档来记录自身日志。</p>
<table>
<thead>
<tr>
<th align="center">日志文件</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/var/log/httpd/</td>
<td align="center">RPM包安装的apache服务的默认日志目录</td>
</tr>
<tr>
<td align="center">/var/log/mail/</td>
<td align="center">RPM包安装的邮件服务的额外日志目录</td>
</tr>
<tr>
<td align="center">/var/log/samba/</td>
<td align="center">RPM包安装的samba服务的日志目录</td>
</tr>
<tr>
<td align="center">/var/log/sssd/</td>
<td align="center">守护进程安全服务目录</td>
</tr>
</tbody></table>
<h3 id="11-2-rsyslogd-日志服务"><a href="#11-2-rsyslogd-日志服务" class="headerlink" title="11.2 rsyslogd 日志服务"></a>11.2 rsyslogd 日志服务</h3><ol>
<li><p>日志文件格式</p>
<p>基本日志格式包括以下4个：</p>
<p>​    1、事件产生的<strong>时间</strong>；</p>
<p>​    2、发生事件的服务器的<strong>主机名</strong>；</p>
<p>​    3、产生事件的<strong>服务名或程序名</strong>；</p>
<p>​    4、事件的<strong>具体信息</strong>； </p>
<p><img src="/2021/08/25/16-07-33/image-20210204175838158.png" alt="image-20210204175838158">-</p>
<table>
<thead>
<tr>
<th align="center">信息</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Feb 1 19:30:10</td>
<td align="center">事件产生的<strong>时间</strong></td>
</tr>
<tr>
<td align="center">localhost</td>
<td align="center">发生事件的服务器的<strong>主机名</strong></td>
</tr>
<tr>
<td align="center">sshd</td>
<td align="center">产生事件的<strong>服务名或程序名</strong></td>
</tr>
<tr>
<td align="center">Server listening on 0.0.0.0 port 22.</td>
<td align="center">事件的<strong>具体信息</strong></td>
</tr>
</tbody></table>
<p>编辑文件时的格式为：<img src="/2021/08/25/16-07-33/image-20210204173312723.png" alt="image-20210204173312723"> 存放日志文件</p>
<p>第一个*表示日志类型，第二个表示日志级别</p>
<p>1 、日志类型分为：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auth</td>
<td align="center">pam产生的日志</td>
</tr>
<tr>
<td align="center">authpriv</td>
<td align="center">ssh、ftp等登录信息的验证信息</td>
</tr>
<tr>
<td align="center">corn</td>
<td align="center">事件任务相关</td>
</tr>
<tr>
<td align="center">kern</td>
<td align="center">内核</td>
</tr>
<tr>
<td align="center">lpr</td>
<td align="center">打印</td>
</tr>
<tr>
<td align="center">mail</td>
<td align="center">邮件</td>
</tr>
<tr>
<td align="center">mark(syslog) - rsyslog</td>
<td align="center">服务内部的信息，时间标识</td>
</tr>
<tr>
<td align="center">news</td>
<td align="center">新闻组</td>
</tr>
<tr>
<td align="center">user</td>
<td align="center">用户程序产生的相关信息</td>
</tr>
<tr>
<td align="center">uucp</td>
<td align="center">unix to nuix copy主机之间相关的通信</td>
</tr>
<tr>
<td align="center">local 1-7</td>
<td align="center">自定义的日志设备</td>
</tr>
</tbody></table>
<p>2、日志级别分为：</p>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">debug</td>
<td align="center">有调试信息的，日志通信最多</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">一般信息日志，最常用</td>
</tr>
<tr>
<td align="center">notice</td>
<td align="center">最具有重要性的普遍条件的信息</td>
</tr>
<tr>
<td align="center">warning</td>
<td align="center">警告级别</td>
</tr>
<tr>
<td align="center">err</td>
<td align="center">错误级别，阻止某个功能或模块不能正常工作的信息</td>
</tr>
<tr>
<td align="center">crit</td>
<td align="center">严重级别，阻止整个系统或整个软件不能正常工作的信息</td>
</tr>
<tr>
<td align="center">alert</td>
<td align="center">需要立即修改的信息</td>
</tr>
<tr>
<td align="center">emerg</td>
<td align="center">内核崩溃等重要信息</td>
</tr>
<tr>
<td align="center">none</td>
<td align="center">什么都不记录</td>
</tr>
</tbody></table>
<!--注意：从上到下，级别从低到高，记录信息越来越少--></li>
<li><p><strong>/etc/rsyslog.conf 配置文件</strong></p>
<p>上面<strong>第一个表格</strong>中的那些日志文件全是由rsyslogd产生的，详情可以看这个配置文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210204170654864.png" alt="image-20210204170654864">-</p>
<p>说明：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319140705939.png" alt="image-20210319140705939">-</p>
<p>这种时将日志输出到文件，除了这种还有将消息发送给用户，也就是把这里变为<strong>用户名</strong>。还有就是通过管道符号发送给<strong>用户程序</strong>，程序放到管道符后面。还有就是将消息发送给<strong>其他主机</strong>上的syslog程序，格式就是@加上主机名，之后再去<strong>接受端修改/etc/sysconfig/rsyslog文件</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210319141104769.png" alt="image-20210319141104769">-</p>
<p>SYSLOGD_OPTIONS=”-r -x -m 0”</p>
<p>-r表示允许接收外来的消息，-x表示不解析DNS,-m 0表示时间戳标记间隔,</p>
<p>如果指定只接受某个或多个ip过来的日志，修改如下</p>
<p>SYSLOGD_OPTIONS=”-s 168.1.1.1:168.1.1.2”</p>
<p>最后防火墙打开514/udp端口，setenforce 0，重启 rsyslog 即可</p>
</li>
<li><p>自定义日志文件</p>
<p>在 /etc/rsyslog.conf 中添加一个日志文件 /var/log/test_logvim .log ,当有事件发送时（比如sshd服务相关事件），该文件会接收到信息并保存</p>
<p><img src="/2021/08/25/16-07-33/image-20210204180931069.png" alt="image-20210204180931069">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204180954785.png" alt="image-20210204180954785">-</p>
</li>
</ol>
<h3 id="11-3-日志轮替"><a href="#11-3-日志轮替" class="headerlink" title="11.3 日志轮替"></a>11.3 日志轮替</h3><p>​    日志轮替就是把旧的日志文件移动并改名，同时建立新的空白日志文件，当旧日志文件超出保存的范围之后，就会进行删除操作</p>
<p>​    1. 日志的命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CentOS使用logrotate进行（全局）日志轮替管理，当然也可以单独给某个日志文件指定策略，想要改变日志轮替文件名字，通过 /etc/logrotate.conf 配置文件中 “dateext” 参数；</span><br><span class="line"></span><br><span class="line">​	如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如：“secure-20210204”。这样的日志文件不会重叠，不需要改名，只需要指定保存日志个数，删除多余的日志文件即可。</span><br><span class="line"></span><br><span class="line">​	如果配置文件中没有“dateext”参数，日志文件就需要进行改名，当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210204190453346.png" alt="image-20210204190453346">-</p>
<p>解释：</p>
<p>rotate log files weekly – 每周对日志文件进行一次轮替</p>
<p>keep 4 weeks worth of backlogs – 共保留4份日志我呢见，当建立新的日志文件时，旧的就会被删除</p>
<p>create new (empty) log files after rotating old ones – 创建新的空的日志文件，在日志轮替之后</p>
<p>use date as a suffix of the rotated file – 使用日期作为日志轮替文件的后缀</p>
<p>uncomment this if you want your log files compressed – 日志文件是否被压缩，如果取消注释，则日志文件会在存储的同时进行压缩</p>
<p>RPM packages drop log rotation information into this directory – 包含 /etc/logrotate.d 目录中的所有子配置文件，也就是说会把这个目录中所有子配置文件读取出来</p>
<p><strong>logrotate配置文件：</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">daily</td>
<td align="center">日志的轮替周期是每天</td>
</tr>
<tr>
<td align="center">weekly</td>
<td align="center">日志的轮替周期是每周</td>
</tr>
<tr>
<td align="center">monthly</td>
<td align="center">日志的轮替周期是每月</td>
</tr>
<tr>
<td align="center">rotate 数字</td>
<td align="center">保留日志文件的个数，0指没有备份</td>
</tr>
<tr>
<td align="center">compress</td>
<td align="center">日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td align="center">create mode owner group</td>
<td align="center">建立新的日志，同时指定新日志的权限与所有者和所属组</td>
</tr>
<tr>
<td align="center">mail address</td>
<td align="center">当日志轮替时，输出内容通过邮件发送到指定的邮件地址</td>
</tr>
<tr>
<td align="center">missingok</td>
<td align="center">如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td align="center">notifempty</td>
<td align="center">如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td align="center">minsize 大小</td>
<td align="center">日志轮替的最小值。也就是达到这个值才会轮替，否则就算时间达到也不轮替</td>
</tr>
<tr>
<td align="center">size 大小</td>
<td align="center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td>
</tr>
<tr>
<td align="center">dateext</td>
<td align="center">使用日期作为日志轮替文件的后缀</td>
</tr>
<tr>
<td align="center">sharedscripts</td>
<td align="center">在此关键字之后的脚本只执行一次</td>
</tr>
<tr>
<td align="center">prerotate/endscript</td>
<td align="center">在日志轮替之前执行的脚本命令</td>
</tr>
<tr>
<td align="center">postrotate/endscript</td>
<td align="center">在日志轮替之后执行的脚本命令</td>
</tr>
</tbody></table>
<p>自定义日志轮替：</p>
<ol>
<li><p>直接在 /etc/logrotate.conf 中写入该日志的轮替策略</p>
</li>
<li><p>在 <strong>/etc/logrotate.d/</strong> 目录中新建该日志的轮替文件，在该轮替文件中写入策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志假如轮替（<strong>推荐方法</strong>）</p>
<p><img src="/2021/08/25/16-07-33/image-20210204193457467.png" alt="image-20210204193457467">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210204193824839.png" alt="image-20210204193824839">-</p>
<p>下面演示把<strong>Nginx</strong>的访问日志加入日志轮替：</p>
<p>这里采用第二种方法，在**/etc/logrotate.d/** 目录中新建nginxlog文件，然后往里面写入策略：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310124513716.png" alt="image-20210310124513716">-</p>
<p>然而发现运行失败，一看错误日志才发现，尼玛原先已经有了一个：</p>
<p><img src="/2021/08/25/16-07-33/image-20210310133638168.png" alt="image-20210310133638168">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210310133703221.png" alt="image-20210310133703221">-</p>
<p>然后修改一下系统日期，再进入到 <strong>/etc/cron.daily</strong> 目录，执行 <strong>logrotate</strong>，即可查看到备份的文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210310133526591.png" alt="image-20210310133526591">-</p>
</li>
</ol>
<h3 id="11-4-查看内存日志"><a href="#11-4-查看内存日志" class="headerlink" title="11.4 查看内存日志"></a>11.4 查看内存日志</h3><p>​    journalctl 查看<strong>内存日志</strong>，重启后清空。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">journalctl</td>
<td align="center">查看全部</td>
</tr>
<tr>
<td align="center">journalctl  -n 3</td>
<td align="center">查看最新3条</td>
</tr>
<tr>
<td align="center">journalctl  –since 19:00 –until 19:10:10</td>
<td align="center">查看起止时间内的日志，可加日期</td>
</tr>
<tr>
<td align="center">journalctl  -p err</td>
<td align="center">报错日志</td>
</tr>
<tr>
<td align="center">journalctl  -o verbose</td>
<td align="center">日志详细内容</td>
</tr>
<tr>
<td align="center">journalctl _PID=1234 _COMM=sshd 或者 journalctl | grep sshd</td>
<td align="center">查看包含这些参数的日志</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210204194908128.png" alt="image-20210204194908128">-</p>
<h3 id="11-5-logger命令"><a href="#11-5-logger命令" class="headerlink" title="11.5 logger命令"></a>11.5 logger命令</h3><p>通过logger命令使用 syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入一行信息</p>
<p>logger命令的语法为：<strong>logger [-i] [-f filename] [-p priority] [-t tag] [message…]</strong></p>
<table>
<thead>
<tr>
<th><strong>选 项</strong></th>
<th><strong>说 明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-f filename</td>
<td>将 filename 文件的内容作为日志。</td>
</tr>
<tr>
<td>-i</td>
<td>每行都记录 logger 进程的ID。</td>
</tr>
<tr>
<td>-p priority</td>
<td>指定优先级；优先级必须是形如 facility.priority 的完整的选择器，默认优先级为 user.notice。</td>
</tr>
<tr>
<td>-t tag</td>
<td>使用指定的标签标记每一个记录行。</td>
</tr>
<tr>
<td>message</td>
<td>要写入的日志内容，多条日志以空格为分隔；如果没有指定日志内容，并且  -f filename 选项为空，那么会把标准输入作为日志内容。</td>
</tr>
</tbody></table>
<p>例如，将ping命令的结果写入日志：ping localhost | logger -it logger_test local3.notice&amp;</p>
<p>命令解释：-i 在每行都记录进程的ID号，-t logger_test 每行记录都加上 “logger_test” 这个标签，-p local3.notice 设置日志类型和优先级</p>
<p><img src="/2021/08/25/16-07-33/image-20210319144243925.png" alt="image-20210319144243925">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319144255340.png" alt="image-20210319144255340">-</p>
<!--注意，最后的&不能少-->

<p>然后通过 tail -f 查看实时日志数据的跟新：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319144412418.png" alt="image-20210319144412418">-</p>
<!--注意，刚刚使用logger输出的日志文件是messages!-->

<h3 id="11-5-搭建日志服务器"><a href="#11-5-搭建日志服务器" class="headerlink" title="11.5 搭建日志服务器"></a>11.5 搭建日志服务器</h3><p>部署 rsyslog + LogAnalyzer + MySQL中央日志服务器</p>
<p>1、客户端配置：<code>vim /etc/rsyslog.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none                @IP地址</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210319201240388.png" alt="image-20210319201240388">-</p>
<p>然后重启rsyslog服务</p>
<p>2、服务端配置：<code>vim /etc/rsyslog.conf</code></p>
<p>因为rsyslog默认是不接受其他主机传来的日志信息。</p>
<p>所以需要编辑配置文件加载TCP、UDP模块，并且监听端口，就可以接收其他主机传来的日志信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210319155159957.png" alt="image-20210319155159957">-</p>
<p>rsyslog默认将日志文件存储在本地，需要通过配置文件将其修改为<strong>存储在MySQL数据库中</strong></p>
<p>不过这需要<strong>模块</strong>支持，需要先安装 rsyslog-mysql 软件包：<code>yum install -y rsyslog-mysql</code></p>
<p>安装完成以后使用<code>rpm -ql rsyslog-mysql</code>看一下生成2个文件，一个是模块、一个是初始化数据库的SQL语句</p>
<p>只要编辑配置文件将模块加载，然后将sql语句导入至MySQL数据库服务器中即可。</p>
<p>在数据库中创建的用户要与rsyslog.conf的一致</p>
<p><img src="/2021/08/25/16-07-33/image-20210319155715828.png" alt="image-20210319155715828">-</p>
<p>3、配置数据库</p>
<p>安装mariaDB：<code>yum install -y mariadb</code></p>
<p>然后初始化数据库：<code>mysql  -uroot  -p123  &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319160233573.png" alt="image-20210319160233573">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319160304155.png" alt="image-20210319160304155">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319160411324.png" alt="image-20210319160411324">-</p>
<p>然后授权用户（给Syslog创建用户和密码）：</p>
<p><code>grant all on Syslog.* to &#39;chen&#39;@&#39;localhost.%&#39; identified by &#39;123&#39;;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319162017322.png" alt="image-20210319162017322">-</p>
<p>5、然后去官网下载LogAnalyzer, <a href="https://loganalyzer.adiscon.com/downloads/">https://loganalyzer.adiscon.com/downloads/</a></p>
<p>下载完后，直接解压：<code>tart -zxvf .......</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319162321929.png" alt="image-20210319162321929">-</p>
<p>解压完成以后，去下载<strong>httpd</strong>，然后将LogAnalyzer中的src文件复制到/var/www/html/loganalyzer 即可</p>
<p><code>cp -a loganalyzer-4.1.10/src/ /var/www/html/loganalyzer</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319162820712.png" alt="image-20210319162820712">-</p>
<p>6、浏览器打开 LogAnalyzer 并进行配置：<code>http://IP地址/loganalyzer</code></p>
<p>记得关闭selinux和防火墙</p>
<p><img src="/2021/08/25/16-07-33/image-20210319163227795.png" alt="image-20210319163227795">-</p>
<p>然后就报错了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319164021832.png" alt="image-20210319164021832"></p>
<p>这个文件需要手动创建：<code>touch /var/www/html/loganalyzer/config.php</code></p>
<p>然后按照上面的红色字体的提示，赋予权限为 666：<code>chmod 666 /var/www/html/loganalyzer/config.php</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210319164135745.png" alt="image-20210319164135745">-</p>
<p>再次刷新网页就正常了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319164200658.png" alt="image-20210319164200658">-</p>
<p>这一步：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319164423092.png" alt="image-20210319164423092">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210319164443308.png" alt="image-20210319164443308">-</p>
<p>最后还是错了，这就需要把刚刚那个config文件删了重新touch一个：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319164635653.png" alt="image-20210319164635653">-</p>
<p>错误原因竟是，最先忘了配置下面这个：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319211814621.png" alt="image-20210319211814621">-</p>
<p>然后就可以成功访问了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210319212112155.png" alt="image-20210319212112155"></p>
<h2 id="第十二章-备份与恢复篇"><a href="#第十二章-备份与恢复篇" class="headerlink" title="第十二章 备份与恢复篇"></a>第十二章 备份与恢复篇</h2><h3 id="12-1-备份"><a href="#12-1-备份" class="headerlink" title="12.1 备份"></a>12.1 备份</h3><p>Linux的备份和恢复有两种方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 把需要备份的文件或者分区用 tar 打包就行，下次需要恢复的时候，再解压覆盖即可；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 使用 dump 和 restore 命令；</span></span><br></pre></td></tr></table></figure>

<p>安装dump命令：<code>yum install dump</code></p>
<p>dump支持分卷和<u>增量备份（差异备份，对比上次备份的文件，只备份修改过的文件）</u></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-c</strong></td>
<td align="center">创建新的归档文件</td>
</tr>
<tr>
<td align="center">-0123456789</td>
<td align="center">备份层级，0为最完整备份，会备份所有文件。0之上就是增量备份。到9后再轮替又从0开始</td>
</tr>
<tr>
<td align="center">-f 文件名</td>
<td align="center">指定备份后的文件名</td>
</tr>
<tr>
<td align="center">-j</td>
<td align="center"><strong>调用bzlib库来压缩文件</strong>，压缩成bz2格式</td>
</tr>
<tr>
<td align="center">-T 日期</td>
<td align="center">指定开始备份的时间与日期</td>
</tr>
<tr>
<td align="center"><strong>-u</strong></td>
<td align="center">备份完毕后，再/etc/dumpdares中记录备份的文件系统，层级，日期与时间等信息</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">指定文件名，若该文件已存在备份文件中，则列出名称</td>
</tr>
<tr>
<td align="center">-W</td>
<td align="center">显示需要备份的文件及其最后一次备份的层级，时间，日期</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">与-W类似，但仅显示需要备份的文件</td>
</tr>
</tbody></table>
<p>例子：将/boot分区中所有内容备份到/opt/boot.bak0.bz2文件中，备份层级为0</p>
<p>命令：<code>dump -0uj -f /opt/boot.bak0.bz2 /boot</code></p>
<p>结果报错了，显示：<strong>Bad magic number in super-block while opening filesystem</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210204203922375.png" alt="image-20210204203922375">-</p>
<p>使用<code>df -Th</code>查看分区的Type：</p>
<p><img src="/2021/08/25/16-07-33/image-20210204203958729.png" alt="image-20210204203958729">-</p>
<!--我们会发现分区是使用的默认分区xfs-->

<p>这种情况下 我们可以使用如下命令进行备份或者恢复：</p>
<p><code>xfsdump -0uj -f /opt/boot.bak0.bz2 /boot</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210204204258371.png" alt="image-20210204204258371">-</p>
<!--上图中指定设备标签，就是对要备份的设备做一个描述-->

<p><img src="/2021/08/25/16-07-33/image-20210204204455678.png" alt="image-20210204204455678">-</p>
<p>下面进行第一次增量备份：</p>
<p><code>dump -1uj -f /opt/boot.bak1.bz2 /boot</code></p>
<p><code>xfsdump -l 1 -uj -f /opt/boot.bak1.bz2 /boot</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210204205710651.png" alt="image-20210204205710651">-</p>
<!--第二次的增量备份大小 只有21k-->

<!--dump命令配合crontab可以实现无人值守备份-->

<p>前面备份的/boot分区是支持增量备份的，但还是有一些分区不支持，如/etc，只能使用0级备份并且参数 -u 也不支持了</p>
<p><img src="/2021/08/25/16-07-33/image-20210204211126079.png" alt="image-20210204211126079">-</p>
<h3 id="12-2-恢复"><a href="#12-2-恢复" class="headerlink" title="12.2 恢复"></a>12.2 恢复</h3><p>​    安装 restore 命令：<code>yum install restore</code></p>
<p>​    <!--注意使用xfsdump备份的文件需要使**xfsrestore**命令来进行恢复--></p>
<p>​    restore 语法：<code>restore [模式选项] [选项]</code></p>
<p>​    下面4个模式，不能混用，一次只能使用一个</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-C</td>
<td align="center">对比模式，将备份的文件与已存在的文件相互对比</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">交互模式，在进行还原操作时，restore指令将依序询问用户</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">还原模式</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">查看模式，查看备份文件有哪些文件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-f</td>
<td align="center">从指定的文件中读取备份数据，进行还原操作</td>
</tr>
</tbody></table>
<p><img src="/2021/08/25/16-07-33/image-20210205112933193.png" alt="image-20210205112933193">-</p>
<h2 id="第十三章-启动管理篇"><a href="#第十三章-启动管理篇" class="headerlink" title="第十三章 启动管理篇"></a>第十三章 启动管理篇</h2><h3 id="13-1-Linux的启动流程"><a href="#13-1-Linux的启动流程" class="headerlink" title="13.1 Linux的启动流程"></a>13.1 Linux的启动流程</h3><pre><code>1. 首先Linux要通过自检，检查硬件设备有没有故障
2. 如果有多块启动盘的话，需要在BIOS中选择启动磁盘
3. 启动MBR中的bootloader引导程序
4. 加载内核文件
5. 执行所有进程的父进程、老祖宗systemd
6. 欢迎界面
</code></pre>
<p>在Linux的启动流程中，加载内核文件时关键文件：</p>
<pre><code>1. kernel文件：vmlinuz-4.18.0-240.10.1.el8_3.x86_64
2. initrd文件：initramfs-4.18.0-240.10.1.el8_3.x86_64.img
</code></pre>
<p>这两个文件全在/boot中</p>
<p><img src="/2021/08/25/16-07-33/image-20210206111354470.png" alt="image-20210206111354470">-</p>
<h3 id="13-2-自定义Linux"><a href="#13-2-自定义Linux" class="headerlink" title="13.2 自定义Linux"></a>13.2 自定义Linux</h3><ol>
<li><p>先为现在的Linux添加一块大小为8个G的硬盘</p>
<p><img src="/2021/08/25/16-07-33/image-20210206161038755.png" alt="image-20210206161038755">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210206161111381.png" alt="image-20210206161111381">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210206161147033.png" alt="image-20210206161147033">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210206161432982.png" alt="image-20210206161432982">-</p>
<p>然后开机之后，通过<code>fdisk</code>对各个那个硬盘进行分区：</p>
<p>1、使用<code>lsblk</code>查看有哪些硬盘：</p>
<p><img src="/2021/08/25/16-07-33/image-20210206161744568.png" alt="image-20210206161744568">-</p>
<!--上面的sdb就是刚刚添加的那个硬盘-->

<ol start="2">
<li>使用<code>fdisk /dev/sdb</code>对其进行分区：</li>
</ol>
<p><img src="/2021/08/25/16-07-33/image-20210206162245372.png" alt="image-20210206162245372">-</p>
<!--作为/boot分区-->

<p><img src="/2021/08/25/16-07-33/image-20210206162340176.png" alt="image-20210206162340176">-</p>
<!--剩余的全部分给根分区-->

<p><img src="/2021/08/25/16-07-33/image-20210206162427433.png" alt="image-20210206162427433">-</p>
<!--w 是写入-->

<p><img src="/2021/08/25/16-07-33/image-20210206162515433.png" alt="image-20210206162515433">-</p>
<ol start="3">
<li>使用<code>mkfs.ext4 /dev/sdbn</code>命令进行格式化：</li>
</ol>
<p><img src="/2021/08/25/16-07-33/image-20210206162643756.png" alt="image-20210206162643756">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210206162723211.png" alt="image-20210206162723211">-</p>
<ol start="4">
<li>创建目录，并挂载新的磁盘：</li>
</ol>
<p>在现在的Linux系统下的mnt目录中，新建两个目录：boot和sysroot，boot作为mini系统的boot目录，sysroot作为mini系统的bin目录：<code>mkdir -p /mnt/boot /mnt/sysroot</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206163017252.png" alt="image-20210206163017252">-</p>
<p><code>mount /dev/sdb1 /mnt/boot</code> 将sdb1挂载到boot目录</p>
<p><code>mount /dev/sdb2 /mnt/sysroot</code> 将sdb2挂载到sysroot目录</p>
<p><img src="/2021/08/25/16-07-33/image-20210206163221823.png" alt="image-20210206163221823">-</p>
<ol start="5">
<li>挂载完成后安装grub，将内核文件拷贝到目标磁盘去：</li>
</ol>
<p><code>grub2-install --root-directory=/mnt /dev/sdb</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206164242158.png" alt="image-20210206164242158">-</p>
<!--注意/mnt和/dev/sdb之间是有空格的-->

<p>看一下二进制确认一下是否安装成功：</p>
<p><code>hexdump -C -n 512 /dev/sdb</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206164447228.png" alt="image-20210206164447228">-</p>
<!--512 和/dev/sdb之间也是有空格的-->

<!--结果是成功的！！-->

<ol start="6">
<li>下面将原系统boot目录下的内容全部cp到/mnt/boot中去：</li>
</ol>
<p><code>cp -rf /boot/* /mnt/boot/</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206164840030.png" alt="image-20210206164840030">-</p>
<!--先把/mnt/boot/中的内容删完：rm -rf /mnt/boot/*--></li>
<li><p><strong>修改grub2/gurb.cfg文件（核心步骤）</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210206165119622.png" alt="image-20210206165119622">-</p>
<p>使用 <code>lsblk -f</code> 查看UUID：</p>
<p><img src="/2021/08/25/16-07-33/image-20210206165402944.png" alt="image-20210206165402944">-</p>
<p>将cfg文件中对应的sda1的UUID改为sdb1的UUID：</p>
<p><img src="/2021/08/25/16-07-33/image-20210206184458915.png" alt="image-20210206184458915">-</p>
<!--这个位置失败了，目前没找到解决方法--></li>
<li><p>创建目标主机的根文件系统</p>
<p><code>mkdir -pv /mnt/sysroot/&#123;etc/rc.d, usr, var, proc, sys, dev, lib, lib64, bin, sbin, boot, srv, mnt, media, home, root&#125;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206185126766.png" alt="image-20210206185126766">-</p>
<!--注意：`etc/rc.d, usr, var, proc, sys, dev, lib, lib64, bin, sbin, boot, srv, mnt, media, home, root`逗号后面不能有空格！！！-->

<!--这些目录中，虽然有些不会用，但必须创建--></li>
<li><p>cp需要的bash和库文件给新系统使用</p>
<p><code>cp -r /lib64/*.* /mnt/sysroot/lib64/</code></p>
<!--"-r 递归复制"-->

<p><img src="/2021/08/25/16-07-33/image-20210206191138803.png" alt="image-20210206191138803">-</p>
<p><code>cp -r /bin/bash /mnt/sysroot/bin/</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206191242826.png" alt="image-20210206191242826">-</p>
</li>
<li><p>创建一个新的虚拟机，然后将默认分配的磁盘移除掉，指向刚刚创建的磁盘</p>
<p><img src="/2021/08/25/16-07-33/image-20210206191909318.png" alt="image-20210206191909318">-</p>
<p>然后添加硬盘：</p>
<p><img src="/2021/08/25/16-07-33/image-20210206191952928.png" alt="image-20210206191952928">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210206192116231.png" alt="image-20210206192116231">-</p>
</li>
</ol>
<h3 id="13-3-批量装机"><a href="#13-3-批量装机" class="headerlink" title="13.3 批量装机"></a>13.3 批量装机</h3><p>​    <strong>整个流程的简单说明</strong>：安装肯定得有系统镜像才行吧，然后还需要FTP和TFTP服务器用来传输文件，其中TFTP是用来传输小文件，不需要确认，所有这里用来传输内核、初始化镜像和pxe引导程序，而FTP就用来传输整个系统镜像，因为整个系统很大，几个G的文件，所有需要用FTP来保证传输不出错，安装镜像有几种方式，光盘、U盘、网络传输，这里选择的就是网络安装，所以需要配置DHCP服务，将需要安装系统的主机配置到同一个局域网中，这样就可以通过内网使用FTP传输文件了，又因为要使用FTP服务，所以还需要对主系统的防火墙和selinux进行配置，不然就无法传输。顺利进入到安装界面后，就需要选择一些语言、键盘等，所以还需要使用kickstart这个软件来生成对应的选项配置文件（ks.cfg），生成的这个文件就类似于anaconda-ks.cfg，为什么要用这个文件呢，因为当我们在选择完语言和键盘等选项之后，就会生成anaconda-ks.cfg这个配置文件，但是选择的过程是手动的，如果我们提前写好了这个文件，到时候直接加载，就不需要再手动地去选择了，在这个文件中还可以添加一些系统安装完成后需要运行的内容，比如安装完成系统之后再一键安装LNMP等，一键配置从系统安装到网站搭建，方便极了！但是为什么又分了pxe和cobbler呢，因为在一个局域网中，比如一个办公室，有人用Windows、有人用linux，服务器用Linux，所以不是每个人的操作系统都是一样的，但是pxe只能让全部人员用一个系统，这就很不方便，要实现不同人群的不同操作系统的要求，还需要分别对这些人气分批次进行，比如先对Linux用户、然后对Windows用户。但是有了cobbler就不一样了，不要在分批次，可以实现上面的要求</p>
<h4 id="13-3-1-使用pxe进行批量安装"><a href="#13-3-1-使用pxe进行批量安装" class="headerlink" title="13.3.1 使用pxe进行批量安装"></a>13.3.1 使用pxe进行批量安装</h4><p>​    <strong>PXE</strong>是由Intel公司开发的网络引导技术，工作在Client/Server模式，<strong>允许客户机通过网络从远程服务器下载引导镜像</strong>，并加载安装文件或者整个操作系统。若要搭建PXE网络体系，主机端必须满足以下条件：安装源（系统盘文件）、TFTP服务、FTP服务、DHCP服务、Linux内核、能够向客户机裸机发送PXE引导程序、启动菜单及无人应答文件等。客户端必须满足以下条件：客户端的网卡支持PXE协议，且主板支持网络引导（现在多数都支持）、设置BIOS允许从Network或LAN启动。</p>
<p>实操：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一键批量安装Linux系统脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># -------准备工作------------------</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 防火墙开启ftp、tftp、dhcp服务</span></span></span><br><span class="line">echo &quot;正在进行准备工作的设置！&quot;</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=tftp --add-service=dhcp --add-service=ftp &amp;&gt; /dev/null</span><br><span class="line">firewall-cmd --reload &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把 selinux 安全机制关了</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为镜像文件都在光盘里面，所以还需要挂载过来</span></span><br><span class="line">mkdir /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">mount /dev/sr0 /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 都挂载了，那顺便配置本地yum源吧</span></span><br><span class="line">cd /etc/yum.repos.d</span><br><span class="line">mkdir /etc/yum.repos.d/bak &amp;&gt; /dev/null</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">cat &lt;&lt; EOF &gt; dvd.repo</span><br><span class="line">[dvd]</span><br><span class="line">name=centos7</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 vsftp、dhcp、tftp、syslinux</span></span><br><span class="line">echo &quot;正在安装vsftp、dhcp、tftp、syslinux&quot;</span><br><span class="line">yum install -y vsftpd dhcp tftp-server syslinux  1&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果安装失败，则退出</span></span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line"> exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;准备工作结束！&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------准备工作结束------------------</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------配置TFTP------------</span></span><br><span class="line">echo &quot;开始配置TFTP&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 修改tftp的配置文件</span></span></span><br><span class="line">sed -i &#x27;14s/yes/no/g&#x27; /etc/xinetd.d/tftp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Linux内核、初始化镜像、pxe引导程序文件拷贝到 /var/lib/tftpboot/ 下</span></span><br><span class="line">cp /mnt/cdrom/images/pxeboot/vmlinuz /var/lib/tftpboot/</span><br><span class="line">cp /mnt/cdrom/images/pxeboot/initrd.img /var/lib/tftpboot/</span><br><span class="line">cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;TFTP配置完成！&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------配置pxe启动菜单------------</span></span><br><span class="line">echo &quot;配置pxe启动菜单！&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 获取一下本机IP地址</span></span></span><br><span class="line">IP_ADDR=`ip addr | grep inet | grep brd | awk &#x27;&#123;print $2&#125;&#x27; | awk -F/ &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取一下本机子网号</span></span><br><span class="line">SUB=`echo $IP_ADDR | cut -d . -f 1-3`</span><br><span class="line">SUBNET_ADDR=&quot;$&#123;SUB&#125;.0&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">mkdir /var/lib/tftpboot/pxelinux.cfg &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">cat &lt;&lt; <span class="string">EOF &gt; /var/lib/tftpboot/pxelinux.cfg/default</span></span></span><br><span class="line">default auto</span><br><span class="line">prompt 1</span><br><span class="line">label auto</span><br><span class="line">        kernel vmlinuz</span><br><span class="line">        append initrd=initrd.img method=ftp://$&#123;IP_ADDR&#125;/centos7 ks=ftp://$&#123;IP_ADDR&#125;/ks.cfg</span><br><span class="line">label linux text</span><br><span class="line">        kernel vmlinuz</span><br><span class="line">        append text initrd=initrd.img method=ftp://$&#123;IP_ADDR&#125;/centos7</span><br><span class="line">label linux rescue</span><br><span class="line">        kernel vmlinuz</span><br><span class="line">        append rescue initrd=initrd.img method=ftp://$&#123;IP_ADDR&#125;/centos7</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">echo &quot;pxe配置完成！&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------配置FTP------------</span></span></span><br><span class="line">echo &quot;开始配置FTP&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">mkdir /var/ftp/centos7 &amp;&gt; /dev/null</span></span></span><br><span class="line">echo &quot;正在copy系统文件，时间较长，请玩一会~&quot;</span><br><span class="line">cp -rf /mnt/cdrom/* /var/ftp/centos7/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 注意若不是第一次安装vsftpd，有可能没有允许匿名用户访问</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">echo &quot;FTP配置结束！&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------配置DHCP------------</span></span></span><br><span class="line">echo &quot;开始配置DHCP服务&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash"># 注意这里是追加写入，因为源文件里面还有注释，算了还是不追加了</span></span></span><br><span class="line">SUB_A=&quot;$&#123;SUB&#125;.0&quot;</span><br><span class="line">SUB_B=&quot;$&#123;SUB&#125;.1&quot;</span><br><span class="line">SUB_C=&quot;$&#123;SUB&#125;.50&quot;</span><br><span class="line">SUB_D=&quot;$&#123;SUB&#125;.254&quot;</span><br><span class="line">SUB_E=&quot;$&#123;SUB&#125;.255&quot;</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/dhcp/dhcpd.conf</span><br><span class="line">subnet $&#123;SUB_A&#125; netmask 255.255.255.0 &#123;</span><br><span class="line">  range $&#123;SUB_B&#125; $&#123;SUB_C&#125;;  </span><br><span class="line">  option domain-name-servers 8.8.8.8;</span><br><span class="line">  option routers $&#123;SUB_D&#125;;</span><br><span class="line">  option broadcast-address $&#123;SUB_E&#125;;</span><br><span class="line">  default-lease-time 21600;</span><br><span class="line">  max-lease-time 43200;</span><br><span class="line">  next-server $&#123;IP_ADDR&#125;;   #指定TFTP服务器的地址</span><br><span class="line">  filename &quot;pxelinux.0&quot;;     #指定PXE引导程序的文件名</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">echo &quot;DHCP服务配置结束！&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------配置ks.cfg文件------------</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 照着/root/anaconda-ks.cfg文件重新</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 或者安装一个kckstart来点击创建一个配置文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> yum install -y system-config-kickstart</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 这里选择安装，然后生成一个配置文件</span></span></span><br><span class="line">echo &quot;开始配置ks.cfg文件&quot;</span><br><span class="line">cat &lt;&lt; EOF &gt; /var/ftp/ks.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">platform=x86, AMD64, 或 Intel EM64T</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">version=DEVEL</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Install OS instead of upgrade</span></span></span><br><span class="line">install</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Keyboard layouts</span></span></span><br><span class="line">keyboard &#x27;us&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Root password = 123</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 密码可能有问题，装好了系统之后，可能还需要修改密码</span></span></span><br><span class="line">rootpw --iscrypted $1$4vl7X/nX$aqoCeN9ZX4Hcr1pfSXvUk.</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> System language</span></span></span><br><span class="line">lang zh_CN</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> System authorization information</span></span></span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Use text install</span></span></span><br><span class="line">text</span><br><span class="line">firstboot --disable</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> SELinux configuration</span></span></span><br><span class="line">selinux --disabled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Firewall configuration</span></span></span><br><span class="line">firewall --disabled</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Network information</span></span></span><br><span class="line">network  --bootproto=dhcp --device=ens32</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Halt after installation</span></span></span><br><span class="line">halt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> System timezone</span></span></span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Use network installation</span></span></span><br><span class="line">url --url=&quot;ftp://$&#123;IP_ADDR&#125;/centos7&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> System bootloader configuration</span></span></span><br><span class="line">bootloader --location=mbr</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Partition clearing information</span></span></span><br><span class="line">clearpart --all</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Disk partitioning information</span></span></span><br><span class="line">part / --fstype=&quot;xfs&quot; --size=10240</span><br><span class="line">part /boot --fstype=&quot;xfs&quot; --size=500</span><br><span class="line">part /home --fstype=&quot;xfs&quot; --size=4096</span><br><span class="line">part swap --fstype=&quot;swap&quot; --size=4096</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 这里放安装后脚本</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 这里可以调用一键部署LMNP之类的脚本</span></span></span><br><span class="line"><span class="meta">%</span><span class="bash"><span class="string">post --interpreter=#!/bin/bash</span></span></span><br><span class="line">mkdir chenhaha</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line"><span class="meta">%</span><span class="bash"><span class="string">end</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash"><span class="string">packages</span></span></span><br><span class="line">@development</span><br><span class="line">@fonts</span><br><span class="line">@ftp-server</span><br><span class="line">@gnome-apps</span><br><span class="line">@gnome-desktop</span><br><span class="line">@input-methods</span><br><span class="line">@mariadb</span><br><span class="line">@mariadb-client</span><br><span class="line">@php</span><br><span class="line">@platform-devel</span><br><span class="line">@python-web</span><br><span class="line">@remote-desktop-clients</span><br><span class="line">@web-servlet</span><br><span class="line">vinagre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash"><span class="string">end</span></span></span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">echo &quot;ks.cfg 配置结束&quot;</span></span></span><br><span class="line">echo &quot;全部配置结束！&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------配置结束------------</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------启动服务------------</span></span></span><br><span class="line">echo &quot;开始启动服务&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">systemctl start vsftpd tftp dhcpd</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">echo &quot;服务启动结束&quot;</span></span></span><br><span class="line">echo &quot;脚本执行结束！&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> --------脚本结束------------</span></span></span><br></pre></td></tr></table></figure>

 <!--安装失败有可能是虚拟机分配的硬盘和内存大小不够造成的-->

<!--注意：不能直接复制文件到Linux里面，会出现格式错误（出现不明\r），应该直接手动复制代码-->

<p>搭建好PXE远程安装服务器以后，就可以使用客户机进行安装测试了。</p>
<p>对于新购买的服务器或PC裸机，一般不需要额外设置；</p>
<p>若要为已有系统的主机重装系统，则可能需要修改BIOS设置，<strong>将“Boot first”设置为“NETWOR”</strong>，然后重启主机。</p>
<p>如果服务器配置正确，网络连接、PXE支持等都没有问题，则客户机重启后将自动配置IP地址，然后从TFTP服务器中获取引导程序pxelinux.0,并根据引导菜单配置提示用户启动入口，如下所示：</p>
<p>   <img src="/2021/08/25/16-07-33/clip_image002.jpg" alt="img"></p>
<p>在提示字符串boot:后**直接按Enter键（或执行“auto”命令)**，将会进入图形安装入口；若执行“linux text”命令则进入文本安装入口；若执行“linux rescue”命令则进入救援模式。依次选择语言、键盘类型，然后会提示用户指定安装介质。</p>
<h4 id="13-3-2-使用cobbler进行批量安装"><a href="#13-3-2-使用cobbler进行批量安装" class="headerlink" title="13.3.2 使用cobbler进行批量安装"></a>13.3.2 使用cobbler进行批量安装</h4><p>cobbler 是对pxe的封装，所以底层还是pxe，但是cobbler实现了许多pxe没有的功能，比如安装不同的系统等</p>
<p>实操过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一键部署 cobbler 脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;正在进行防火墙设置！&quot;</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置iptables</span> </span><br><span class="line">yum install -y iptables-services &amp;&gt; /dev/null</span><br><span class="line">systemctl start iptables</span><br><span class="line">systemctl enable iptables</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 443 是因为 cobbler web 需要用 https方面</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 69 是 TFTP</span></span><br><span class="line">iptables -I INPUT -p udp --dport 69 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 25151 -j ACCEPT</span><br><span class="line">service iptables save</span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把 selinux 安全机制关了</span></span><br><span class="line">setenforce 0</span><br><span class="line">echo  -e &quot;\033[32m 防火墙设置完成！ \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;正在进行yum源的配置&quot;</span><br><span class="line">mkdir /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">mkdir /etc/yum.repos.d/bak &amp;&gt; /dev/null</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">mount /dev/sr0 /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/dvd.repo</span><br><span class="line">[development]</span><br><span class="line">name=centos7</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enable=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[epel]</span><br><span class="line">name=epel</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">baseurl=https://mirrors.aliyun.com/epel/7/x86_64/</span><br><span class="line"></span><br><span class="line">[centos]</span><br><span class="line">name=centos base</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/os/x86_64/</span><br><span class="line">EOF</span><br><span class="line">echo  -e &quot;\033[32m yum源配置完成！ \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;正在安装所需软件&quot;</span><br><span class="line">yum install -y cobbler cobbler-web dhcp tftp-server xinetd syslinux httpd pykickstart fence-agents net-tools &amp;&gt; /dev/null</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line">  echo -e &quot;\033[31m 下载失败！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line">echo  -e &quot;\033[32m 软件安装完成！ \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;正在启动相关服务&quot;</span><br><span class="line">systemctl start cobblerd httpd tftp xinetd rsyncd dhcpd</span><br><span class="line">if [ ! $? ]</span><br><span class="line">then</span><br><span class="line">  echo -e &quot;\033[31m 启动失败！ \033[0m&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line">systemctl enable cobblerd httpd tftp xinetd rsyncd dhcpd</span><br><span class="line">echo  -e &quot;\033[32m 服务启动完成 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;查看cobbler存在的错误！&quot;</span><br><span class="line">echo &quot;------------------------------------&quot;</span><br><span class="line">cobbler check</span><br><span class="line">echo &quot;------------------------------------&quot;</span><br><span class="line">echo &quot;配置静态IP&quot;</span><br><span class="line">ENS=`ip maddr | grep ens | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">OLD_IP_ADDR=`ifconfig | grep inet | awk &#x27;NR==1 &#123;print $2&#125;&#x27;`</span><br><span class="line">IP_CONF=/etc/sysconfig/network-scripts/ifcfg-$&#123;ENS&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除UUID，并配置静态IP地址</span></span><br><span class="line">sed -i &#x27;/^UUID/d&#x27; $&#123;IP_CONF&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改BOOTPROTO为static</span></span><br><span class="line">sed -i &#x27;/^BOOTPROTO/s/dhcp/static/g&#x27; $&#123;IP_CONF&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加静态IP地址、网关、子网掩码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 静态IP地址用 ‘date +%S’来获取，date +%S 是秒，一共60秒</span></span><br><span class="line">IP_4=`date +%S`</span><br><span class="line">cat &lt;&lt; EOF &gt;&gt; $&#123;IP_CONF&#125;</span><br><span class="line">IPADDR=$&#123;OLD_IP_ADDR%.*&#125;.$&#123;IP_4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 44 看具体而定</span></span><br><span class="line">GATEWAY=$&#123;OLD_IP_ADDR%.*&#125;.44</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启网卡</span></span><br><span class="line">ifdown $&#123;ENS&#125;</span><br><span class="line">ifup $&#123;ENS&#125;</span><br><span class="line">systemctl restart network.service</span><br><span class="line">echo -e &quot;\033[32m 静态IP配置完成 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;开始配置cobbler&quot;</span><br><span class="line">COB_CFG=/etc/cobbler/settings</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取本机IP地址</span></span><br><span class="line">NEW_IP_ADDR=`ifconfig | grep inet | awk &#x27;NR==1 &#123;print $2&#125;&#x27;`</span><br><span class="line">sed -i &#x27;/^manage_rsync:/s/0/1/g&#x27; $&#123;COB_CFG&#125;</span><br><span class="line">sed -i &quot;/^next_server:/s/127.0.0.1/$&#123;NEW_IP_ADDR&#125;/g&quot; $&#123;COB_CFG&#125;</span><br><span class="line">sed -i &quot;/^server:/s/127.0.0.1/$&#123;NEW_IP_ADDR&#125;/g&quot; $&#123;COB_CFG&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户初始密码</span></span><br><span class="line">echo -e &quot;\033[32m cobbler 初始密码为：123 \033[0m&quot;</span><br><span class="line">NEW_PSD=`openssl passwd -1 &quot;123&quot;`</span><br><span class="line">OLD_PSD=$1$mF86/UHC$WvcIcX2t6crBz2onWxyac.</span><br><span class="line">sed -i &quot;#^default_password_crypted:#s#$&#123;OLD_PSD&#125;#$&#123;NEW_PSD&#125;#g&quot; $&#123;COB_CFG&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 DHCP 服务</span></span><br><span class="line">sed -i &#x27;/^manage_dhcp:/s/0/1/g&#x27; $&#123;COB_CFG&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置yum仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">&#x27;/^yum_post_install_mirror:/s/0/1/g&#x27;</span> <span class="variable">$&#123;COB_CFG&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 cobblerd</span></span><br><span class="line">systemctl restart cobblerd</span><br><span class="line">echo -e &quot;\033[32m cobbler配置完成 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;开始修改TFTP&quot;</span><br><span class="line">TFTP_CFG=/etc/xinetd.d/tftp</span><br><span class="line">sed -i &#x27;/^disable/s/yes/no/g&#x27; $&#123;TFTP_CFG&#125;</span><br><span class="line">systemctl restart tftp</span><br><span class="line">echo -e &quot;\033[32m 绿色字 \033[0mTFTP配置完成&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;开始配置DHCP&quot;</span><br><span class="line">DHCP_CFG=/etc/cobbler/dhcp.template</span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">&quot;/^option routers/s/192.168.1.5/<span class="variable">$&#123;NEW_IP_ADDR%.*&#125;</span>.44/g&quot;</span> <span class="variable">$&#123;DHCP_CFG&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">&#x27;/^option domain-name-servers/s/192.168.1.1/8.8.8.8/g&#x27;</span> <span class="variable">$&#123;DHCP_CFG&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> next-server 就是指定tftp服务器的地址，也就是 NEW_IP_ADDR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">&quot;/^next-server/s/\$next_server/<span class="variable">$&#123;NEW_IP_ADDR&#125;</span>/g&quot;</span> <span class="variable">$&#123;DHCP_CFG&#125;</span></span></span><br><span class="line">sed -i &quot;22s/192.168.1.5/$&#123;NEW_IP_ADDR%.*&#125;.44/g&quot; $&#123;DHCP_CFG&#125;</span><br><span class="line">sed -i &#x27;23s/192.168.1.1/8.8.8.8/g&#x27; $&#123;DHCP_CFG&#125;</span><br><span class="line">sed -i &quot;28s/\$next_server/$&#123;NEW_IP_ADDR&#125;/g&quot; $&#123;DHCP_CFG&#125;</span><br><span class="line">sed -i &quot;s/192.168.1/$&#123;NEW_IP_ADDR%.*&#125;/g&quot; $&#123;DHCP_CFG&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">echo &quot;DHCP开始同步！&quot;</span><br><span class="line">systemctl restart cobblerd</span><br><span class="line">systemctl restart httpd</span><br><span class="line">systemctl restart rsyncd</span><br><span class="line">cobbler sync 1&gt; /dev/null</span><br><span class="line"></span><br><span class="line">sleep 5</span><br><span class="line">echo  -e &quot;\033[32m dhcp同步完成！ \033[0m&quot;</span><br><span class="line">systemctl restart dhcpd</span><br><span class="line">echo  -e &quot;\033[32m dhcp配置完成！ \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;开始配置kickstart文件！&quot;</span><br><span class="line">cat &lt;&lt; EOF &gt; /root/ks.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash">platform=x86, AMD64, 或 Intel EM64T</span></span><br><span class="line"><span class="meta">#</span><span class="bash">version=DEVEL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install OS instead of upgrade</span></span><br><span class="line">install</span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyboard layouts</span></span><br><span class="line">keyboard &#x27;us&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Root password = 123</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码可能有问题，装好了系统之后，可能还需要修改密码</span></span><br><span class="line">rootpw --iscrypted $1$4vl7X/nX$aqoCeN9ZX4Hcr1pfSXvUk.</span><br><span class="line"><span class="meta">#</span><span class="bash"> System language</span></span><br><span class="line">lang zh_CN</span><br><span class="line"><span class="meta">#</span><span class="bash"> System authorization information</span></span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use text install</span></span><br><span class="line">text</span><br><span class="line">firstboot --disable</span><br><span class="line"><span class="meta">#</span><span class="bash"> SELinux configuration</span></span><br><span class="line">selinux --disabled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Firewall configuration</span></span><br><span class="line">firewall --disabled</span><br><span class="line"><span class="meta">#</span><span class="bash"> Network information</span></span><br><span class="line">network  --bootproto=dhcp --device=ens32</span><br><span class="line"><span class="meta">#</span><span class="bash"> Halt after installation</span></span><br><span class="line">halt</span><br><span class="line"><span class="meta">#</span><span class="bash"> System timezone</span></span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use network installation</span></span><br><span class="line">url --url=&quot;ftp://$&#123;IP_ADDR&#125;/centos7&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> System bootloader configuration</span></span><br><span class="line">bootloader --location=mbr</span><br><span class="line"><span class="meta">#</span><span class="bash"> Partition clearing information</span></span><br><span class="line">clearpart --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> Disk partitioning information</span></span><br><span class="line">part / --fstype=&quot;xfs&quot; --size=10240</span><br><span class="line">part /boot --fstype=&quot;xfs&quot; --size=500</span><br><span class="line">part /home --fstype=&quot;xfs&quot; --size=4096</span><br><span class="line">part swap --fstype=&quot;swap&quot; --size=4096</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里放安装后脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里可以调用一键部署LMNP之类的脚本</span></span><br><span class="line"><span class="meta">%</span><span class="bash">post --interpreter=<span class="comment">#!/bin/bash</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">yum_config_stanza</span></span><br><span class="line">mkdir chenhaha</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line">echo &quot;1&quot;</span><br><span class="line"><span class="meta">%</span><span class="bash">end</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">packages</span></span><br><span class="line">@development</span><br><span class="line">@fonts</span><br><span class="line">@ftp-server</span><br><span class="line">@gnome-apps</span><br><span class="line">@gnome-desktop</span><br><span class="line">@input-methods</span><br><span class="line">@mariadb</span><br><span class="line">@mariadb-client</span><br><span class="line">@php</span><br><span class="line">@platform-devel</span><br><span class="line">@python-web</span><br><span class="line">@remote-desktop-clients</span><br><span class="line">@web-servlet</span><br><span class="line">vinagre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">end</span></span><br><span class="line">EOF</span><br><span class="line">echo  -e &quot;\033[32m kickstart配置完成 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;开始导入镜像！&quot;</span><br><span class="line">cobbler import --path=/mnt/cdrom --name=centos7 --arch=x86_64 --kickstart=/root/ks.cfg 1&gt; /dev/null</span><br><span class="line">echo  -e &quot;\033[32m 镜像导入成功 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;配置所安装系统的yum源！&quot;</span><br><span class="line">cobbler repo add --name=CentOS7-x86_64-Base --mirror=http://mirrors.163.com/centos/7/os/x86_64/ --arch=x86_64 --breed=yum</span><br><span class="line">echo  -e &quot;\033[32m yum源配置成功 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo &quot;配置cobbler web&quot;</span><br><span class="line">C_WEB_CFG=/etc/cobbler/modules.conf</span><br><span class="line">sed -i &#x27;23s/authn_configfile/authn_pam/g&#x27; $&#123;C_WEB_CFG&#125;</span><br><span class="line">sed -i &#x27;43s/authz_allowall/authz_ownership/g&#x27; $&#123;C_WEB_CFG&#125;</span><br><span class="line">useradd webuser</span><br><span class="line">echo 123 | passwd --stdin webuser &amp;&gt; /dev/null</span><br><span class="line">CO_U_CFG=/etc/cobbler/users.conf</span><br><span class="line">sed -i &#x27;/^admin/s/&quot;&quot;/&quot;webuser&quot;/g&#x27; $&#123;CO_U_CFG&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 cobblerd</span></span><br><span class="line">cobbler sync &amp;&gt; /dev/null</span><br><span class="line">systemctl restart cobblerd</span><br><span class="line">systemctl restart httpd</span><br><span class="line">echo  -e &quot;\033[32m cobbler web 配置完成 \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------</span></span><br><span class="line">echo  -e &quot;\033[32m 请访问：https://$&#123;NEW_IP_ADDR&#125;/cobbler_web \033[0m&quot;</span><br><span class="line">echo  -e &quot;\033[32m 账号：webuser， 密码：123 \033[0m&quot;</span><br><span class="line">echo  -e &quot;\033[32m 脚本已执行完成！ \033[0m&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署结束</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210330190842432.png" alt="image-20210330190842432">-</p>
<h2 id="第十四章-Linux可视化管理"><a href="#第十四章-Linux可视化管理" class="headerlink" title="第十四章 Linux可视化管理"></a>第十四章 Linux可视化管理</h2><h3 id="14-1-Webmin"><a href="#14-1-Webmin" class="headerlink" title="14.1 Webmin"></a>14.1 Webmin</h3><p>​    Webmin是功能强大的基于Web的Unix/Linux系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理操作。</p>
<ol>
<li><p>下载安装Webmin</p>
<p>在浏览器中下载：<a href="https://download.webmin.com/download/yum/">https://download.webmin.com/download/yum/</a></p>
<p>在Linux中通过<strong>wget</strong>下载：<a href="https://download.webmin.com/download/yum/webmin-1.970-1.noarch.rpm">https://download.webmin.com/download/yum/webmin-1.970-1.noarch.rpm</a></p>
</li>
<li><p>安装：<code>rpm -ivh webmin-1.970-1.noarch.rpm</code></p>
<p><strong>错误：显示perl(Encode::Detect) is needed by webmin-1.970-1.noarch</strong></p>
<p><strong>需要安装：<code>yum -y install perl-Encode-Detect</code></strong></p>
</li>
<li><p>重置密码： <code>/usr/libexec/webmin/changepass.pl /etc/webmin root 123</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210205182538055.png" alt="image-20210205182538055">-</p>
<p>先进入 /usr/libexec/webmin/ 目录，再改密码</p>
<p>root 是 webmin 的用户名，不是OS的，这里是八 webmin 的 root 用户密码改成了123</p>
</li>
<li><p>修改webmin服务的端口号：<code>vim /etc/webmin/miniserv.conf</code></p>
</li>
</ol>
<p>将 <strong>port</strong> = 10000 修改为123，将 <strong>listen</strong> = 10000 也改成123</p>
<ol start="5">
<li><p><code>/etc/webmin/restart</code> 重启</p>
<p><img src="/2021/08/25/16-07-33/image-20210205175341085.png" alt="image-20210205175341085">-</p>
<p><code>/etc/webmin/start</code> 启动</p>
<p><code>/etc/webmin/stop</code> 停止</p>
</li>
<li><p>防火墙开放 666 端口</p>
</li>
</ol>
<p><code>firewall-cmd --zone=public --add-port=666/tcp --permanent</code> 开放端口</p>
<p><img src="/2021/08/25/16-07-33/image-20210205175506001.png" alt="image-20210205175506001">-</p>
<p><code>firewall-cmd --reload</code> 跟新防火墙</p>
<p><img src="/2021/08/25/16-07-33/image-20210205175541518.png" alt="image-20210205175541518">-</p>
<p><code>firewall-cmd --zone=public --list-ports</code> 查看已经开放的端口号</p>
<p><img src="/2021/08/25/16-07-33/image-20210205175612703.png" alt="image-20210205175612703">-</p>
<ol start="7">
<li>登录webmin</li>
</ol>
<p>输入：<code>http:IP地址：666</code>，用户名是：root，密码是：123</p>
<p><img src="/2021/08/25/16-07-33/image-20210205182755380.png" alt="image-20210205182755380"></p>
<p><img src="/2021/08/25/16-07-33/image-20210205183045343.png" alt="image-20210205183045343"></p>
<h3 id="14-2-宝塔"><a href="#14-2-宝塔" class="headerlink" title="14.2 宝塔"></a>14.2 宝塔</h3><p>​    bt宝塔Linux面板是提升<strong>运维</strong>效率的服务器管理软件，支持一键LAMP、LNMP、集群、监控、网站、FTP、数据库、JAVA等多项服务器管理功能。</p>
<p>​    安装和使用：</p>
<ol>
<li><p>进入官网：<a href="https://www.bt.cn/download/linux.html">https://www.bt.cn/download/linux.html</a></p>
</li>
<li><p>复制下载地址：<code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code></p>
</li>
<li><p>安装成功后，会显示登录地址，账户和密码，复制到浏览器打开即可</p>
<p><img src="/2021/08/25/16-07-33/image-20210205185229008.png" alt="image-20210205185229008">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210205185501852.png" alt="image-20210205185501852">-</p>
<ol start="4">
<li>如果密码忘了可以输入：<code>bt default</code></li>
<li>可以输入 bt 查看帮助命令</li>
</ol>
</li>
</ol>
<h2 id="第十五章-FTP服务器"><a href="#第十五章-FTP服务器" class="headerlink" title="第十五章 FTP服务器"></a>第十五章 FTP服务器</h2><p>为什么使用VSFTP?</p>
<p>因为这个软件支持虚拟用户</p>
<h3 id="1、安装服务端vsftpd"><a href="#1、安装服务端vsftpd" class="headerlink" title="1、安装服务端vsftpd"></a>1、安装服务端<strong>vsftpd</strong></h3><p>​    本地源安装：</p>
<p>​    网络源安装：<code>yum install -y vsftpd ftp</code></p>
<h3 id="2、启动服务"><a href="#2、启动服务" class="headerlink" title="2、启动服务"></a>2、启动服务</h3><p>​    服务名称：vsftpd</p>
<p>​    <code>systemctl start vsftpd</code></p>
<p>​    <code>systemctl enable vsftpd</code> # 开机自启vsftpd</p>
<p>​    <strong>若启动失败，显示错误为</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Job for vsftpd.service failed because the control process exited with error code. See &quot;systemctl status vsftpd.service&quot; and &quot;journalctl -xe&quot; for details</span><br></pre></td></tr></table></figure>

<p>​    <strong>解决方法</strong>：</p>
<p>​    先修改配置文件：<code>vim /etc/vsftpd/vsftpd.conf</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210302133746321.png" alt="image-20210302133746321">-</p>
<p>​    然后查看一下<strong>21端口</strong>是否被占用：<code>netstat -lanpt | grep 21</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210302134013917.png" alt="image-20210302134013917">-</p>
<p>​    果然被一个名叫pure-ftpd的进程占用了，现在杀掉该进程：</p>
<p>​    先查看pure-ftpd的进程号：<code>ps aux | grep pure-ftpd</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210302134225973.png" alt="image-20210302134225973">-</p>
<p>​    杀掉该进程：<code>kill -9 904</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210302134245366.png" alt="image-20210302134245366">-</p>
<p>​    然后就可以成功运行了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302134356561.png" alt="image-20210302134356561">-</p>
<h3 id="3、防火墙设置"><a href="#3、防火墙设置" class="headerlink" title="3、防火墙设置"></a>3、防火墙设置</h3><p>方法一：</p>
<p><code>firewall-cmd --permanent --zone=public --add-service=ftp</code></p>
<p><code>firewall-cmd --reload</code></p>
<p>方法二：</p>
<p><code>systemctl stop firewalld</code></p>
<p>方法三：</p>
<p>使用ntsysv命令，开启 vsftpd 服务</p>
<p><img src="/2021/08/25/16-07-33/image-20210302101847646.png" alt="image-20210302101847646">-</p>
<h3 id="4、selinux设置"><a href="#4、selinux设置" class="headerlink" title="4、selinux设置"></a>4、selinux设置</h3><p>​    设置：<code>setenforce 0</code>，然后使用 <code>getenforce</code> 查看 selinux 的状态</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210302111432466.png" alt="image-20210302111432466">-</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210302111517928.png" alt="image-20210302111517928">-</p>
<h3 id="3、安装ftp"><a href="#3、安装ftp" class="headerlink" title="3、安装ftp"></a>3、安装ftp</h3><p>​    Linux系统中使用ftp命令对ftp服务器进行访问，若没有安装ftp，需要先进行安装：<code>yum install -y ftp</code></p>
<h3 id="4、启动ftp"><a href="#4、启动ftp" class="headerlink" title="4、启动ftp"></a>4、启动ftp</h3><p>​    <img src="/2021/08/25/16-07-33/image-20210302135112024.png" alt="image-20210302135112024">-</p>
<p>​    <!--因为在同一台电脑，所以IP地址用：127.0.0.1--></p>
<p>​    图中：Name为<strong>ftp</strong>，Password为<strong>空</strong>，ftp就是<strong>匿名用户</strong>，要以匿名用户登录，首先得修改配置文件：</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210302135310071.png" alt="image-20210302135310071">-</p>
<h3 id="5、ftp中的用户讲解"><a href="#5、ftp中的用户讲解" class="headerlink" title="5、ftp中的用户讲解"></a>5、ftp中的用户讲解</h3><p>​    ftp中的用户有三类：<strong>匿名（ftp、anonymous）、系统用户（普通用户、root）、虚拟用户</strong></p>
<h4 id="5-1-匿名用户"><a href="#5-1-匿名用户" class="headerlink" title="5.1 匿名用户"></a>5.1 匿名用户</h4><p>匿名用户登录过程：</p>
<p>​    输入用户名之后，ftp会去查看认证文件：**/etc/pam.d/**中是否用该用户的存在，如果存在，则登录成功</p>
<p>匿名用户<strong>ftp</strong>通过：<code>cat /ect/passwd</code> 文件可以查看到</p>
<p><img src="/2021/08/25/16-07-33/image-20210302143630459.png" alt="image-20210302143630459">-</p>
<p>默认匿名用户访问的目录是：**/var/ftp**</p>
<p><strong>注意</strong>：匿名用户虽然访问的是 /var/ftp 这个目录，<del>但是匿名用户是以Linux中其他人的角色访问的，</del>就只是匿名用户这个身份，下面查看 /var/ftp 的权限</p>
<p><img src="/2021/08/25/16-07-33/image-20210302140240193.png" alt="image-20210302140240193">-</p>
<p><del>这里可以看到other是没有<strong>写</strong>的权限的</del>  这里可以看到有写权限的只有root用户，如需要让匿名用户有<strong>写</strong>的权限，<del>这应该是需要加上<strong>w</strong></del>  因为不是other，所以修改other没有用，并且修改配置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302140437616.png" alt="image-20210302140437616">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210302141710118.png" alt="image-20210302141710118">-</p>
<!--注意每次修改后，都需要重新启动vsftpd服务-->

<p><strong>BUT</strong>，结果还是不行，原因竟是在/var/ftp是root用户的目录，<del>在这个目录里面把other权限加上了<strong>w</strong>就是不行</del>，解决方法有：</p>
<p>1、把<strong>pub</strong>这个目录的所有者改为<strong>ftp</strong>：</p>
<p><strong>先把前面修改w的操作还原</strong>，然后直接把这个pub目录的所有者改为ftp：</p>
<p><code>chown ftp /var/ftp/pub</code></p>
<p>修改位置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302155808938.png" alt="image-20210302155808938">-</p>
<p>因为ftp打开后，默认的文件夹是：**/var/ftp<strong>，而不是：</strong>/var/ftp/pub**</p>
<p>所以需要<strong>先切换文件夹到pub</strong>后，再来创建文件夹：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302155012790.png" alt="image-20210302155012790">-</p>
<!--因为前面修改的是pub这个目录的所以者为ftp！！！-->

<p>2、把<strong>ftp</strong>加入到<strong>pub</strong>这个目录的所属组中去：</p>
<p>因为pub的所属组是<strong>root</strong>组，现在只需要将<strong>ftp</strong>添加到<strong>root</strong>组中即可：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302184433884.png" alt="image-20210302184433884">-</p>
<p>先还原：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302191628948.png" alt="image-20210302191628948">-</p>
<p>还原之后，就不能再生成文件夹了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302192816110.png" alt="image-20210302192816110">-</p>
<p>下面将<strong>ftp</strong>添加到<strong>root</strong>组：<code>groupmems -a ftp -g root</code></p>
<p>添加之后再查看root组的成员：<code>groupmems -l -g root</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210302193003552.png" alt="image-20210302193003552">-</p>
<p>因为ftp现在已经被添加到了root组了，所以现在修改组成员的权限：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302193649117.png" alt="image-20210302193649117">-</p>
<p>然后重启vsftpd后，再次创建文件夹：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302193800144.png" alt="image-20210302193800144">-</p>
<!--成功！！！-->

<p>3、通过修改acl</p>
<p><code>setfacl -m u:ftp:rwx pub</code></p>
<p><strong><!--acl在day02的文件权限里面--></strong></p>
<hr>
<p>匿名用户的其他操作（<code>vim /etc/vsftpd/vsftpd.conf</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">no_anon_password=YES  # 设置匿名用户登录ftp时不输入密码</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210302194643776.png" alt="image-20210302194643776">-</p>
<!--此处不再提示输入密码！-->

<!--注意：每次设置后，都需要重启vsftpd服务-->

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftpd_banner= banner内容  # 设置提示内容</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210302194942000.png" alt="image-20210302194942000">-</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">anon_upload_enable=YES # 匿名用户上传权限</span><br></pre></td></tr></table></figure>

<p>下面在windows上上传文件到Linux：</p>
<p>先登录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302201453253.png" alt="image-20210302201453253">-</p>
<p>但是报错了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302203059866.png" alt="image-20210302203059866">-</p>
<p><strong>错误原因</strong>：</p>
<p>错误的原因竟是：在Windows打开了ftp之后，<strong>没有切换到pub目录下</strong>，<strong>shit</strong>，之后再次切换到pub目录下，就可以正常的进行上传和下载操作了</p>
<p><strong>下载操作</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303104540783.png" alt="image-20210303104540783">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303104627675.png" alt="image-20210303104627675">-</p>
<p><strong>上传操作</strong>：</p>
<p>先在本地找到需要上传的文件，然后：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303104735089.png" alt="image-20210303104735089">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303104804390.png" alt="image-20210303104804390">-</p>
<!--上传和下载文件时，都可以使用绝对地址-->

<p>1、用带图形界面的Xftp：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220055798.png" alt="image-20210302220055798">-</p>
<!--上面已经上传成功！-->

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">anon_mkdir_write_enable=YES #   匿名用户新建文件夹的权限</span><br></pre></td></tr></table></figure>

<p>关闭<strong>新建文件夹权限</strong>的结果：</p>
<p>1、图形化：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220216124.png" alt="image-20210302220216124">-</p>
<p>2、字符界面：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220259992.png" alt="image-20210302220259992">-</p>
<p>打开<strong>新建文件夹权限</strong>的结果：</p>
<p>1、图形界面：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220414727.png" alt="image-20210302220414727">-</p>
<p>2、字符界面：</p>
<!--跟上面上面的那个操作一样-->

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">anon_other_write_enable=YES # 匿名用户删除和修改文件的权限</span><br></pre></td></tr></table></figure>

<p>删除效果：</p>
<p>关闭之后的效果：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220844192.png" alt="image-20210302220844192">-</p>
<p>开启之后的效果：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302220939902.png" alt="image-20210302220939902">-</p>
<p>修改文件：</p>
<p>​    匿名用户修改文件的内容有点让人摸不着头脑，因为在修改了pub的文件所有者的操作后，在pub文件夹下创建的文件，其所有者和所属组全都是 ftp ，按理说，既然所有者都是ftp了，那ftp对其就应该能修改其内容，但是这里不是，还需要给文件加上其它权限，要不然连打开文件的权限都没有，修改前：-rw——-，修改后：-rw-rw-r–，注意：若修改为：-rw-rw—-，也照样打不开，难道ftp是先以其他人的身份打开文件，然后后面的修改操作又是以所有者的身份进行？这个不得而知，至少现在不知道（2021-3-3），不过至少现在能修改文件了！！</p>
<p><img src="/2021/08/25/16-07-33/image-20210303105102806.png" alt="image-20210303105102806">-</p>
<p>改了配置文件，还需要对匿名用户的权限进行修改吗（777）？</p>
<p><strong>需要</strong></p>
<h4 id="5-2-系统用户"><a href="#5-2-系统用户" class="headerlink" title="5.2 系统用户"></a>5.2 系统用户</h4><p>系统用户默认访问<strong>主目录</strong>，默认具有<strong>上传、下载、新建、删除</strong>的权限，还可以切换到系统的<strong>其他目录</strong></p>
<p>需要先设置允许系统用户访问：<code>local_enable=YES</code></p>
<p>下面以系统中的普通用户 chen 登录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302212114282.png" alt="image-20210302212114282">-</p>
<p>系统用户默认访问的是自己的主目录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302212340010.png" alt="image-20210302212340010">-</p>
<p>切换到系统其它目录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303075132129.png" alt="image-20210303075132129">-</p>
<p>怎么在“ftp&gt;“下进行<strong>写入操作</strong></p>
<p><strong>allow_writeable_chroot=YES  允许写入 —– 这句有什么用？</strong></p>
<p>上面的写入和 <strong>write_enable=YES</strong> 有什么区别？</p>
<p>答：因为系统用户登录后，默认是进入到家目录，并且默认可以进行删除、修改、增加等操作，还可以进入到其它目录，所以需要对其进行限制，需要使用：<strong>chroot_local_user=YES</strong> # 控制用户访问路径访问自己的主目录，不能切换到其他目录，但是限制后就不能进行删除、修改、增加等操作了，所以需要加入<strong>allow_writeable_chroot=YES</strong> 这一句，使其可以在自己的家目录中进行删除等操作。</p>
<p>解决方法用带图形界面的Xftp：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302222328255.png" alt="image-20210302222328255">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210302221421386.png" alt="image-20210302221421386">-</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">max_clients=30  # 设置最大连接数</span><br><span class="line"></span><br><span class="line">idle_session_timeout=600  # 设置超时时间</span><br><span class="line"></span><br><span class="line">local_root=/mnt/public/ # 设置系统用户访问ftp的默认目录</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">write_enable=YES #  允许写入</span><br><span class="line"></span><br><span class="line">chroot_local_user=YES # 控制用户访问路径访问指定目录，不能切换到其他目录</span><br><span class="line"></span><br><span class="line">allow_writeable_chroot=YES # 允许写入</span><br></pre></td></tr></table></figure>

<p>然后修改 <strong>/mnt/public/</strong> 目录下的文件权限，跟上面的操作一样</p>
<h4 id="5-3-虚拟用户"><a href="#5-3-虚拟用户" class="headerlink" title="5.3 虚拟用户"></a>5.3 虚拟用户</h4><p>创建虚拟用户的操作：</p>
<ol>
<li><p>安装Vsftpd虚拟用户需要用到的软件及认证模块：</p>
<p><code>yum install pam* libdb-utils libdb* --skip-broken -y</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303135720497.png" alt="image-20210303135720497">-</p>
<!--卸载软件：yum remove 软件名称--></li>
<li><p>创建虚拟用户临时文件**/etc/vsftpd/ftpusers.txt**，用户名密码格式如下：</p>
<p>文件的内容是：<strong>奇数行用户名、偶数行密码</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210303113705016.png" alt="image-20210303113705016">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303113637228.png" alt="image-20210303113637228">-</p>
</li>
<li><p>生成Vsftpd虚拟用户数据库认证文件：</p>
<p><code>db_load -T -t hash -f /etc/vsftpd/ftpusers.txt /etc/vsftpd/ftpuser.db</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303140229502.png" alt="image-20210303140229502">-</p>
<p><strong>选项-T</strong>允许应用程序能够将文本文件转译载入进数据库，如果指定了<strong>选项-T</strong>，那么一定要追跟<strong>子选项-t</strong>，用来指定转译载入的数据库类型，-t可以指定的数据类型有Btree、<strong>Hash</strong>、Queue和Recon数据库，这里使用的就是hash，<strong>选项-f</strong> 参数后面接包含用户名和密码的文本文件</p>
<!--将用户信息文件转换为数据库并使用hash加密--></li>
<li><p>设置权限为600：</p>
<p><code>chmod 600 /etc/vsftpd/ftpuser.db</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303140332769.png" alt="image-20210303140332769">-</p>
<!--防止除了root以外的其他人读取-->

<p><strong>但是这的所属组为什么ftp呢？</strong></p>
</li>
<li><p>配置<strong>PAM</strong>认证文件：</p>
<p><code>vim /etc/pam.d/vsftpd.vu</code></p>
<p>写入下面两行内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auth  required  pam_userdb.so  db=/etc/vsftpd/ftpuser</span><br><span class="line"></span><br><span class="line">account required pam_userdb.so db=/etc/vsftpd/ftpuser</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210303140721935.png" alt="image-20210303140721935">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303140703983.png" alt="image-20210303140703983">-</p>
<!--源文件是ftpuser.db但是上面写的时候不用加后缀--></li>
<li><p>在系统中新建一个伪用户：ftpuser（nologin），用于虚拟用户映射：</p>
<p><code>useradd -s /sbin/nologin ftpuser</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303120919346.png" alt="image-20210303120919346">-</p>
<!--注意：创建的这个用户一定是nologin，目的就是为了防止黑客登录--></li>
<li><p>修改默认的配置文件：<code>vim /etc/vsftpd/vsftpd.conf</code></p>
<p>修改内容：# pam_service_name=vsftpd</p>
<!--注掉这行是因为现在准备使用虚拟用户，所以需要切换到PAM认证文件去-->

<p><img src="/2021/08/25/16-07-33/image-20210303140942978.png" alt="image-20210303140942978">-</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pam_service_name=vsftpd.vu</span><br><span class="line"></span><br><span class="line">guest_enable=YES  # 开启系统虚拟用户访问</span><br><span class="line"></span><br><span class="line">guest_username=ftpuser  # 指定系统虚拟用户</span><br><span class="line"></span><br><span class="line">user_config_dir=/etc/vsftpd/vsftpd_user_conf   # 指定虚拟用户的配置文件目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：在 vsftpd_user_conf 目录下，单独为每个用户进行权限设置，文件名必须跟自定义用户列表中的用户名一样，例如文件名为：chen1</span></span><br><span class="line"></span><br><span class="line">virtual_use_local_privs=YES  # 虚拟用户与映射用户的权限是否一致，默认为NO</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210303141358772.png" alt="image-20210303141358772">-</p>
<p><strong>如果不设为YES会导致</strong>？？？？</p>
<p><strong>不设置的话，默认就是YES，当值等于YES，配置不生效，等于NO配置生效</strong></p>
</li>
<li><p>分别为虚拟用户创建私有的<strong>虚拟目录</strong>与独立的<strong>配置文件夹</strong>：</p>
<p><code>mkdir /home/ftpuser/chen1</code> # 这里是创建chen1的家目录</p>
<p><code>mkdir /etc/vsftpd/vsftpd_user_conf</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210303141946575.png" alt="image-20210303141946575">-</p>
<p>然后进入 <strong>/etc/vsftpd/vsftpd_user_conf</strong> 这个目录，创建并配置用户 chen1 的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local_root=/home/ftpuser/chen1  # 默认访问的目录</span><br><span class="line"></span><br><span class="line">virtual_use_local_privs=NO   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 当 virtual_use_local_privs=YES 时，虚拟用户和本地用户有相同的权限；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当 virtual_use_local_privs=NO 时，虚拟用户和匿名用户有相同的权限，默认是NO。</span></span><br><span class="line"></span><br><span class="line">write_enable=YES  # 允许写入</span><br><span class="line">anon_world_readable_only=YES  # 允许浏览</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210303142607095.png" alt="image-20210303142607095">-</p>
<p>为什么这里全是anonymous的配置呢？</p>
<p><del><strong>因为当时创建的系统用户 ftpuser 是 nologin 状态，也就跟 ftp 一样了</strong>，也就是说，现在的chen1、chen2、chen3都是以anonymous身份登录上去的。</del>，<strong>不一样，ftp这个虚拟用户是登录ftp服务器自动创建的，跟手动创建的nologin状态下的系统用户是不一样的，是这样的吗？</strong></p>
<p>查看 /etc/passwd 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303120906704.png" alt="image-20210303120906704">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210303120919346.png" alt="image-20210303120919346">-</p>
<p>配置虚拟用户成功后登录出错，显示：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303143728203.png" alt="image-20210303143728203">-</p>
<p>这个错误原因是因为配置文件后面加了空格和一些其它文字所导致的，应该为下面这样：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303143849523.png" alt="image-20210303143849523">-</p>
<p>然后，出现了一些其它错误，类似于上面的匿名用户，创建文件夹失败，删除失败等等。。</p>
<p><img src="/2021/08/25/16-07-33/image-20210303144056673.png" alt="image-20210303144056673">-</p>
<!--注意：chroot_local_user=YES 需要和 chroot_list_enable=NO 配合起义使用才能达到限制用户在自己的主目录，而不能cd到其它目录-->

<p><img src="/2021/08/25/16-07-33/image-20210303163453718.png" alt="image-20210303163453718">-</p>
<!--注意：当使用pwd显示 “/” 的时候，其实是被限制在了自己的主目录，这里的 / 不是根目录，就是 /home/ftpuser/chen1 这个目录-->

<p>在几经折磨之后，重新改写了主配置文件和子配置文件内容后成功了：</p>
<p>主配置文件内容：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303171803013.png" alt="image-20210303171803013">-</p>
<p>子配置文件内容：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303171819340.png" alt="image-20210303171819340">-</p>
<p>结果就是chen1用户，被限制在了自己的主目录，可以进行相关操作，如果不想让chen1用户拆包你创建文件夹，则在子配置文件中设置为：<strong>anon_mkdir_write_enable=NO</strong> 即可</p>
<!--贼nm复杂，去死吧--></li>
</ol>
<h4 id="5-4-三个用户对比"><a href="#5-4-三个用户对比" class="headerlink" title="5.4 三个用户对比"></a>5.4 三个用户对比</h4><p>安全等级最高的是<strong>虚拟用户</strong>，为什么这么说？</p>
<p>因为即使你使用虚拟用户登录后被黑客发现了，但是他得到的ftp用户名是nologin状态的，得不到真正的用户名和密码</p>
<h4 id="5-4-用户黑白名单"><a href="#5-4-用户黑白名单" class="headerlink" title="5.4 用户黑白名单"></a>5.4 用户黑白名单</h4><p><img src="/2021/08/25/16-07-33/image-20210302224313654.png" alt="image-20210302224313654">-</p>
<ol>
<li><p><strong>vim /etc/vsftpd/ftpusers 黑名单</strong>，此文件中包含的用户将被禁止登录vsftpd服务器，不管该用户是否在</p>
<p><img src="/2021/08/25/16-07-33/image-20210302224401734.png" alt="image-20210302224401734">-</p>
</li>
<li><p><strong>vim /etc/vstfpd/user_list 白名单</strong>，此文件中包含的用户可能被禁止登录，可能被允许登录</p>
<p><img src="/2021/08/25/16-07-33/image-20210302224422165.png" alt="image-20210302224422165">-</p>
</li>
<li><p>当用户<strong>同时出现</strong>在白名单和黑名单中时，为什么<strong>登录失败</strong>后还会显示ftp？</p>
<p>答：那个没影响，就比如打开QQ登录失败，但QQ还启动着</p>
</li>
<li><p>当存在 <strong>userlist_enable=YES</strong> 时，user_list文件生效。</p>
</li>
<li><p>当存在 **userlist_deny=YES **时，则仅禁止列表中的帐户登录。</p>
</li>
<li><p>当存在 **userlist_deny=NO **时，则允许列表中用户登录。 </p>
</li>
<li><p>其中：<strong>ftpusers文件的优先级要高于user_list文件</strong>，即如果一个用户同时存在于两个文件中，则<strong>被拒绝访问ftp</strong>。</p>
</li>
</ol>
<p>​    8. 配置文件中默认只有：<strong>userlist_enable=YES</strong> 这一项</p>
<h3 id="6、vsftpd日志管理"><a href="#6、vsftpd日志管理" class="headerlink" title="6、vsftpd日志管理"></a>6、vsftpd日志管理</h3><p>​    日志文件：**/var/log/xferlog**</p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210302225251521.png" alt="image-20210302225251521">-</p>
<p>​    <strong>日志管理，还是在主配置文件中</strong></p>
<p>​    <strong>xferlog_enable=YES</strong> # 开启日志记录</p>
<p>​    <strong>xferlog_std_format=YES</strong> # 日志格式</p>
<p>​    <strong>xferlog_file=/var/log/xferlog</strong> # 指定日志存放位置</p>
<p>​    指定日志存放位置后，再次打开出错：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302225638935.png" alt="image-20210302225638935">-</p>
<p>​    解决方法：<strong>需要先创建文件夹vsftp文件夹后，再次运行vsftp即可</strong></p>
<p>日志文件输出格式：</p>
<p><img src="/2021/08/25/16-07-33/image-20210303110921509.png" alt="image-20210303110921509">-</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wed Mar  3 18:21:13 2021</td>
<td align="center">当前时间（为本地时间），格式：DDD MMM dd hh:mm:ss YYYY</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">传输时间，单位为秒，这里为1秒</td>
</tr>
<tr>
<td align="center">::ffff:192.168.30.1</td>
<td align="center">远程主机名称/IP</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">文件大小</td>
</tr>
<tr>
<td align="center">/pub/www</td>
<td align="center">文件名：传输的文件名，这包括路径</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">传输类型：a 以ASCII传输，b 以二进制文件传输</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">特殊处理标志：_：不做任何特殊处理，c：文件是压缩格式，u：文件是非压缩格式，t：文件是tar格式</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">传输方向：o 从ftp服务器向客户端传输， i 相反</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">访问模式：a 匿名用户，g 来宾（虚拟）用户，r 系统用户</td>
</tr>
<tr>
<td align="center"><no_password></no_password></td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">ftp</td>
<td align="center">服务名，一般都为 ftp</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">认证方式，0 无，1 RFC931认证</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">认证用户id，如果使用*则表示无法获取该id</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">完成状态，i 未完成，c 完成</td>
</tr>
</tbody></table>
<!--这个表的内容是上面那个图片的最后一行-->

<h4 id="6-1-vsftpd-日志备份实战"><a href="#6-1-vsftpd-日志备份实战" class="headerlink" title="6.1 vsftpd 日志备份实战"></a>6.1 vsftpd 日志备份实战</h4><p>题：<strong>备份ftp日志：每周末晚上23点30分对日志文件进行备份，删除一个月前的日志文件</strong></p>
<p>先执行：<code>crontab -e</code> </p>
<p>然后输入备份指令：<code>30 22 * * 7 sh sftp_log_backup.sh</code></p>
<p>其中 <strong>sftp_log_backup.sh</strong> 中的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原日志目录</span></span><br><span class="line">LOG_ADDRESS=/var/log/xftplog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份的目录</span></span><br><span class="line">BACKUP=/var/log/ftp </span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间，作为文件名</span></span><br><span class="line">DATETIME=$(date+%Y-%m-%d_%H) </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建备份文件的目录，如果不存在，就创建</span></span><br><span class="line">[! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> [] 表示 <span class="built_in">test</span> -e， 意思是判断目录是否存在，如果不存在$?就为<span class="literal">false</span>，前面的！表示取反，意思是假 &gt; 真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始备份</span></span><br><span class="line">cp $&#123;LOG_ADDRESS&#125; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩备份的文件</span></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除对应的备份目录</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除一个月前的备份文件</span></span><br><span class="line">find $&#123;BACKUP&#125; -atime +30 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125;\;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向控制台打印备份成功</span></span><br><span class="line">echo &quot;备份日志文件成功~&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7、客户端软件访问"><a href="#7、客户端软件访问" class="headerlink" title="7、客户端软件访问"></a>7、客户端软件访问</h3><p>Windows上有：winscp、Xftp、XShell、MobaXterm</p>
<p>Linux、Windows、浏览器、资源管理器上访问：输入 ftp + IP地址</p>
<p><img src="/2021/08/25/16-07-33/image-20210302102214856.png" alt="image-20210302102214856">-</p>
<p>输入help，显示出来的就是ftp命令：</p>
<p><img src="/2021/08/25/16-07-33/image-20210302102325926.png" alt="image-20210302102325926">-</p>
<h2 id="第十五章-Linux内核源码篇"><a href="#第十五章-Linux内核源码篇" class="headerlink" title="第十五章 Linux内核源码篇"></a>第十五章 Linux内核源码篇</h2><p>​    现代的操作系统一般是由进程管理、内存管理、文件系统、驱动程序和网络等组成。</p>
<table>
<thead>
<tr>
<th align="center">文件</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boot</td>
<td align="center">和系统引导相关的代码</td>
</tr>
<tr>
<td align="center">fs</td>
<td align="center">存放Linux支持的文件系统代码</td>
</tr>
<tr>
<td align="center">include</td>
<td align="center">存放Linux核心需要的头文件</td>
</tr>
<tr>
<td align="center">init</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">kernel</td>
<td align="center">和系统内核相关的源码</td>
</tr>
<tr>
<td align="center">lib</td>
<td align="center">存放库代码</td>
</tr>
<tr>
<td align="center">Makefile</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mm</td>
<td align="center">和内存管理相关的代码</td>
</tr>
<tr>
<td align="center">tools</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>内核升级：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<p>下载&amp;解压内核源码：<code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.13.tar.xz &amp;&amp; tar -zxvf linux-5.10.13.tar.xz</code></p>
<p> 检测内核版本，显示可以升级的：<code>yum info kernel -q</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210206214150205.png" alt="image-20210206214150205">-</p>
<p>查看当前的内核版本：<code>uname -a</code> </p>
<p>升级内核：<code>yum update kernel</code></p>
<p>查看已经安装的内核：<code>yum list kernel -q</code></p>
<p>源码理解：</p>
<h2 id="第十六章-Kali系统操作"><a href="#第十六章-Kali系统操作" class="headerlink" title="第十六章 Kali系统操作"></a>第十六章 Kali系统操作</h2><h3 id="16-1-暴力破解ssh的密码"><a href="#16-1-暴力破解ssh的密码" class="headerlink" title="16.1 暴力破解ssh的密码"></a>16.1 暴力破解ssh的密码</h3><h4 id="1、启用kali的root用户"><a href="#1、启用kali的root用户" class="headerlink" title="1、启用kali的root用户"></a>1、启用kali的root用户</h4><p>​    参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/108046018">https://zhuanlan.zhihu.com/p/108046018</a></p>
<p>​    修改后就可以使用root用户登录了</p>
<h4 id="2、暴力破解-ssh-密码"><a href="#2、暴力破解-ssh-密码" class="headerlink" title="2、暴力破解 ssh 密码"></a>2、暴力破解 ssh 密码</h4><p>​    准备条件，先准备一台肉鸡，我这里使用centos 8</p>
<ol>
<li><p>配置网络</p>
<p>虚拟机可以忽略这一步</p>
</li>
<li><p>互相ping一下</p>
<p><img src="/2021/08/25/16-07-33/image-20210304120500254.png" alt="image-20210304120500254">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304120547737.png" alt="image-20210304120547737">-</p>
<p>互相ping成功！</p>
</li>
<li><p>在kali端使用nmap扫描肉鸡开放的端口</p>
<p><code>namp -ip 192.168.30.130</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304120826963.png" alt="image-20210304120826963">-</p>
<p>成功扫描到开放的端口，这里有我们需要的ssh服务</p>
</li>
<li><p>做一个字典</p>
<p>用户名 <code>vim user.txt</code> ，然后里面写入可能的用户名：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304120956367.png" alt="image-20210304120956367">-</p>
<p>密码 <code>vim pass.txt</code>，然后里面写入可能的密码：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304121127239.png" alt="image-20210304121127239">-</p>
<!--不做字典也可以去网上下载，不过那样会花很多时间--></li>
<li><p>使用 <strong>hydra</strong> 破解肉鸡的 ssh 密码</p>
<p><img src="/2021/08/25/16-07-33/image-20210304121301864.png" alt="image-20210304121301864">-</p>
<p>成功，可以看到对于的用户名和密码</p>
</li>
<li><p>系统的加固</p>
<p>​    由破解密码的思路反推，可以明白，系统加固可以采用：复杂密码、错误登录次数限制、限制指定IP地址登录、删除或禁用系统多余账户，采用密钥对登录、ftp可采用虚拟用户</p>
</li>
<li><p>使用 <strong>Metasploit</strong>  扫描</p>
<p>输入：msfconsole 命令即可启动Metasploit  </p>
<p><img src="/2021/08/25/16-07-33/image-20210304121509578.png" alt="image-20210304121509578">-</p>
<p>然后因为我们是准备扫描ssh，所以下一步需要找一下有关ssh的模块：<code>search ssh</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304121702801.png" alt="image-20210304121702801">-</p>
<p>一直往下找，一直找到第19行：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304121746706.png" alt="image-20210304121746706">-</p>
<p>这就是我们需要的模块，auxiliary是辅助的意思，全局意思是：<strong>通过枚举来辅助扫描ssh</strong></p>
<p>然后我们启用这个模块：<code>use 19</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304121926927.png" alt="image-20210304121926927">-</p>
<p>然后照着上面显示的RHOSTS、RPORT、USER_FILE进行设置，可以看见Current Setting这一栏，有些是有默认值的，还需要设置一些没有的内容</p>
<p><img src="/2021/08/25/16-07-33/image-20210304122121739.png" alt="image-20210304122121739">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304122142547.png" alt="image-20210304122142547">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304122219444.png" alt="image-20210304122219444">-</p>
<p>看到Current Settings这一栏，已经设置好了现在，下面启动Metasploit  </p>
<p><img src="/2021/08/25/16-07-33/image-20210304122317690.png" alt="image-20210304122317690">-</p>
<p>从结果可以看出，已经扫描到了root和chen两个用户</p>
</li>
<li><p>使用<strong>Patator</strong>进行暴力破解</p>
<p>命令行输入<code>patator</code>，即可看到我们需要的模块</p>
<p><img src="/2021/08/25/16-07-33/image-20210304122947713.png" alt="image-20210304122947713">-</p>
<p>然后根据提示：<code>patator 模块 --help</code>，查看关于ssh_login的帮助信息</p>
<p>然后可以看到范例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh_login host=10.0.0.1 user=root password=FILE0 0=passwords.txt -x ignore:mesg=<span class="string">&#x27;Authentication failed.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后我们现在来试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh_login host=192.168.30.130 user=root password=FILE0 0=pass.txt -x ignore:mesg=&#x27;Authentication failed.&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210304123949165.png" alt="image-20210304123949165">-</p>
<p>可以看到这一行，123这个密码登录root用户成功！</p>
</li>
<li><p>使用<strong>BrutesPray</strong>进行暴力破解（<strong>Brutes Pray</strong>：人面兽心的人祈祷）</p>
<p><strong>BrutesPray</strong>是一款基于 <strong>nmap</strong> 扫描输出的 gnmap/XML 文件。自动调用<strong>Medusa</strong>对服务进行爆破</p>
<p>使用这个需要先安装：<code>apt-get install -y brutespray</code></p>
<p>这时候突然遇到了一个问题：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304134638619.png" alt="image-20210304134638619">-</p>
<p>可以确定是软件源的问题，需要在root用户下，编辑source.list文件</p>
<p><code>vim /etc/apt/source.list</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304135114042.png" alt="image-20210304135114042">-</p>
<p>换的是<strong>中科大</strong>的源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<p>然后跟新一下：<code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304135331142.png" alt="image-20210304135331142">-</p>
<p>然后再次安装：<code>apt-get install -y brutespray</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304140515434.png" alt="image-20210304140515434">-</p>
<p>安装成功！</p>
<p>因为BrutesPray是基于nmap扫描输出的gnmap/XML文件，所以先生成这个XML文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304141233911.png" alt="image-20210304141233911">-</p>
<p>注意：</p>
<p>-sV 是版本检测，用于扫描目标主机服务版本号. 探测打开的端口以确定服务/版本信息</p>
<p>-oX 表示以xml的格式输出结果到以文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210304141646827.png" alt="image-20210304141646827">-</p>
<p><del>文件生成成功！</del>其实生成文件失败了，应该用：</p>
<p><code>nmap -sV -p 22 192.168.30.130/24 -oX nmaplive.xml</code> </p>
<p><img src="/2021/08/25/16-07-33/image-20210304142648941.png" alt="image-20210304142648941">-</p>
<p>这样才算成功了！</p>
<p>下面开始用BrutesPray破解：</p>
<p><code>brutespray --file nmaplive.xml -U user.txt -P pass.txt -c</code></p>
<p>–file 接刚才生成的XML文件</p>
<p>-u 接用户名，-U 接一个 用户名字典文件</p>
<p>-p 接一个密码，-P 接一个密码字典文件</p>
<p>-c 成功后继续爆破</p>
<p><img src="/2021/08/25/16-07-33/image-20210304143412261.png" alt="image-20210304143412261">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304142828568.png" alt="image-20210304142828568">-</p>
<p>成功找到账户和密码</p>
</li>
</ol>
<h2 id="第十七章-Web服务器"><a href="#第十七章-Web服务器" class="headerlink" title="第十七章 Web服务器"></a>第十七章 Web服务器</h2><h3 id="17-1-静态网站搭建"><a href="#17-1-静态网站搭建" class="headerlink" title="17.1 静态网站搭建"></a>17.1 静态网站搭建</h3><p>​    apache 的服务名称：<strong>httpd</strong></p>
<h4 id="17-1-1-单个静态网站部署"><a href="#17-1-1-单个静态网站部署" class="headerlink" title="17.1.1 单个静态网站部署"></a>17.1.1 单个静态网站部署</h4><ol>
<li><p>命令  <code>rpm  -qa  | grep  httpd</code>  ，查看系统中已安装的所有apache软件包列表</p>
<p><img src="/2021/08/25/16-07-33/image-20210304145347061.png" alt="image-20210304145347061">-</p>
</li>
<li><p>安装 Apache 服务：<code>yum install -y httpd</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304172127469.png" alt="image-20210304172127469">-</p>
<p>然后检查是否启动：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304144740246.png" alt="image-20210304144740246">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304172304211.png" alt="image-20210304172304211">-</p>
<!--没启动就启动-->

<p>配置文件位置：/etc/httpd/conf/httpd.conf</p>
<p><img src="/2021/08/25/16-07-33/image-20210304172744927.png" alt="image-20210304172744927">-</p>
<p>端口号：tcp 80</p>
<p><img src="/2021/08/25/16-07-33/image-20210304172804311.png" alt="image-20210304172804311">-</p>
<p>日志文件位置：/var/log/httpd/，有两个日志文件，一个访问，一个错误</p>
<p><img src="/2021/08/25/16-07-33/image-20210304172838522.png" alt="image-20210304172838522">-</p>
<p>网站默认主目录：/var/www/html/，默认为空</p>
<p><img src="/2021/08/25/16-07-33/image-20210304172945763.png" alt="image-20210304172945763">-</p>
</li>
<li><p>测试 Apache 服务安装是否成功</p>
<p><img src="/2021/08/25/16-07-33/image-20210304173321783.png" alt="image-20210304173321783"></p>
<!--打开浏览器，输入127.0.0.1 ，如果看到 test字样，代表安装成功-->

<!--在本机访问，需要打开防火墙的80端口，或者关闭防火墙，还有 selinux的设置--></li>
<li><p>添加一个静态网站到：/var/www/html</p>
<p><img src="/2021/08/25/16-07-33/image-20210304173959959.png" alt="image-20210304173959959">-</p>
</li>
<li><p>修改配置文件：<code>vim /etc/httpd/conf/httpd.conf</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304174304472.png" alt="image-20210304174304472">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174232617.png" alt="image-20210304174232617">-</p>
</li>
<li><p>更改首页名称index为exam：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174616263.png" alt="image-20210304174616263">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174529884.png" alt="image-20210304174529884">-</p>
<p>然后重启服务再次访问：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174732831.png" alt="image-20210304174732831">-</p>
</li>
<li><p>更改端口号为8080：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174847686.png" alt="image-20210304174847686">-</p>
<p>重启服务后再次访问：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304174920492.png" alt="image-20210304174920492">-</p>
</li>
<li><p>Apache 安全配置</p>
<p>1、虚拟目录的配置</p>
</li>
<li></li>
</ol>
<h4 id="17-1-2-多个静态网站部署"><a href="#17-1-2-多个静态网站部署" class="headerlink" title="17.1.2 多个静态网站部署"></a>17.1.2 多个静态网站部署</h4><p>​    下面配置是基于域名的虚拟主机方式部署多个网站</p>
<ol>
<li><p>在hosts文件中域名注册</p>
<p>编辑 /etc/hosts 在最后追加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.30.135 www.examchenchen.com</span><br><span class="line">192.168.30.135 www.hrchenchen.com</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/25/16-07-33/image-20210304194407637.png" alt="image-20210304194407637">-</p>
<!--注意只在本机有效--></li>
<li><p>使用<strong>nslookup</strong>查询一下：</p>
<p>nslookup是域名查询命令，可以在linux和windows平台上查询域名对应的iP地址</p>
<p><img src="/2021/08/25/16-07-33/image-20210304181524432.png" alt="image-20210304181524432">-</p>
</li>
<li><p>ping 一下这两个域名：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304194449144.png" alt="image-20210304194449144">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304194529388.png" alt="image-20210304194529388">-</p>
</li>
<li><p><del>将 exam 和 hr 网站放到**/var/www**目录下：</del></p>
<p><img src="/2021/08/25/16-07-33/image-20210304192451106.png" alt="image-20210304192451106">-</p>
<!--这里没有改动--></li>
<li><p>修改主配置文件：<code>vim /etc/httpd/conf/httpd.conf</code></p>
<p>把端口改回 <strong>80</strong>，然后去掉刚才在<strong>DirectoryIndex</strong>后面添加的 <strong>exam.html</strong></p>
<p>在配置文件最后增加：<strong>Include conf/vhost/*.conf</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210304182346885.png" alt="image-20210304182346885">-</p>
<!--这样的目的是便于维护，因为可以分别将exam和hr的配置文件放到vhost目录下-->

<!--注意：这里的 conf/vhost/，全路径是 /etc/httpd/conf/vhost/--></li>
<li><p>然后创建一个在conf目录下新建一个vhost目录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304183204397.png" alt="image-20210304183204397">-</p>
</li>
<li><p>分别为exam和hr创建配置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304194600598.png" alt="image-20210304194600598">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210304194620952.png" alt="image-20210304194620952">-</p>
</li>
<li><p>重启服务后报错：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304183402304.png" alt="image-20210304183402304">-</p>
<p>原因是因为在httpd主配置文件中写到：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304183513750.png" alt="image-20210304183513750">-</p>
<p>但是，新建的vhost的权限却是这样的：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304183607204.png" alt="image-20210304183607204">-</p>
<p>所以需要把vhost的权限改为<strong>apche</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304183708832.png" alt="image-20210304183708832">-</p>
<p>再次启动服务<strong>还是出错</strong>，原因是前面修改了<strong>DocumentRoot</strong>，现在改回来了，还是不能启动，那么使用 <strong>httpd -t</strong> 检查语法是否错误：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304191557413.png" alt="image-20210304191557413">-</p>
<!--服务成功启动！--></li>
<li><p>再次打开网站，<strong>还是不能访问</strong>的原因是因为我是在Windows上访问的，应该在本Linux系统上访问的，在Windows上访问还需要修改hosts文件！！shit！！</p>
</li>
<li><p>再次打开就成功了：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304194824444.png" alt="image-20210304194824444"></p>
<p><img src="/2021/08/25/16-07-33/image-20210304194839369.png" alt="image-20210304194839369"></p>
</li>
</ol>
<h3 id="17-2-动态网站搭建"><a href="#17-2-动态网站搭建" class="headerlink" title="17.2 动态网站搭建"></a>17.2 动态网站搭建</h3><h4 id="1、LAMP平台的搭建"><a href="#1、LAMP平台的搭建" class="headerlink" title="1、LAMP平台的搭建"></a>1、LAMP平台的搭建</h4><p>​    <strong>LAMP = Linux + Apache + Mysql + PHP</strong></p>
<p>​    此过程可通过<strong>宝塔页面</strong>一键安装，如果不嫌麻烦就采用下面的方法：</p>
<p>​    <strong>注意：以下操作在CentOS 8 有依赖问题，所以，已经切换到了 CentOS 7 上！</strong></p>
<p>​    <strong>在CentOS 7 中使用的是<u>本地源</u>，不是网络源，所以安装很顺利！</strong></p>
<ol>
<li><p>安装Apache</p>
<p><code>yum install httpd httpd-devel</code> </p>
<p>然后启动报错：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305181609690.png" alt="image-20210305181609690">-</p>
<p>然后修改了一下端口号，因为那句：no listening sockets available, shutting down</p>
<p>因为上面安装了<strong>Nginx</strong>占用了<strong>80端口</strong>！！</p>
<p><code>vim /etc/httpd/conf/httpd.conf</code>，修改端口为 81，然后再次启动，成功</p>
<p>然后设置为开机自启：<code>systemctl enable httpd</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305221028779.png" alt="image-20210305221028779">-</p>
</li>
<li><p>安装MariaDB</p>
<p><code>yum install mariadb mariadb-server mariadb-libs mariadb-devel</code></p>
<p>然后：<code>rpm -qa | grep maria</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305221307913.png" alt="image-20210305221307913">-</p>
<p>开启mysql服务：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305221408573.png" alt="image-20210305221408573">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305221459969.png" alt="image-20210305221459969">-</p>
<p>登录数据库：mysql -u root -p</p>
<p><img src="/2021/08/25/16-07-33/image-20210305222415566.png" alt="image-20210305222415566">-</p>
<p>注意首次登录没有密码，需要设置：<code>mysql_secure_installation</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305223140938.png" alt="image-20210305223140938">-</p>
<p>查看数据库：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305223427897.png" alt="image-20210305223427897">-</p>
<p>选择数据库：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305223510460.png" alt="image-20210305223510460">-</p>
<p>创建数据库：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305223741122.png" alt="image-20210305223741122">-</p>
<p>删除数据库：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305223813641.png" alt="image-20210305223813641">-</p>
<p>数据库备份：<code>mysqldump mysql --user=root --password=123&gt;db-01.mysql;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305224126294.png" alt="image-20210305224126294">-</p>
<p>数据库恢复：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305224226202.png" alt="image-20210305224226202">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305224304550.png" alt="image-20210305224304550">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305224421994.png" alt="image-20210305224421994">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305224437442.png" alt="image-20210305224437442">-</p>
<!--人狠话不多！--></li>
<li><p>安装PHP</p>
<p><code>yum -y install php php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mysql</code></p>
<p>测试PHP是否安装成功：<code>vim /etc/www/html/info.php</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305224912349.png" alt="image-20210305224912349">-</p>
<p>重启httpd服务：<code>systemctl restart httpd</code></p>
<p>然后打开浏览器输入：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305224807427.png" alt="image-20210305224807427">-</p>
<!--perfect--></li>
<li><p>发布bbs网站</p>
<p>把bbs论坛移动到/var/www/html目录下，通过浏览器直接访问：<code>IP/bbs</code>进行安装</p>
<p>准备工作：</p>
<p>cd 到 /var/www/html 目录下，然后修改bbs下面所有文件的所属组或者所有者为apache：</p>
<p><code>chown -R apache bbs/</code></p>
<p>然后：<code>setenforce 0</code></p>
<p>最后通过浏览器访问！</p>
<p>进行到这步时，先去MariaDB新建一个数据库：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305232158612.png" alt="image-20210305232158612">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305232316438.png" alt="image-20210305232316438">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305232336065.png" alt="image-20210305232336065"></p>
<!--成功部署bbs！--></li>
<li><p>Apache 日志管理</p>
<p>Apache的日志分为access_log 和 error_log 两个，位置是在 /var/log/httpd 下</p>
<p><img src="/2021/08/25/16-07-33/image-20210306091516198.png" alt="image-20210306091516198">-</p>
<p>在我们网站部署遇到问题时，可以通过去查看error日志找到问题所在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Sat Mar 06 09:03:11.751269 2021] [autoindex:error] [pid 1574] [client 192.168.30.1:5190] AH01276: Cannot serve directory /var/www/html/: No matching DirectoryIndex (index.html,index.php) found, and server-generated directory index forbidden by Options directive</span><br></pre></td></tr></table></figure>

<p>注意到这一句：[autoindex:error]，这就是错误日志级别，现在是<strong>error</strong>级别</p>
<table>
<thead>
<tr>
<th align="center">等级</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">emerg</td>
<td align="center">紧急(系统无法使用)</td>
</tr>
<tr>
<td align="center">alert</td>
<td align="center">必须立即采取措施</td>
</tr>
<tr>
<td align="center">crit</td>
<td align="center">致命情况</td>
</tr>
<tr>
<td align="center">error</td>
<td align="center">错误情况</td>
</tr>
<tr>
<td align="center">warn</td>
<td align="center">警告情况</td>
</tr>
<tr>
<td align="center">notice</td>
<td align="center">一般情况</td>
</tr>
<tr>
<td align="center">infor</td>
<td align="center">普通信息</td>
</tr>
<tr>
<td align="center">debug</td>
<td align="center">调试信息</td>
</tr>
</tbody></table>
<p>然后看到 <strong>No matching DirectoryIndex (index.html,index.php) found</strong>：这句话的意思在这个目录下没有找到index开头的网页文件，那我们去看看是不是真的没有：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306092321300.png" alt="image-20210306092321300">-</p>
<p>那为什么会产生这条信息呢？那还需要去apache的配置文件中看：<code>vim /etc/httpd/conf/httpd.conf</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210306092630874.png" alt="image-20210306092630874">-</p>
<p>把这3行注释掉，然后修改：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306093248035.png" alt="image-20210306093248035">-</p>
<p>然后重启apache服务，就不会再次报这个错了，but 又有一个新错误：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306093655629.png" alt="image-20210306093655629">-</p>
<p>看内容跟域名有关，而且上面说了怎么弄：set ServerName directive globally to suppress this message</p>
<p><img src="/2021/08/25/16-07-33/image-20210306094126935.png" alt="image-20210306094126935">-</p>
<p>找到这一行，然后按照提示修改即可，然后再次查看错误日志，发现没有错误了！！！</p>
<p><img src="/2021/08/25/16-07-33/image-20210306094111232.png" alt="image-20210306094111232">-</p>
<p>上面提示的都是notice级别的，不用管！</p>
<p>在主配置文件中有一行：<strong>LogLevel</strong>，是用于调整记录错误日志中的信息的<strong>详细程度</strong>，apache默认级别是warn，那么warn级别以上的日志都会记录，但是写日志会给系统带来很大的损耗，关闭日志后，粗略估计可以提高整体性能近40%</p>
<p>注意每条信息后面都跟有<strong>PID进程号</strong>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306103341537.png" alt="image-20210306103341537">-</p>
<p>我们可以通过：ps -q + PID 去查看对于的服务名：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306103322123.png" alt="image-20210306103322123">-</p>
<p>看完了错误日志后，来看看访问日志，访问日志有专门的格式，可以去到主配置文件查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306105031045.png" alt="image-20210306105031045">-</p>
<table>
<thead>
<tr>
<th align="center">字段值（格式）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.30.1**(%h)**</td>
<td align="center">这是发送请求到服务器的客户的IP地址，即远程主机的地址，即它表明访问网站的究竟是谁</td>
</tr>
<tr>
<td align="center">-<strong>(%l)</strong></td>
<td align="center">这是由客户端identd进程判断的RFC1413身份(identity)，输出中的符号”-“表示此处的信息无效。除非在严格控制的内部网络中，此信息通常很不可靠，不应该被使用。只有在将IdentityCheck指令设为On时，Apache才会试图得到这项信息。</td>
</tr>
<tr>
<td align="center">-<strong>(%u)</strong></td>
<td align="center">这是HTTP认证系统得到的访问该网页的客户标识(<strong>userid</strong>)，环境变量<strong>REMOTE_USER</strong>会被设为该值并提供给CGI脚本。如果状态码是401，表示客户未通过认证，则此值没有意义。如果网页没有设置密码保护，则此项将是”-“。</td>
</tr>
<tr>
<td align="center">[06/Mar/2021:10:07:03 +0800]<strong>(%t)</strong></td>
<td align="center">这是服务器完成请求处理时的时间，其格式是： [日/月/年:时:分:秒 时区]</td>
</tr>
<tr>
<td align="center">“GET /bbs/static/image/common/nv.png HTTP/1.1”</td>
<td align="center">引号中是客户端发出的包含许多有用信息的请求行。该客户的动作是GET，请求的资源是/images/apache_pb.gif，使用的协议是HTTP/1.1</td>
</tr>
<tr>
<td align="center">404**(%&gt;s)**</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">228**(%b)**</td>
<td align="center">这项是返回给客户端的不包括响应头的字节数。如果没有信息返回，则此项应该是”-“，如果希望记录为”0”的形式，就应该用**%B**</td>
</tr>
<tr>
<td align="center">“<a href="http://192.168.30.136:81/data/cache/style_1_common.css?rjM&quot;">http://192.168.30.136:81/data/cache/style_1_common.css?rjM&quot;</a> ||格式： <strong>“<a href="http://localhost:81/&quot;">http://localhost:81/&quot;</a> (“%{Referer}i”)</strong></td>
<td align="center">“Referer”请求头。此项指明了该请求是被从哪个网页提交过来的</td>
</tr>
<tr>
<td align="center">“Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36” || 格式：**”Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0” “%{User-Agent}i&quot;**</td>
<td align="center">“User-Agent”请求头。此项是客户端提供的浏览器识别信息，这里可以看出我用的时Chrome浏览器</td>
</tr>
</tbody></table>
</li>
<li><p>对Apache日志进行分割</p>
<p>使用<strong>rotatelogs</strong>轮循工具对日志文件进行轮循，基本上是按照事件或者大小来控制的</p>
<p><img src="/2021/08/25/16-07-33/image-20210306190840997.png" alt="image-20210306190840997">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210306192054119.png" alt="image-20210306192054119">-</p>
<!--注意上面的CustomLog的位置，不能放到Directory里面，不然会产生语法错误！-->

<p><img src="/2021/08/25/16-07-33/image-20210306192659653.png" alt="image-20210306192659653">-</p>
<p>成功产生今天的日志，注意上面那个<strong>86400是秒</strong>，换成天数是1天，也就是说，每天都产生一个，这样查看日志可以很方便的找到。</p>
</li>
<li><p>Apache服务器的安全加固</p>
<ul>
<li><p>安装最新补丁</p>
<p>如果门是敞开的话，在窗户上加锁就毫无意义。同样道理，如果你没有打补丁，继续下面的操作就没有什么必要</p>
<p><strong>操作方法</strong>：</p>
<p><strong>如果是yum安装的，直接yum update httpd更新版本</strong><br><strong>如果是源代码安装的，请从apache官网下载最新版源码包编译安装</strong></p>
</li>
<li><p>隐藏Apache的版本号和其它敏感信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210309145359945.png" alt="image-20210309145359945">-</p>
<p><strong><!--apache的类似于这样！！--></strong></p>
<p>默认情况下，很多apache安装时会显示<strong>版本号</strong>及操作系统版本，甚至会显示服务器上安装的是什么样的apache模块。这些信息可以为黑客所用，并且黑客还可以从中得知你所配置的服务器上的很多设置都是默认状态。</p>
<p>操作方法：<code>vim /var/etc/httpd/conf/httpd.conf</code> </p>
<p>在配置文件中添加：<strong>ServerSignature Off</strong></p>
</li>
<li><p>确保apache以其自身的用户账号和组运行（Apache启动权限）</p>
<p>创建一个新的帐户来替代这个帐号启动apache并设置相应的权限，因为在配置文件中可以看到两行：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306121003275.png" alt="image-20210306121003275">-</p>
<p>可以创建一个专用的账户或者组去运行httpd，然后还需要修改一下网站各个文件的权限</p>
</li>
<li><p>确保web根目录之外的文件没有提供服务</p>
<p>拒绝对整个服务器<strong>文件系统</strong>的访问。你必须<strong>显式允许访问其他的web内容目录</strong>，意思就是我们不让apache访问web根目录之外的任何文件</p>
<p><img src="/2021/08/25/16-07-33/image-20210306121650930.png" alt="image-20210306121650930">-</p>
<p>注意：<strong>AllowOverride</strong>参数就是指明Apache服务器是否去找**.htacess<strong>文件作为配置文件，如果设置为</strong>none**,那么服务器将<strong>忽略</strong>.htacess文件，如果设置为<strong>All</strong>,那么所有在.htaccess文件里有的指令都将被<strong>重写，</strong>设置之后网页就无法访问了，原因时下面那句<strong>Require all denied</strong>，这句的意思是禁止所以访问请求，可以改为<strong>Require all granted</strong>，允许所以访问请求，如果想达到只允许来自特定域名主机的访问请求，其他请求将被拒绝，就把Require后面修改为特定主机域名或者IP</p>
<p>无条件禁止访问：</p>
<p>​    <strong>Order Allow,Deny</strong><br><strong>​    Deny from All</strong></p>
<p>禁止部分内容的访问，其他的全部开放：</p>
<p>​    <strong>Order Deny,Allow</strong><br><strong>​    Deny from ip1 ip2</strong></p>
<p><code>Options</code>指令的主要作用是控制特定目录将启用哪些服务器特性，Apache允许在一个目录配置中设置多个<code>Options</code>指令。不过，一般来说，如果一个目录被多次设置了<code>Options</code>，则指定特性数量最多的一个<code>Options</code>指令会被完全接受(其它的被忽略)，而各个<code>Options</code>指令之间并不会合并</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">All</td>
<td align="center">表示除 <code>MultiViews</code>之外的所有特性。这也是Options指令的 默认设置</td>
</tr>
<tr>
<td align="center">None</td>
<td align="center">表示不启用任何的服务器特性。</td>
</tr>
<tr>
<td align="center">FollowSymLinks</td>
<td align="center">服务器允许在此目录中使用符号连接。如果该配置选项位于 <code>&lt;Location&gt;</code>配置段中，将会被忽略</td>
</tr>
<tr>
<td align="center">Indexes</td>
<td align="center">如果输入的网址对应服务器上的一个文件目录，而此目录中又没有 DirectoryIndex指令(例如： DirectoryIndex index.html index.php)，那么服务器会返回由 mod_autoindex模块生成的一个格式化后的目录列表，并列出该目录下的所有文件</td>
</tr>
<tr>
<td align="center">MultiViews</td>
<td align="center">允许使用 mod_negotiation模块提供内容协商的”多重视图”。简而言之，如果客户端请求的路径可能对应多种类型的文件，那么服务器将根据客户端请求的具体情况自动选择一个最匹配客户端要求的文件。例如，在服务器站点的 file文件夹下中存在名为 hello.jpg和 hello.html的两个文件，此时用户输入 Http://localhost/file/hello，如果在 file文件夹下并没有 hello子目录，那么服务器将会尝试在 file文件夹下查找形如 hello.*的文件，然后根据用户请求的具体情况返回最匹配要求的 hello.jpg或者 hello.html。</td>
</tr>
<tr>
<td align="center">SymLinksIfOwnerMatch</td>
<td align="center">服务器仅在符号连接与目标文件或目录的所有者具有相同的用户ID时才使用它。简而言之，只有当符号连接和符号连接指向的目标文件或目录的所有者是同一用户时，才会使用符号连接。如果该配置选项位于 <code>&lt;Location&gt;</code>配置段中，将会被忽略</td>
</tr>
<tr>
<td align="center">ExecCGI</td>
<td align="center">允许使用 <code>mod_cgi</code>模块执行CGI脚本</td>
</tr>
<tr>
<td align="center">Includes</td>
<td align="center">允许使用 <code>mod_include</code>模块提供的服务器端包含功能</td>
</tr>
<tr>
<td align="center">IncludesNOEXEC</td>
<td align="center">允许服务器端包含，但禁用”#exec cmd”和”#exec cgi”。但仍可以从 <code>ScriptAlias</code>目录使用”#include virtual”虚拟CGI脚本。</td>
</tr>
</tbody></table>
</li>
<li><p>关闭目录浏览</p>
<p>通过用option命令来实现这个功能，设置option为none或者 - indexes</p>
<!--注意indexes前面的是减号！--></li>
<li><p>关闭includes</p>
<p>使用option命令来实现，设置option为none或者 - includes</p>
<!--注意includes前面的是减号！--></li>
<li><p>关闭cgi执行程序</p>
<p>使用option命令来实现，设置option为none或者 - execcgi</p>
</li>
<li><p>禁止apache遵循符号链接</p>
<p>使用option命令来实现，设置option为none或者 - followsymlinks</p>
</li>
<li><p>关闭多重选项</p>
<p>使用option命令来实现，设置option为none</p>
</li>
<li><p>关闭对.htaccess文件的支持</p>
<p><strong>allowoverride none</strong></p>
</li>
<li><p>运行mod_security</p>
<p>这个安全模组支持：简单过滤、基于过滤的常规表达式、url编码验证、unicode编码验证、审计、空字节攻击防止、上载存储限制、服务器身份隐藏、内置的chroot支持、更多其它功能</p>
<p>安装mod_security：yum install -y mod_security</p>
<p>安装完成后可以在/etc/httpd/conf.d里面找到主配置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306171914514.png" alt="image-20210306171914514">-</p>
<p>然后在配置文件中加载：<strong>LoadModule security2_module modules/mod_security2.so</strong></p>
<p>上面这句中的 modules/mod_security2.so 意思是在modules（/etc/httpd/modules）文件夹下的mod_security2.so文件，security2_module是模块的名称</p>
<p><img src="/2021/08/25/16-07-33/image-20210306172212025.png" alt="image-20210306172212025">-</p>
<p>然后重启apache服务！</p>
<p>然后接下来这步最为关键，就是配置mod_security，详见：<a href="https://blog.csdn.net/claytang/article/details/80066400">https://blog.csdn.net/claytang/article/details/80066400</a></p>
</li>
<li><p>关闭任何不必要的模块</p>
<p>apache通常会安装几个模块，浏览apache的module documentation，了解已安装的各个模块是做什么用的。很多情况下，你会发现并不需要激活那些模块，找到httpd.conf中包含loadmodule的代码。要关闭这些模块，只需要在代码行前添加一个#号。要找到正在运行的模块，可以用以下语句：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306173957755.png" alt="image-20210306173957755">-</p>
<p><del><code>grep loadmodule httpd.conf</code></del></p>
<p>以下模块通常被激活而并无大用：</p>
<p>mod_imap, mod_include, mod_info, mod_userdir, mod_status, mod_cgi, mod_autoindex</p>
</li>
<li><p>从httpd.conf中清除默认的注释</p>
<p>Apache 2.2.4中默认的httpd.conf文件有400多行。在这400行中，只有一小部分是实际的Apache指令，其余的仅是帮助用户如何恰当地在httpd.conf中放置指令的注释。完全清除多余的注释。文件变得更加容易阅读</p>
</li>
<li><p>Listen指令具体化</p>
<p>在第一次安装Apache时，httpd.conf包含一个“Listen 80”指令。应将其改变为“Listen mn.xx.yy.zz:80”，在这里“mn.xx.yy.zz”是你想让Apache监听其请求的IP地址。如果你的Apache运行在一个拥有多个IP地址的服务器上时，这一点尤其重要。如果你不采取预防措施，默认的“Listen 80”指令告诉Apache监听每一个IP地址的80端口</p>
<p><img src="/2021/08/25/16-07-33/image-20210306180257025.png" alt="image-20210306180257025">-</p>
</li>
</ul>
</li>
<li><p>Apache配置基于域名的虚拟主机</p>
<p>基于域名的虚拟主机可以看看下面的DNS然后配置一下，或者简单一点直接修改**/etc/hosts文件**：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306202458753.png" alt="image-20210306202458753">-</p>
<p>注意上面犯了两个错误：IP地址应该写前面，不要加端口号</p>
<p>然后创建站点主目录及首页文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306200233038.png" alt="image-20210306200233038">-</p>
<p>创建文件夹后，需要将将bbschen的所有者改为apache</p>
<p>编辑apache主配置文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306202649075.png" alt="image-20210306202649075">-</p>
<p>直接下载查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306204957955.png" alt="image-20210306204957955">-</p>
<p>下面创建虚拟目录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306210811964.png" alt="image-20210306210811964">-</p>
<p>直接下载查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210306210740219.png" alt="image-20210306210740219">-</p>
<!--请注意上面的目录是 /haha！--></li>
<li><p>Apache的解析漏洞</p>
<p><strong>原理</strong>：Apache文件解析漏洞与用户的配置有密切的关系，严格来说<strong>属于用户配置问题</strong>。Apache文件解析漏洞涉及到一个解析文件的特性。Apache默认一个文件可以有多个以点.分割的后缀，当右边的后缀无法识别，则继续向左识别，发现后缀是php,交个php处理这个文件。</p>
<p><strong>例如</strong>：在Apache中，访问：liuwx.php.360会从右往左识别后缀，存在解析漏洞的时候，会<strong>从右往左识别</strong>哪个能解析，360是不能被解析，然后往左识别到php就识别能解析，这就是Apache的解析漏洞</p>
</li>
<li><p>–</p>
</li>
</ol>
<h4 id="2、LTMJ平台的搭建"><a href="#2、LTMJ平台的搭建" class="headerlink" title="2、LTMJ平台的搭建"></a>2、LTMJ平台的搭建</h4><p><strong>LTMJ = Linux + Tomcat + Mysql + Java</strong></p>
<p>1、安装软件</p>
<ol>
<li><p>安装汤姆凯特</p>
</li>
<li><p>安装MariaDB</p>
</li>
<li><p>安装JDK</p>
<p>首先查看自己的机器上是否已经自带openjdk，有的话就需要删：</p>
<p><img src="/2021/08/25/16-07-33/image-20210312202418632.png" alt="image-20210312202418632">-</p>
<p>我这个系统没有JDK，所有直接去官网下载tar.gz的包</p>
</li>
</ol>
<p>2、环境配置</p>
<p>3、上传网站</p>
<p>4、访问网站</p>
<h2 id="第十八章-负载均衡集群"><a href="#第十八章-负载均衡集群" class="headerlink" title="第十八章 负载均衡集群"></a>第十八章 负载均衡集群</h2><h3 id="1、集群分类"><a href="#1、集群分类" class="headerlink" title="1、集群分类"></a>1、集群分类</h3><p>​    无论是哪种群集，都至少包括两台节点服务器，而对外表现为一个整体，只提供一个访问入口(域名或IP地址），相当于一台大型计算机。根据群集所针对的目标差异可分为以下三种类型。</p>
<p>​    <strong>负载均衡群集LB （Load Balance Clustcr）:<strong>以提高应用系统的响应能力、尽可能负载均衡群集 （Load Balance Clustcr）:以提高应用系统的响应能力、尽可能处理更多的访问请求、减少延迟为目标，获得高并发、高负载(LB)的整体性能。例如，“DNS轮询”“应用层交换”“反向代理”等都可用作负载均衡群集。LB的负载分配依赖于主节点的</strong>分流算法，将来自客户机的访问请求分担给多个服务器节点，从而缓解整个系统的负载压力。</strong></p>
<p>​    <strong>高可用群集High Availability Cluster）:<strong>以提高应用系统的可靠性、尽可能地减少中断时间为目标，确保服务的连续性，达到高可用(HA）的容错效果。例如，“故障切换”“双机热备”“多机热备”等都属于高可用群集技术。HA 的工作方式包括</strong>双工和主从两种模式</strong>。<strong>双工即所有节点同时在线:主从则只有主节点在线，但当出现故障时从节点能自动切换为主节点。</strong></p>
<p>​    <strong>高性能运算群集（High Performance Computer Cluster）：</strong>以提高应用系统的CPU运速度、扩展硬件资源和分析能力为目标，获得相当于大型、超级计算机的高性能运算（HCP）能力。例如“云计算”“网络计算机”也可视为高性能运算的一种。高性能运算群集的同性能依赖于“分布式运算”和“并行计算”，通过专用硬件和软件将多个服务器的CPU、内存等资源整合在一起，实现只有大型、超级计算机才具备的计算能力。</p>
<p>​    不同类型的群集在必要时可以合并，如高可用的负载均衡群集。</p>
<h3 id="2、负载均衡群集的分成结构"><a href="#2、负载均衡群集的分成结构" class="headerlink" title="2、负载均衡群集的分成结构"></a>2、负载均衡群集的分成结构</h3><p>​    在典型的负表均衡群集中，包括三个层次的组件。前端至少有一个负载调度器(Load Balancer，或称为 Director)负责响应并分发来自客户机的访问请求。后端由大量的真实服务器（Rcal Scrver)构成服务器池(Scrver Pool)，提供实际的应用服务，整个群集的伸缩性通过增加、删除服务器节点来完成，而这些过程对客户机是透明的；为了保持服务的一致性，所有节点使用共享存储设备。</p>
<p>​    **第一层，负载调度器:**这是访问整个群集系统的唯一入口.对外使用所有服务器共有的VIP（Virtual IP，虚拟IP）地址，也称为群集IP地址。通常会配置主、备两台调度器实现热备份，当主调度器失效以后平滑替换至备用调度器，确保高可用性。</p>
<p>​    **第二层，服务器池:**群集所提供的应用服务（如HTTP、FIP）由服务器池承担，其中的每个节点其有独立的RIP(RealIP，真实IP）地址，只处理调度器分发过来的客户机请求。当某个节点暂时失效时，负载调度器的容错机制会将其隔离，等待错误排除以后再重新纳入展务器池。</p>
<p>​    <strong>第三层，共享存储：</strong> 为服务器池中的所有节点提供稳定，一致的文件存取服务。确保整个群集的统一性。在Linux/UNIX环境中，共享存储可以使用NAS设备，或者提供 NFSNetwork File System.网络文件系能&gt;共享服务的专用服务器。</p>
<h3 id="3、负载均衡群集的工作模式"><a href="#3、负载均衡群集的工作模式" class="headerlink" title="3、负载均衡群集的工作模式"></a>3、负载均衡群集的工作模式</h3><p>​    关于群集的负载调度技术，可以基于<strong>IP、端口、内容</strong>等进行分发，其中基于IP的负载调度是效率最高的。<strong>基于IP的负载均衡模式中，常见的有地址转换、IP隧道和直接路由三种模式</strong>。</p>
<p>​    <strong>地址转换（Network Address Translation）：</strong>简称NAT模式，类似于防火墙的私有网络结构，负载调度器作为所有服务器节点的网关，即作为客户机的访问入口，也是各节点回应客户机的访问出口。服务器节点使用私有IP地址，与负载调度器位于同一物理网络，安全性要优于其他两种方式。</p>
<p>​    **IP隧道（IP Runnel）:**简称TUN模式，采用开放式的网络结构，负载调度器仅作为客户机的访问入口，各节点通过各自的Internet连接直接回应客户机，而不再经过负载调度器。服务器节点分散在互联网中的不同位置，具有独立的公网IP地址，通过专用IP隧道与负载调度器相互通信。</p>
<p>​    **直接路由（Direct Routing）:**简称DR模式，采用半开放式的网络结构，与TUN模式的结构类似，但各节点并不是分散在各地，而是与调度器位于同一物理网络。负载调度器与各节点服务器通过本地网络连接，不需要建立专用的IP隧道。</p>
<p>​    三种工作模式，NAT方式只需要一个公网IP地址，从而成为最易用的一种负载均衡模式，安全性也比较好，许多硬件负载均衡设备就是采用这种方式；相比较而言，DR和TUN模式的负载能力更加强大、适用范围更广，但节点的安全性要稍差一些。</p>
<h3 id="4、实现负载均衡的方法"><a href="#4、实现负载均衡的方法" class="headerlink" title="4、实现负载均衡的方法"></a>4、实现负载均衡的方法</h3><p>关于网站架构比较合理设计的架构方案：即<strong>Nginx/HAProxy+Keepalived</strong>做Web最前端的负载均衡器，后端的Mysql架构采用一主多从，读写分离的方式，采用<strong>LVS+Keepalived</strong>的方式。</p>
<h4 id="4-1、LVS"><a href="#4-1、LVS" class="headerlink" title="4.1、LVS"></a>4.1、LVS</h4><p>​    Linux Virtual Server（LVS）是针对Linux内核开发的一个负载均衡项目，由我国的章文嵩博士在1998年5月创建，官方站点位于<a href="http://www.linuxvirtualserver.org/%E3%80%82LVS%E5%AE%9E%E9%99%85%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%9F%BA%E4%BA%8EIP%E8%99%9A%E6%8B%9F%E5%8C%96%E5%BA%94%E7%94%A8%EF%BC%8C%E4%B8%BA%E5%9F%BA%E4%BA%8EIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%86%85%E5%AE%B9%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8F%90%E5%87%BA%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E3%80%82LVS%E7%8E%B0%E5%9C%A8%E5%B7%B2%E6%88%90%E4%B8%BALinux%E5%86%85%E6%A0%B8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%BC%96%E8%AF%91%E4%B8%BAip_vs%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%BF%85%E8%A6%81%E6%97%B6%E8%83%BD%E5%A4%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E3%80%82">http://www.linuxvirtualserver.org/。LVS实际上相当于基于IP虚拟化应用，为基于IP地址和内容请求分发的负载均衡提出一种高效的解决方法。LVS现在已成为Linux内核的一部分，默认编译为ip_vs模块，必要时能够自动调用。</a></p>
<h5 id="4-1-1-特点"><a href="#4-1-1-特点" class="headerlink" title="4.1.1 特点"></a>4.1.1 特点</h5><ol>
<li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的；</li>
<li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率；</li>
<li>工作稳定，自身有完整的双机热备方案，如LVS+Keepalived和LVS+<a href="http://www.linuxde.net/tag/heartbeat">Heartbeat</a>，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived；</li>
<li>无流量，保证了均衡器<a href="http://www.linuxde.net/tag/io">IO</a>的性能不会收到大流量的影响；</li>
<li>应用范围比较广，可以对所有应用做负载均衡；</li>
<li>软件本身不支持正则处理，不能做动静分离，这个就比较遗憾了；其实现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li>
<li>如果是网站应用比较庞大的话，实施LVS/DR+Keepalived起来就比较复杂了，特别后面有<a href="http://www.linuxde.net/tag/windows">Windows</a> Server应用的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li>
</ol>
<h5 id="4-1-2-负载调度算法"><a href="#4-1-2-负载调度算法" class="headerlink" title="4.1.2 负载调度算法"></a>4.1.2 负载调度算法</h5><p>​    针对不同的网络服务和配置需要，LVS调度器提供多种不同的负载调度算法，其中最常用的四种算法包括轮询、加权轮询、最少连接和加权最少连接。</p>
<p>​    <strong>轮询（Round Robn）：</strong>将收到的访问请求按照顺序轮流分配给群集中的各节点（真实服务器）,均等地对待每一台服务器，而不管服务器实际的连接数和系统负载。</p>
<p>​    <strong>加权轮询（Weihted Round Robin）：</strong>根据真实服务器的处理能力轮流分配收到的访问请求，调度器可以自动查询各节点的负载情况 ，并动态调整其权重。这样可以保证处理能力强的服务器承担更多的访问流量。</p>
<p>​    <strong>最少连接（Least Connections）：</strong>根据真实服务器已建立的连接数进行分配，将收到的访问请求优先分配给连接数最少的节点。如果所有的服务器节点性能相近，采用这种方式可以更好地均衡负载。</p>
<p>​    <strong>加权最少连接（Weihted Least Connections）：</strong>在服务器节点的性能差异较大的情况下，可以为真实服务器自动调整权重，权重较高的节点将承担更大比例的活动连接负载。</p>
<h5 id="4-1-3-使用ipvsadm工具"><a href="#4-1-3-使用ipvsadm工具" class="headerlink" title="4.1.3 使用ipvsadm工具"></a>4.1.3 使用ipvsadm工具</h5><p>​    <strong>ipvsadm是</strong>在负载调度器上使用的<strong>LVS群集管理工具</strong>，通过调用<strong>ip_vs模块</strong>来添加、删除服务器节点，以及查看群集的运行状态。在CentOS7系统中，需要手动安装ipvsdm软件包。LVS群集的管理工作主要包括<strong>建虚拟服务器</strong>，添加服务器节点，查看群集节点状态、删除服务器节点和保存负载分配策略。</p>
<p><strong>实验环境</strong>：在虚拟机中天机4台centos7</p>
<p><strong>实验配置流程</strong>：</p>
<p>1、添加的这4台各司其职，其中一台作为lvs，另外三台作为web服务器。</p>
<p>2、给lvs添加第二张网卡（需要设置为lan1），作为三台web的网关（lan1）</p>
<!--注意：三台服务器先把脚本传过去在设置为lan1，不然没有IP地址，传不了脚本啊！！-->

<p>3、防火墙配置，将三台web防火墙的http服务打开，关掉selinux，然后把主lvs中的firewall停掉，并安装iptables，然后配置两项，一是主lvs两张网卡之间的联通，这里主要是用到了SNAT进行端口转发，二是开启http服务（80端口）</p>
<p>4、配置LVS实现轮询负载均衡：将主lvs设置为群集VIP地址，然后再去添加子节点（web节点）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ---------3台web虚拟机专属配置---------------</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line">mkdir /etc/yum.repos.d/bak</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">mount /dev/sr0 /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /etc/yum.repos.d/dvd.repo</span></span><br><span class="line"><span class="string">[dvd]</span></span><br><span class="line"><span class="string">name=centos7</span></span><br><span class="line"><span class="string">baseurl=file:///mnt/cdrom</span></span><br><span class="line"><span class="string">enable=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># 防火墙开启http服务</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=http &amp;&gt; /dev/null</span><br><span class="line">firewall-cmd --reload &amp;&gt; /dev/null</span><br><span class="line"><span class="comment"># 把 selinux 安全机制关了</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ENS1=`ip maddr | grep ens | awk <span class="string">&#x27;NR==2&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">IP_CONF=/etc/sysconfig/network-scripts/ifcfg-<span class="variable">$&#123;ENS1&#125;</span></span><br><span class="line"><span class="comment"># 删除UUID，并配置静态IP地址</span></span><br><span class="line">sed -i <span class="string">&#x27;/^UUID/d&#x27;</span> <span class="variable">$&#123;IP_CONF&#125;</span></span><br><span class="line"><span class="comment"># 修改BOOTPROTO为static</span></span><br><span class="line">sed -i <span class="string">&#x27;/^BOOTPROTO/s/dhcp/static/g&#x27;</span> <span class="variable">$&#123;IP_CONF&#125;</span></span><br><span class="line"><span class="comment"># 添加静态IP地址、网关、子网掩码</span></span><br><span class="line"><span class="comment"># 静态IP地址用 ‘date +%S’来获取，date +%S 是秒，一共60秒</span></span><br><span class="line">IP_4=`date +%S`</span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt;&gt; $&#123;IP_CONF&#125;</span></span><br><span class="line"><span class="string">IPADDR=192.168.10.$&#123;IP_4&#125;</span></span><br><span class="line"><span class="string"># 注意这里的网关地址，一定是LVS服务器上的一块网卡的地址</span></span><br><span class="line"><span class="string"># 所以要先去LVS服务器上添加一块网卡，然后将这块网卡放到LAN网段1（LAN网段1是手动添加的）</span></span><br><span class="line"><span class="string"># 然后先手动给这块网卡添加静态IP地址等，然后再来这里填写</span></span><br><span class="line"><span class="string"># 不一定是254，但一定是在同一个网段</span></span><br><span class="line"><span class="string">GATEWAY=192.168.10.211</span></span><br><span class="line"><span class="string">NETMASK=255.255.255.0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 重启网卡</span></span><br><span class="line">ifdown <span class="variable">$&#123;ENS1&#125;</span></span><br><span class="line">ifup <span class="variable">$&#123;ENS1&#125;</span></span><br><span class="line">systemctl restart network.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------</span></span><br><span class="line"><span class="comment"># 判断是否安装httpd</span></span><br><span class="line">rpm -qa | grep <span class="string">&quot;httpd&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! $? -eq 0  ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  yum install -y httpd  &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 软件已安装，请去确认配置文件是否已经被修改！ \033[0m&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看80端口是否被占用：netstat -lanpt | grep 80</span></span><br><span class="line">yum install -y net-tools &amp;&gt; /dev/null</span><br><span class="line">SER_NAME=`netstat -lanpt | grep :80 | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> | awk -F/ <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="comment"># 如果端口被占用，就把对应服务停掉</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="variable">$&#123;SER_NAME&#125;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  SER_ID=`ps -aux | grep <span class="variable">$&#123;SER_NAME&#125;</span> | awk <span class="string">&#x27;NR==1 &#123;print $2&#125;&#x27;</span>`</span><br><span class="line">  <span class="built_in">kill</span> - 9 <span class="variable">$&#123;SER_ID&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 httpd 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"><span class="comment"># 启动 httpd 服务</span></span><br><span class="line">systemctl start httpd</span><br><span class="line"><span class="keyword">if</span> [ ! $? ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 启动 httpd 服务失败, 退出</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 启动失败，请自行查找其它原因！ \033[0m&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 fortune，产生一段随机文本内容</span></span><br><span class="line"><span class="comment">#wget http://springdale.princeton.edu/data/springdale/7/x86_64/os/Addons/Packages/fortune-mod-1.99.1-17.sdl7.x86_64.rpm  &amp;&gt; /dev/null</span></span><br><span class="line"><span class="comment">#wget http://mirror.centos.org/centos/7/os/x86_64/Packages/recode-3.6-38.el7.x86_64.rpm  &amp;&gt; /dev/null</span></span><br><span class="line"><span class="comment">#yum install -y recode-3.6-38.el7.x86_64.rpm  &amp;&gt; /dev/null</span></span><br><span class="line"><span class="comment">#rpm -i fortune-mod-1.99.1-17.sdl7.x86_64.rpm  &amp;&gt; /dev/null</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#WORDS=`fortune`</span></span><br><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /var/www/html/index.html</span></span><br><span class="line"><span class="string">#$&#123;WORDS&#125;</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">$$</span></span><br><span class="line"><span class="string">$0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 httpd 服务</span></span><br><span class="line">systemctl restart httpd &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;部署apache成功！&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;部署apache失败！&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#------------配置结束------------------</span></span><br></pre></td></tr></table></figure>

<p>主服务器需要添加两张网卡，一个作为3台web的网关（ens37），一个作为外网访问的接口地址（ens32）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------主LVS的配置-------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------</span></span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line">mkdir /etc/yum.repos.d/bak</span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">mount /dev/sr0 /mnt/cdrom &amp;&gt; /dev/null</span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/dvd.repo</span><br><span class="line">[dvd]</span><br><span class="line">name=centos7</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enable=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--------------IP配置------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一块网卡（手动在虚拟机中添加），然后为网卡设置静态IP地址</span></span><br><span class="line">ENS1=`ip maddr | grep ens | awk &#x27;NR==2&#123;print $1&#125;&#x27;`</span><br><span class="line">ENS2=`ip maddr | grep ens | awk &#x27;NR==2&#123;print $2&#125;&#x27;`</span><br><span class="line">IP_CONF_1=/etc/sysconfig/network-scripts/ifcfg-$&#123;ENS1&#125;</span><br><span class="line">IP_CONF_2=/etc/sysconfig/network-scripts/ifcfg-$&#123;ENS2&#125;</span><br><span class="line">rm -rf $&#123;IP_CONF_2&#125;</span><br><span class="line">cp $&#123;IP_CONF_1&#125; $&#123;IP_CONF_2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除UUID，并配置静态IP地址</span></span><br><span class="line">sed -i &#x27;/^UUID/d&#x27; $&#123;IP_CONF_2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改BOOTPROTO为static</span></span><br><span class="line">sed -i &#x27;/^BOOTPROTO/s/dhcp/static/g&#x27; $&#123;IP_CONF_2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 本来是单引号，但是替换的是变量，所以需要用双引号</span></span></span><br><span class="line">sed -i &quot;/^NAME/s/$&#123;ENS1&#125;/$&#123;ENS2&#125;/g&quot; $&#123;IP_CONF_2&#125;</span><br><span class="line">sed -i &quot;/^DEVICE/s/$&#123;ENS1&#125;/$&#123;ENS2&#125;/g&quot; $&#123;IP_CONF_2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加静态IP地址、网关、子网掩码</span></span><br><span class="line">cat &lt;&lt; EOF &gt;&gt; $&#123;IP_CONF_2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 网关不一定是254，也可以是其它的</span></span><br><span class="line">RAND_=`date +%S`</span><br><span class="line">GT=`expr $&#123;RAND_&#125; \* 2`</span><br><span class="line">IPADDR=192.168.10.$&#123;GT&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面的意思就是网关就是本机</span></span><br><span class="line">GATEWAY=192.168.10.$&#123;GT&#125;</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启网卡</span></span><br><span class="line">ifdown $&#123;ENS2&#125;</span><br><span class="line">ifup $&#123;ENS2&#125;</span><br><span class="line">systemctl restart network.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------IP配置结束---------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------安装 httpd-------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y httpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start httpd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">---------------防火墙配置---------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭firewalld，然后安装并配置iptables，允许SNAT，允许http服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里要做的就是，打通LVS上的两张网卡的联通（通过SNAT），ens32到ens33之间，这样就能通过本机Windows访问LVS（ens32），进而通过网关（ens34）去访问web服务器了</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld  &amp;&gt; /dev/null</span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装iptables</span></span><br><span class="line">yum install -y iptables-services &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">systemctl start iptables</span></span><br><span class="line"><span class="meta">#</span><span class="bash">再设置开机启动iptables：`systemctl <span class="built_in">enable</span> iptables`</span></span><br><span class="line"><span class="meta">#</span><span class="bash">打开iptables：`systemctl start iptables`</span></span><br><span class="line"><span class="meta">#</span><span class="bash">保存设置：`service iptables save`</span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启iptables服务：`service iptables restart` || `systemctl restart iptables`</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># to-source 后面跟 ens32 的IP地址</span></span></span><br><span class="line">ENS32_IP=`ip addr | grep $&#123;ENS1&#125; | grep inet | awk &#x27;&#123;print $2&#125;&#x27; | awk -F/ &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">echo &quot;ENS32_IP: $&#123;ENS32_IP&#125;&quot;</span><br><span class="line">ENS33_IP=`ip addr | grep $&#123;ENS2&#125; | grep inet | awk &#x27;&#123;print $2&#125;&#x27; | awk -F/ &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">echo &quot;ENS33_IP: $&#123;ENS33_IP&#125;&quot;</span><br><span class="line"></span><br><span class="line">iptables -I INPUT -d $&#123;ENS32_IP&#125; -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables ??? 允许所有转发</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -j ACCEPT</span><br><span class="line">iptables -t nat -I POSTROUTING  -s $&#123;ENS33_IP&#125; -o $&#123;ENS2&#125; -j SNAT --to-source $&#123;ENS32_IP&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许转发</span></span><br><span class="line">echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存 iptables 的设置</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 iptables</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="meta">#</span><span class="bash">--------------防火墙配置结束-----------------------</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------ipvsadm配置------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 ipvsadm</span></span><br><span class="line">yum install -y ipvsadm &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ipvsadm -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建虚拟服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 群集 VIP 地址为 ENS32_IP ，针对tcp 80端口提供负载分流服务，使用的调度算法为轮询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 VIP 地址必须是服务器实际启用的IP地址</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意这里的IP地址添加进去后，显示为localhost，iP地址修改后，这里也需要改！！！目前只能手动改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 终于找到了问题得所在，不是代码没有执行，是第一次添加的是localhost</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们需要的是第二次添加的localhost.localdomain</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以先随便添加一条，让服务启动起来，一定要让服务启动，然后再添加第二条正确的</span></span><br><span class="line">ipvsadm -A -t $&#123;ENS32_IP&#125;:80 -s rr</span><br><span class="line">ipvsadm-save &gt; /etc/sysconfig/ipvsadm</span><br><span class="line">systemctl start ipvsadm</span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------------------------</span></span><br><span class="line"></span><br><span class="line">ipvsadm -A -t $&#123;ENS32_IP&#125;:80 -s rr</span><br><span class="line"><span class="meta">#</span><span class="bash"> ipvsadm -A -t 192.168.2.95:80 -s rr</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加服务器节点，web地址看来只能手写了，不然只能用nmap扫描</span></span><br><span class="line">yum install -y nmap &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">SON_IPS=`nmap -sP 192.168.10.* | grep &quot;Nmap scan report for&quot; | awk &#x27;&#123;print $5&#125;&#x27;`</span><br><span class="line">FOR_NUM=`echo $&#123;SON_IPS&#125; | wc -l`</span><br><span class="line">for((i=1; i&lt;=$&#123;FOR_NUM&#125;; i++))</span><br><span class="line">do</span><br><span class="line">  NOW_IP=`echo $&#123;SON_IPS&#125; | awk &#x27;NR==$&#123;i&#125;&#x27;`</span><br><span class="line">  FOUR_NUM=`echo $&#123;NOW_IP&#125; | awk -F. &#x27;&#123;print $4&#125;&#x27;`</span><br><span class="line">  if [ $&#123;FOUR_NUM&#125; -gt 100 ] </span><br><span class="line">  then</span><br><span class="line">    continue</span><br><span class="line">  else</span><br><span class="line">    ipvsadm -a -t $&#123;ENS32_IP&#125;:80 -r $&#123;NOW_IP&#125;:80 -m -w 1</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存负载分配策略</span></span><br><span class="line">ipvsadm-save &gt; /etc/sysconfig/ipvsadm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务（重建规则）</span></span><br><span class="line">systemctl restart ipvsadm</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># -------------ipvsadm配置结束------------------</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------配置keeplived------------------</span></span><br><span class="line">mv /etc/yum.repos.d/bak /etc/yum.repos.d/</span><br><span class="line">mv /etc/yum.repos.d/dvd.repo /etc/yum.repos.d/bak/</span><br><span class="line">yum install -y kernet-devel openssl-devel popt-devel keepalived &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">KEEPLIVED_CONF=/etc/keepalived/keepalived.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如ip地址为192.168.2.1，下面这句的意思是截取192.168.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;ENS32_IP%.*&#125;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据文件名来判断谁是Mater</span></span><br><span class="line">FLAG=1</span><br><span class="line">case $0 in</span><br><span class="line">&quot;lvs1&quot;)</span><br><span class="line">FLAG=&quot;MASTER&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">FLAG=&quot;BAKUP&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; $&#123;KEEPLIVED_CONF&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">----------------------------</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id  test_R1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state $&#123;FLAG&#125;</span><br><span class="line">    interface $&#123;ENS1&#125;</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 跟外网接口地址在一个网段</span></span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line"><span class="meta">   $</span><span class="bash">&#123;ENS32_IP%.*&#125;.212</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">----------------------------</span></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state $&#123;FLAG&#125;</span><br><span class="line">    interface $&#123;ENS2&#125;</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 跟内网接口地址在一个网段</span></span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">    $&#123;ENS33_IP%.*&#125;.211</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------keeplived配置结束------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------脚本结束---------------------------</span></span><br></pre></td></tr></table></figure>



<h4 id="4-2、Nginx"><a href="#4-2、Nginx" class="headerlink" title="4.2、Nginx"></a>4.2、Nginx</h4><ol>
<li>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是许多朋友喜欢它的原因之一；</li>
<li>Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势所在；</li>
<li>Nginx安装和配置比较简单，测试起来比较方便；</li>
<li>也可以承担高的负载压力且稳定，一般能支撑超过几万次的并发量；</li>
<li>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测；</li>
<li>Nginx仅能支持http和Email，这样就在适用范围上面小很多，这个它的弱势；</li>
<li>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。<a href="http://www.linuxde.net/tag/lnmp">LNMP</a>现在也是非常流行的web架构，大有和以前最流行的<a href="http://www.linuxde.net/tag/lamp">LAMP</a>架构分庭抗争之势，在高流量的环境中也有很好的效果。</li>
<li>Nginx现在作为Web反向加速缓存越来越成熟了，很多朋友都已在生产环境下投入生产了，而且反映效果不错，速度比传统的Squid服务器更快，有兴趣的朋友可以考虑用其作为反向代理加速器。</li>
</ol>
<h4 id="4-3、HAProxy"><a href="#4-3、HAProxy" class="headerlink" title="4.3、HAProxy"></a>4.3、HAProxy</h4><ol>
<li>HAProxy是支持虚拟主机的，以前有朋友说这个不支持虚拟主机，我这里特此更正一下。</li>
<li>能够补充Nginx的一些缺点比如Session的保持，Cookie的引导等工作</li>
<li>支持url检测后端的服务器出问题的检测会有很好的帮助。</li>
<li>它跟LVS一样，本身仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li>
<li>HAProxy可以对Mysql读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，不过在后端的MySQL slaves数量超过10台时性能不如LVS，所以我向大家推荐LVS+Keepalived。</li>
<li>HAProxy的算法现在也越来越多了，具体有如下8种：<br>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</li>
</ol>
<h2 id="第十九章-DNS-服务器"><a href="#第十九章-DNS-服务器" class="headerlink" title="第十九章 DNS 服务器"></a>第十九章 DNS 服务器</h2><p>​    在第十七章中的配置多个静态网站时，我们修改的是hosts文件，正确的应该是配置一个DNS服务器，那么接下来就来配置一个DNS服务器</p>
<p>​    DNS的作用也不用多说，用于域名解析，将域名解析成IP地址</p>
<p>​    DNS默认的端口：<strong>tcp/53、udp/53</strong></p>
<p>​    主机记录（<strong>A</strong>）记录：主机名和IP地址的对应关系</p>
<p>​        <strong>A         ：IPv4的地址</strong></p>
<p>​        <strong>AAAA  ：IPv6的地址</strong></p>
<p>​    起始授权机构（<strong>SOA</strong>）记录：记录名称服务器和管理名称服务器的电子邮箱</p>
<p>​    名称服务器（<strong>NS</strong>）记录：记录管辖此区域的名称服务器</p>
<p>​    别名（<strong>CNAME</strong>）记录：</p>
<p>​    邮件交换记录（<strong>MX</strong>）：根据收信人地址的后缀名来定们邮件服务器。</p>
<p>​    <strong>MX  10   10</strong>：代表优先级，范围0-65535，值越低优先级越高</p>
<p>​    <strong>PTR</strong>：反向指针记录</p>
<p>​    <strong>搭建DNS服务器的步骤</strong>：</p>
<ol>
<li><p>安装DNS服务</p>
<p><code>yum install -y bind</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304195305787.png" alt="image-20210304195305787">-</p>
<p>DNS服务名是：<strong>named.service</strong></p>
<p>启动服务：systemctl start named.service</p>
<p>设置自启动：systemctl enable named.service</p>
<p>DNS的主配置文件在 <strong>/etc/named.conf</strong>（主要配置**<u>域名</u><strong>，也就是</strong>区域**）</p>
<p>DNS的区域配置文件在 <strong>/var/named/</strong> (根据<strong>主配置文件</strong>手动生成，做<strong>DNS记录</strong>）</p>
</li>
<li><p>配置DNS服务器</p>
<p>以 <a href="http://www.examchenchen.com/">www.examchenchen.com</a> 和 <a href="http://www.hrchenchen.com/">www.hrchenchen.com</a> 为例</p>
<p>编辑主配置文件：<code>vim /etc/named.conf</code></p>
<p>在文件末尾添加加载辅助区域文件的内容：**include “/etc/named.rfc1912.zones”**，若有就不用管</p>
<p>在 <strong>/var/named/named.ca</strong> 文件中写有关于全球那13台根域名服务器的IP地址：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304202210698.png" alt="image-20210304202210698">-</p>
<p>编辑 <strong>/etc/named.rfc1912.zones</strong> 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304202408098.png" alt="image-20210304202408098">-</p>
<p>红方框上面的为正向区域（通过域名找IP），下面则为反向区域（通过IP找域名）</p>
<p>现在需要在正向区域中，新增两个<u>区域（域名）</u>：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304202633698.png" alt="image-20210304202633698">-</p>
<!--hint为根域，master为主要区域，slave为备份区域-->

<p>现在需要单独为两个创建<strong>区域配置文件</strong>（自己手动创建）：</p>
<p>先进入 /var/named/ 目录，然后：<code>cp named.localhost exam.com.zone</code> 和<code>cp named.localhost hr.com.zone</code> </p>
<p>再来编辑这个 exam.com.zone 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304203416966.png" alt="image-20210304203416966">-</p>
<p>TTL表示时间，1D表示1天（1 day）</p>
<p>@ 表示本区域，SOA记录，不懂往上翻（记录<strong>名称服务器</strong>和管理名称服务器的<strong>电子邮箱</strong>）</p>
<p><img src="/2021/08/25/16-07-33/image-20210304210426243.png" alt="image-20210304210426243">-</p>
<p>这是最终版本</p>
<p>0表示序列号，1D、1H、1W、3H都表示时间</p>
<p>NS 表示记录管辖此区域的<strong>名称服务器</strong>，也就是<strong>域名服务器</strong>，写为 dns.examchenchen.com. ，但是前面的dns代表一个主机，下面的这一行就指出dns代表的这个主机指的就是本机</p>
<p>dns A 192.68.30.135 表示添加一个域名服务器</p>
<p>www A 192.68.30.135 表示添加一个www服务器（也代表www服务器指的主机也是本机）</p>
<p>然后保存退出，然后 ll 可以看到：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304210132940.png" alt="image-20210304210132940">-</p>
<p>因为当我们进行域名查询的时候都是以named这个用户的身份来进行查询的（要有读取的权限），所以需要将 examchenchen.com.zone 这个文件的所属组改为named</p>
<p><img src="/2021/08/25/16-07-33/image-20210304210224163.png" alt="image-20210304210224163">-</p>
<p>同理在这个文件夹下配置 <strong>hrchenchen.com.zone</strong> 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304210457927.png" alt="image-20210304210457927">-</p>
</li>
<li><p>重启服务：<code>systemctl restart named</code></p>
</li>
<li><p>如果配置出错了，那么进行检查：<code>named-checkconf</code></p>
</li>
<li><p>配置<strong>客户端DNS</strong>：</p>
<p><code>cat /etc/resolv.conf</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304211021708.png" alt="image-20210304211021708">-</p>
<p>说明现在的<strong>域名服务器</strong>的IP地址是：<strong>192.168.30.2</strong></p>
<p>现在编辑这个 /etc/resolv.conf 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304212002662.png" alt="image-20210304212002662">-</p>
<p>解释一下这个文件/etc/resolv.conf ：</p>
<p>文件内容格式：<code>nameserver 指定 DNS 服务器的 IP 地址</code></p>
<p>最多可同时指定 3 个 DNS 服务器的 IP 地址</p>
<p>根据 nameserver 的配置顺序决定搜索。可以使用 domain 来指定当前主机所在域的域名。</p>
<p>为 避 免 /etc/resolv.conf 文 件 的 内 容 被 系 统 修 改 或 覆 盖 ， 需 要 修 改</p>
<p><strong>/etc/NetworkManager/NetworkManager.conf</strong> 文件，在 main 部分添加“<strong>dns=none</strong>”选项。</p>
<p><img src="/2021/08/25/16-07-33/image-20210305152404836.png" alt="image-20210305152404836">-</p>
<p>修改后的内容如下：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305152450628.png" alt="image-20210305152450628">-</p>
<p>重新装载 NetworkManager 的配置，此时客户端域名解析服务器设置完成：</p>
<p><code>systemctl restart NetworkManager.service</code></p>
<p>然后使用nslookup：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304211945867.png" alt="image-20210304211945867">-</p>
</li>
<li><p>注意如果启动了防火墙，则需要关闭，注意上面在hosts中加入了两行，现在需要去掉</p>
</li>
<li><p>然后使用wget，发现hrchenchen这个配置错误了，现在需要排错！</p>
<p><img src="/2021/08/25/16-07-33/image-20210304212639793.png" alt="image-20210304212639793">-</p>
<p>原因是没有该这个文件的权限！！！</p>
<p><img src="/2021/08/25/16-07-33/image-20210304212745120.png" alt="image-20210304212745120">-</p>
<p>成功了！</p>
</li>
</ol>
<h2 id="第二十章-DHCP-服务器"><a href="#第二十章-DHCP-服务器" class="headerlink" title="第二十章 DHCP 服务器"></a>第二十章 DHCP 服务器</h2><p>​    DHCP（Dynamic Host Configuration Protocol动态主机配置协议）提供了动态配置 IP 地 址的功能</p>
<p>​    DHCP的端口：<strong>UDP /67 UDP/68</strong>，默认租约时间为8天</p>
<p>​    DHCP服务名是：<strong>dhcpd</strong></p>
<p>​    DHCP服务器的搭建：</p>
<p>​    1、安装DHCP：<code>yum install -y dhcp</code></p>
<p>​    <img src="/2021/08/25/16-07-33/image-20210304215012443.png" alt="image-20210304215012443">-</p>
<p>​    <!--这个原因是因为CentOS 8 依赖问题导致的，所以需要使用源码安装，自己手动解决依赖问题--></p>
<p>​    好像不是这个原因，应该安装：<strong>dhcp-client</strong> 和 <strong>dhcp-server</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210304215723678.png" alt="image-20210304215723678">-</p>
<p>​    教程：<a href="https://blog.csdn.net/shengjie87/article/details/107105205/">https://blog.csdn.net/shengjie87/article/details/107105205/</a></p>
<p>​    教程：<a href="https://blog.csdn.net/qq_26884501/article/details/112790519">https://blog.csdn.net/qq_26884501/article/details/112790519</a></p>
<p>​    一打开就报了个错：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304230208604.png" alt="image-20210304230208604">-</p>
<p>应该是端口被占用了，现在查看一下67和68端口情况：<code>netstat -lanpt | grep 67</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304230421548.png" alt="image-20210304230421548">-</p>
<p>竟然都没有问题，那又会是什么原因呢？</p>
<p>因为DHCP服务安装完成后配置文件**/etc/dhcp/dhcpd.conf**是空的，所以先编辑它，加入一些自己的数据信息必须的，下面编辑这个文件：</p>
<p>默认是这样的：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304230719097.png" alt="image-20210304230719097">-</p>
<p>此文件的模板在：<code>/usr/share/doc/dhcp-server/dhcpd.conf.example</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304231126106.png" alt="image-20210304231126106">-</p>
<p>复制这个非常基本的声明到 /etc/dhcp/dhcpd.conf 文件中去：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305083307961.png" alt="image-20210305083307961">-</p>
<p>注意：这个配置文件的位置是通过： <code>rpm -qc dhcp-server</code> 查看到的</p>
<p><img src="/2021/08/25/16-07-33/image-20210305081031777.png" alt="image-20210305081031777">-</p>
<p>配置完成以后可以检查一下是否配置正确：<code>dhcpd -t -cf /etc/dhcp/dhcpd.conf</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210305083928286.png" alt="image-20210305083928286">-</p>
<!--其中：subnet是子网号，netmask是子网掩码，range是分配IP地址的范围，option routers 是网关地址，下面那个是DNS地址-->

<p>保存后，即可启动dhcpd服务：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304232202606.png" alt="image-20210304232202606">-</p>
<p>测试DHCP服务器：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304233012934.png" alt="image-20210304233012934">-</p>
<!--为什么是ens33，这个需要使用ifconfig查看-->

<p>修改此配置文件中BOOTPROTO一项的值为“<strong>static</strong>”：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305083009970.png" alt="image-20210305083009970">-</p>
<p>因为后面将用CentOS作为DHCP服务器，作为DHCP服务器的主机必须有一个固定的ip地址</p>
<p>重启network：</p>
<p>要重启centos8的网卡，应先载入新的配置文件，然后在执行重启网卡命令即可</p>
<p>1、载入配置文件：<code>nmcli c reload</code></p>
<p>2、重启网卡：<code>nmcli d reapply ens33</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210304233426542.png" alt="image-20210304233426542">-</p>
<p>然后使用<strong>ifconfig</strong>命令查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210304233457941.png" alt="image-20210304233457941">-</p>
<p>发现IP地址<strong>并没有改变</strong>，原因是因为现在是在虚拟机环境下，还需要进行额外的配置：</p>
<p>打开XP系统，将CentOS 8 作为DHCP服务器，为XP系统自动分配IP地址：</p>
<p>将这两台虚拟机（XP和CentOS 8）的网卡都做<strong>仅主机模式</strong>，都绑定在<strong>vmnet1</strong>网卡上，虚拟机的网络配置里<strong>取消vmnet1网卡的dhcp功能</strong>，并且确保客户端XP系统是<strong>自动获取ip地址</strong>的：</p>
<p><img src="/2021/08/25/16-07-33/image-20210305081729726.png" alt="image-20210305081729726">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305082027253.png" alt="image-20210305082027253">-</p>
<!--取消使用本地DHCP服务前面的勾，下面的子网IP可任意改，但不能和WMnet8一样-->

<p><img src="/2021/08/25/16-07-33/image-20210305082250702.png" alt="image-20210305082250702">-</p>
<!--服务器CentOS和XP都配置网络为仅主机模式，绑定VMnet1网卡，形成一个局域网-->

<p><img src="/2021/08/25/16-07-33/image-20210305082513662.png" alt="image-20210305082513662">-</p>
<!--XP系统将这里设置为自动获取-->

<!--然后重启一下两个系统-->

<p><img src="/2021/08/25/16-07-33/image-20210305092110734.png" alt="image-20210305092110734">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210305091517818.png" alt="image-20210305091517818">-</p>
<p>成功！</p>
<h2 id="第二十一章-自动化运维"><a href="#第二十一章-自动化运维" class="headerlink" title="第二十一章 自动化运维"></a>第二十一章 自动化运维</h2><p>​    由于互联网的快速发展导致产品更新换代速度逐渐加快，运维人员每天都要进行大量的维护操作，仍旧按照传统方式进行维护使得工作效率低下。这时，部署自动化运维就可以尽可能安全，高效地完成这些工作。 一般会把自动化运维工具划分为<strong>两类</strong>：</p>
<p>​    一类是需要使用代理工具的，也就是基于专用的Agent程序来完成管理功能，如：Puppet、Func、<strong>Zabbix</strong>等；</p>
<p>​    另外一类是不需要配置代理工具的，可以直接基于SSH服务来完成管理功能，如：<strong>Ansible</strong>、Fabric等</p>
<h3 id="1、ansible服务"><a href="#1、ansible服务" class="headerlink" title="1、ansible服务"></a>1、ansible服务</h3><ol>
<li><p>ansible 概述</p>
<p>Ansible基于Python开发，集合了众多优秀运维工具的优点，实现了批量运行命令、部署程序、配置系统等功能。默认通过SSH协议进行远程命令执行或下发配置，无需部署任何客户端代理软件，从而使得自动化环境部署变得更加简单。可同时支持多台主机并行管理，使得管理主机更加便捷</p>
<table>
<thead>
<tr>
<th align="center"><strong>工具</strong></th>
<th align="center"><strong>开发语言</strong></th>
<th align="center"><strong>结构</strong></th>
<th align="center"><strong>配置文件格式</strong></th>
<th align="center"><strong>运行任务</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ansible</td>
<td align="center">Python</td>
<td align="center">无</td>
<td align="center">YAML</td>
<td align="center">执行命令行</td>
</tr>
</tbody></table>
</li>
<li><p>ansible 核心组件</p>
<p>Ansible可以看作是一种<strong>基于模块</strong>进行工作的框架结构，批量部署能力就是由Ansible所运行的模块实现的。简而言之Ansible是基于“模块”完成各种“任务”的</p>
<p><img src="/2021/08/25/16-07-33/image-20210318110740750.png" alt="image-20210318110740750">-</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ansible</td>
<td>Ansible核心程序</td>
</tr>
<tr>
<td>HostInventory</td>
<td>记录由Ansible管理的主机信息，包括端口、密码、ip等</td>
</tr>
<tr>
<td>Playbooks</td>
<td>“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能</td>
</tr>
<tr>
<td>CoreModules</td>
<td><strong>核心模块</strong>，主要操作是通过调用核心模块来完成管理任务</td>
</tr>
<tr>
<td>CustomModles</td>
<td>自定义模块，完成核心模块无法完成的功能，支持多种语言</td>
</tr>
<tr>
<td>ConnectionPlugins</td>
<td>连接插件，Ansible和Host通信使用</td>
</tr>
</tbody></table>
</li>
<li><p>安装ansible服务</p>
<ul>
<li><p>安装epel源：<code>yum install epel-release -y</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318111427937.png" alt="image-20210318111427937">-</p>
<p>安装完成后，在源目录下，会多出两个源！</p>
<!--注意：需要先安装这个源才能安装ansible--></li>
<li><p>安装ansible：<code>yum install ansible -y</code> </p>
<p><img src="/2021/08/25/16-07-33/image-20210318111601102.png" alt="image-20210318111601102">-</p>
<p>这里使用的是yum安装，就不用去手动解决上面那么多的依赖包的安装了，这里可以看到下载了YAML，这个类似于XML，用来写脚本用</p>
<p>查看版本信息：<code>ansible --version</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318111948650.png" alt="image-20210318111948650">-</p>
<!--使用 yum 都是安装的最新版本，但这里可以看到版本非常老的感觉，淦！-->

<!--居然还在用python2，python2都停更了，但是去官方文档看了下，说ansible2.5以上都支持python3--></li>
<li><p>配置主机清单</p>
<p>Ansible通过读取默认主机清单**/etc/ansible/hosts**文件，修改主机与组配置后，可同时连接到多个被管理主机上执行任务。比如定义一个websrvs组，包含两台主机的IP地址，再定义一个dbsrvs组，包含一个主机的IP地址</p>
<p>所以现在需要另外再准备一台linux来作为被管理的web服务器（克隆即可）</p>
<p>准备好以后查看一下IP地址：<code>ip addr</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318113110186.png" alt="image-20210318113110186">-</p>
<!--为什么要看IP地址呢？因为前面说过，ansible是通过ssh来进行管理，所以需要先进行ssh连接！-->

<p>可以先用ssh连接一下试一下，结果是能连接的，然后开始配置hosts文件：</p>
<p><code>vim /etc/ansible/hosts</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318113400784.png" alt="image-20210318113400784">-</p>
</li>
<li><p>设置SSH无密码登录</p>
<p><strong>设置无密码登录，详细操作可以往前翻，在第二章的远程登录Linux系统</strong></p>
<p>1、生成密钥对：<code>ssh-keygen -t rsa -f /root/.ssh/id_rsa -N &#39;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318114443179.png" alt="image-20210318114443179">-</p>
<!--意思是：在/root/.sshd下面生成生成一个文件名为id_rsa的文件，同时指定使用的算法为rsa，并且没有passphrase-->

<p>2、然后将公钥上传到准备好的web服务器上去：<code>ssh-copy-id root@192.168.2.109</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318114656203.png" alt="image-20210318114656203">-</p>
<p>然后转到web服务器看一下有没有：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318114719826.png" alt="image-20210318114719826">-</p>
<!--结果是显然的！--></li>
</ul>
<!--注意：Ansible自动化运维环境由控制主机与被管理主机组成，由于Ansible是基于SSH协议进行通信的，所以控制主机安装Ansible软件后不需要重启或运行任何程序，被管理主机也不需要安装和运行任何代理程序--></li>
<li><p>ansible的基操</p>
<hr>
<p>Ansible执行的时候根据结果会显示为<strong>绿色（成功执行）</strong>，<strong>黄色（成功伴随状态改变）</strong>和<strong>红色（执行失败）</strong>等颜色，颜色的显示与changed的状态相关联，并可以在ansible.cfg中进行定制颜色的设定。ansible.cfg中缺省有对上述状态的颜色缺省的设定，系统级的颜色设定缺省在 <strong>/etc/ansible/ansible.cfg</strong> 中设定</p>
<p><img src="/2021/08/25/16-07-33/image-20210318174427972.png" alt="image-20210318174427972">-</p>
<hr>
<p>语法格式：<strong>ansible &lt;host-pattern&gt;[-m module_name][-a args]</strong></p>
<p>&lt;host-pattern&gt; 对哪些主机生效，[-m module_name] 要使用的模块，[-a args] 模块特有的参数</p>
<p>例如：ansible webserver-1 -m command -a ‘date’</p>
<p>意思是在webserver-1里面的主机执行date命令</p>
<p><img src="/2021/08/25/16-07-33/image-20210318115254037.png" alt="image-20210318115254037">-</p>
<p>显示组名不合法，下面修改为webserver1，还是通过/etc/ansible/hosts文件修改，修改完后，再次运行：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318115401956.png" alt="image-20210318115401956">-</p>
<p>对于遇到不会的命令的使用，可以查看ansible专属的帮助信息：<code>ansible-doc -h / -help</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318115621197.png" alt="image-20210318115621197">-</p>
<p>例如：-l, –list            List available plugins（列出可用的插件）</p>
<p><img src="/2021/08/25/16-07-33/image-20210318115743026.png" alt="image-20210318115743026">-</p>
<p>可以看到有非常多的插件！</p>
<p>例如：-s, –snippet         Show playbook snippet for specified plugin(s)（描述信息和操作动作）</p>
<p><img src="/2021/08/25/16-07-33/image-20210318115950646.png" alt="image-20210318115950646">-</p>
</li>
<li><p>了解核心模块的使用</p>
<ul>
<li><p><strong>command模块</strong></p>
<p>ansible管理工具使用-m选项来指定使用模块，<strong>默认使用command模块</strong>，即-m选项省略时会运行此模块，用于在被管理主机上运行命令</p>
<p>例如：在被管理主机上执行date命令，显示被管理主机的时间，有三种执行命令的方式</p>
<p>方法一：<code>ansible 192.168.10.1 -m command -a &#39;date&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318120846873.png" alt="image-20210318120846873">-</p>
<p>方法二：<code>ansible webserver1 -m -command -a &#39;date&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318120943391.png" alt="image-20210318120943391">-</p>
<p>方法三：ansible all -m command -a ‘date’</p>
<p><img src="/2021/08/25/16-07-33/image-20210318120955624.png" alt="image-20210318120955624">-</p>
<p>若：省略-m选项，默认运行command模块：<code>ansible all -a &#39;tail -1 /etc/passwd&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318121016588.png" alt="image-20210318121016588">-</p>
</li>
<li><p><strong>cron模块</strong></p>
<p>ansible中的cron模块用于定义任务计划。</p>
<p>其中有两种状态（state)，present表示添加（省略状态时默认使用），absent表示移除</p>
<p><code>ansible webserver1 -m cron -a &#39;minute=&quot;*/1&quot; job=&quot;/bin/echo/ hello&quot; name=&quot;cron_ha&quot;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318121800277.png" alt="image-20210318121800277">-</p>
<p><strong>解释一下：minute=”*/1” 表示每隔一分钟，job=”/bin/echo/ hello” 表示用echo打印出 hello，name=”cron_ha” 表示给这个定时任务取一个名：cron_ha</strong></p>
<p>查看一下定时任务是否添加成功：<code>ansible webserver1 -a &#39;crontab -l&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318121904750.png" alt="image-20210318121904750">-</p>
<p>可以看到添加成功！</p>
<p>删除刚刚添加的那条定时任务：</p>
<p><code>ansible webserver1 -m cron -a &#39;minute=&quot;*/1&quot; job=&quot;/bin/echo/ hello&quot; name=&quot;test cron job&quot; state=absent&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318122149244.png" alt="image-20210318122149244">-</p>
<p>或者直接跟name就行，这里就体现出了name的好处了：</p>
<p><code>ansible webserver1 -m cron -a &#39;name=&quot;cron_ha&quot; state=absent&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318122240229.png" alt="image-20210318122240229">-</p>
</li>
<li><p><strong>user模块</strong></p>
<p>ansible中的user模块<strong>用于创建用户和更改、删除已存在的用户</strong>。其中name选项用来指明创建的用户名称</p>
<p>创建用户：<code>ansible webserver1 -m user -a &#39;name=&quot;ansible_test&quot;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318131218053.png" alt="image-20210318131218053">-</p>
<p>为ansible_test用户设置密码：</p>
<p><code>ansible webserver1 -m user -a &#39;name=&quot;ansible_test&quot; password=&quot;123&quot;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318132544955.png" alt="image-20210318132544955">-</p>
<p>说明直接指定明文密码是不行的必须用hash加密一下：</p>
<p>首先下载expect包：<code>yum install -y expect</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318133402741.png" alt="image-20210318133402741">-</p>
<p>执行mkpasswd生成一个salt值：<code>mkpasswd</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318133417266.png" alt="image-20210318133417266">-</p>
<p>使用python加密密码：</p>
<p><code>python -c &quot;import crypt, getpass, pwd; print crypt.crypt(&#39;123456&#39;, &#39;\$6\$\Z46ctmqT\$&#39;)&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318133653245.png" alt="image-20210318133653245">-</p>
<!--注意python代码后面的\$6\$表示：sha512，紧接着的\Z46ctmqT就是刚刚生成的salt值，前面的123456就是密码-->

<p>然后再次为ansible_test用户设置密码：<code>ansible webserver1 -m user -a &#39;name=&quot;ansible_test&quot; password=&quot;\$6\$\Z46ctmqT​\$uqqgxEqbCcEQA85WP75fmtO.np/IsVrO84TTP53JV80rcNDy7QHL3XKTJePMmJ6Iw/419hZ2y/KWSCN1RrirA0&quot;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318133837005.png" alt="image-20210318133837005">-</p>
<p>没报警告，成功了！可以正常登录！</p>
<p>查看一下ansible_test用户的状态：<code>ansible webserver1 -a &#39;tail -1 /etc/passwd&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318141216429.png" alt="image-20210318141216429">-</p>
<p>注意，修改密码也可以：</p>
<p><code>ansible webserver -m shell -a &#39;echo 123456 | passwd --stdin ansible_test&#39;</code></p>
<p>同样可以使用：<code>state=absent</code> 移除刚刚新建的 ansible_test 用户：</p>
<p><code>ansible webserver1 -m user -a &#39;name=&quot;ansible_test &quot; state=absent&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318134156488.png" alt="image-20210318134156488">-</p>
<p>显示红色，并说明了当前这个用户已经登录，下面退出后，再试一次：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318134253288.png" alt="image-20210318134253288">-</p>
<p>成功了，不能登录了！</p>
</li>
<li><p><strong>group模块</strong></p>
<p>ansible中的group模块用于<strong>对用户组进行管理</strong></p>
<p>创建一个名为ansible_1的组，并指定组ID，并归到系统组中去：</p>
<p><code>ansible webserver1 -m group -a &#39;name=ansible_1  gid=306 system=yes&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318141824310.png" alt="image-20210318141824310">-</p>
<p>在 /etc/group 中查看一下：<code>ansible webserver1 -a &#39;tail -1 /etc/group&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318142125233.png" alt="image-20210318142125233">-</p>
<p>创建一个组后，再创建一个用户，就可以通过 group=ansible_1  将用户的组设为ansible_1</p>
<p><code>ansible webserver1 -m user -a &#39;name=ansible_user1 uid=1001 system=yes group=ansible_1&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318170239971.png" alt="image-20210318170239971">-</p>
</li>
<li><p><strong>copy模块</strong></p>
<p>ansible中的copy模块用于<strong>实现文件复制和批量下发文件</strong>。基中使用src来定义本地源文件路径，使用dest定义被管理主机文件路径，使用content则是通过指定信息内容来生成目标文件：</p>
<p><code>ansible webserver1 -m copy -a &#39;src=/root/httpd.yaml dest=/root owner=root mode=640&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318171136382.png" alt="image-20210318171136382">-</p>
<p>然后切换到web服务器进行查看：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318171215431.png" alt="image-20210318171215431">-</p>
<p>owner是root，权限也是640，成功！也可以直接查看，不用切换过去：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318172020738.png" alt="image-20210318172020738">-</p>
</li>
<li><p><strong>file模块</strong></p>
<p>ansible中使用file模块来<strong>设置文件属性</strong>。其中使用path指定文件路径，使用src定义源文件路径，使用name或dest来替换创建文件的符号链接</p>
<p><code>ansible webserver1 -m file -a &#39;owner=haha group=root  mode=644 path=/root/httpd.yaml&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318173351275.png" alt="image-20210318173351275">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318173421029.png" alt="image-20210318173421029">-</p>
<p>创建链接文件：</p>
<p><code>ansible webserver1 -m file -a &#39;path=/root/httpd-yaml.link src=/root/httpd.yaml state=link&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318173941627.png" alt="image-20210318173941627">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318174014270.png" alt="image-20210318174014270">-</p>
</li>
<li><p><strong>ping模块</strong></p>
<p>在ansible中使用ping模块来检测指定主机的连通性：<code>ansible webserver1 -m ping</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318174131744.png" alt="image-20210318174131744">-</p>
<!--ping模块，用于确认和对象机器之间是否能够ping通，正常情况会返回pong--></li>
<li><p><strong>service模块</strong></p>
<p>在Ansible中使用service模块来<strong>控制管理服务的运行状态</strong>。</p>
<p>使用enabled表示<strong>是否开机自启</strong>，取值为true或false;</p>
<p>使用name定义<strong>服务名称</strong>；</p>
<p>使用state指定<strong>服务状态</strong>，取值分别为：reloaded, restarted, started, stopped</p>
<p>下面先查看一下web服务器中的named的状态：</p>
<p><code>ansible webserver1 -a &#39;systemctl status named&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318175150143.png" alt="image-20210318175150143">-</p>
<p>是启动状态！下面将其设置为开机自启，并且停掉它！</p>
<p><code>ansible webserver1 -m service -a &#39;enabled=true name=named state=stopped&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318175225177.png" alt="image-20210318175225177">-</p>
<p>再次查看 named 的状态：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318175422433.png" alt="image-20210318175422433">-</p>
<p>可以看到是红色的，被停掉了！</p>
</li>
<li><p><strong>script模块</strong></p>
<p>ansible中的script模块可以<strong>将本地脚本复制到被管理主机上进行运行</strong>。需要注意的是，使用相对路径来指定脚本</p>
<p>在web服务器上执行本机中的脚本代码：ansible webserver1 -m script -a ‘’</p>
<p><img src="/2021/08/25/16-07-33/image-20210318180003847.png" alt="image-20210318180003847">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210318175948188.png" alt="image-20210318175948188">-</p>
</li>
<li><p><strong>shell模块</strong></p>
<p>ansible中的shell模块可以<strong>在被管理主机上运行命令</strong>，并支持像管道符等功能的复杂命令</p>
<p>例如执行这句代码：<code>ip maddr | grep ens | awk &#39;NR==2&#123;print $1&#125;&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318194135208.png" alt="image-20210318194135208">-</p>
</li>
<li><p><strong>yum模块</strong></p>
<p>ansible中的yum模块负载<strong>在被管理主机上安装与卸载软件包</strong>，但是需要提前在每个节点配置自己的yum仓库。基中使用name指定要安装的软件包，还需要带上软件包的版本号，否则安装最新的软件包；</p>
<p>使用state指定安装软件的状态，present、latest用来表示安装，absent表示卸载</p>
<p><code>ansible webserver1 -m yum -a &#39;name=vim&#39;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318194548532.png" alt="image-20210318194548532">-</p>
<p>安装成功！</p>
</li>
<li><p><strong>setup模块</strong></p>
<p>在ansible中使用 setup 模块收集、查看被管理主机的 facts ( facts是Ansible采集被管理主机设备信息的一个功能 ）。每个被管理主机在接收并运行管理从之前，都会将自己的相关信息（ 操作系统版本、IP地址等 ）发送给控制主机</p>
<p><code>ansible all -m setup</code> 会打印出所有的信息</p>
<p><img src="/2021/08/25/16-07-33/image-20210318195001548.png" alt="image-20210318195001548">-</p>
<p>所有这里需要filter，用法：<code>ansible all -m setup -a &quot;filter=ansible_processor&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210318195113535.png" alt="image-20210318195113535">-</p>
<p>就可以过滤出想看的内容了</p>
</li>
</ul>
</li>
<li><p>主机清单（inventory）</p>
<p>Ansible为了更加便 捷地管理主机，在主机清单中将被管理主机进行分组命名，默认的主机清单为/etc/ansible/hosts文件。主机清单可以设置为多个，也可以通过Dynamic Inventory动态生成。</p>
<p>Inventory文件以中括号的字符标识为组名，将主机分组管理，也可以将同一主机同时划分到多个不同的组中。如果被管理主机使用非默认的ssh端口，还可以在主机名之后用冒号加端口号的方式进行标明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   - Comments begin with the <span class="string">&#x27;#&#x27;</span> character</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Blank lines are ignored</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - Groups of hosts are delimited by [header] elements</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - You can enter hostnames or ip addresses</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   - A hostname/ip can be a member of multiple groups</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>主机变量</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210318200601287.png" alt="image-20210318200601287">-</p>
</li>
<li><p><strong>组变量</strong></p>
<p>这个webserver1就是<strong>组变量</strong></p>
<p><img src="/2021/08/25/16-07-33/image-20210318200349779.png" alt="image-20210318200349779">-</p>
</li>
<li><p><strong>组嵌套</strong></p>
<p>在Inventory中的组还可以嵌套其他的组，也可以向组中的主机指定变量。不过这些变量只能在ansible-playbook工具中使用，直接使用Ansible工具并不支持</p>
</li>
<li><p><strong>Iventory参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ansible_ssh_host</strong></td>
<td>定义hosts ssh地址</td>
</tr>
<tr>
<td><strong>ansible_ssh_port</strong></td>
<td>定义hosts ssh端口</td>
</tr>
<tr>
<td><strong>ansible_ssh_user</strong></td>
<td>定义hosts ssh认证用户</td>
</tr>
<tr>
<td><strong>ansible_ssh_pass</strong></td>
<td>定义hosts ssh认证密码，明文密码不安全</td>
</tr>
<tr>
<td><strong>ansible_sudo</strong></td>
<td>定义hosts sudo用户</td>
</tr>
<tr>
<td><strong>ansible_sudo_pass</strong></td>
<td>定义hosts sudo密码</td>
</tr>
<tr>
<td><strong>ansible_sudo_exe</strong></td>
<td>定义host sudo路径</td>
</tr>
<tr>
<td><strong>ansible_connection</strong></td>
<td>定义hosts连接方式，如ssh,local,paramiko</td>
</tr>
<tr>
<td><strong>ansible_ssh_private_key_file</strong></td>
<td>定义ssh连接的公钥文件</td>
</tr>
<tr>
<td><strong>ansible_shell_type</strong></td>
<td>定义hosts shell类型,默认是sh</td>
</tr>
<tr>
<td><strong>ansible_python_interpreter</strong></td>
<td>定义hosts 任务执行python路径</td>
</tr>
<tr>
<td><strong>ansible_*_interpreter</strong></td>
<td>定义hosts其他语言解析路径</td>
</tr>
</tbody></table>
<p>刚开始登录的时候是使用的ssh免密登录，现在将公钥key删了，试一下密码登录：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318201418992.png" alt="image-20210318201418992">-</p>
<p>设置一下密码和账号：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318203001164.png" alt="image-20210318203001164">-</p>
<p>结果报错了，说不支持：</p>
<p><img src="/2021/08/25/16-07-33/image-20210318201705952.png" alt="image-20210318201705952">-</p>
<p>报错提示说了Host Key checking is enabled ，现在去 <strong>/etc/ansible/ansible.cfg</strong> 里面关一下：</p>
<p>==将 host_key_checking = False 前面的#号去掉即可== </p>
<p><img src="/2021/08/25/16-07-33/image-20210318203028347.png" alt="image-20210318203028347">-</p>
</li>
</ul>
</li>
<li><p><strong>YAML与playbook</strong></p>
<p>YAML是一种用来表达资料序列的格式，由于参考了其他多种语言，所以具有很高的可计性，YAML是YAML Ain’t Markup Language的缩写，即YAML不是XML。不过在研发这种语言时，YAML的意思其实是Yet Another Markup Language(仍是一种标记语言）</p>
<p>官网：<a href="http://www.yaml.org/">http://www.yaml.org</a></p>
<p>特性：</p>
<p>（1）具有良好的可读性，易于实现</p>
<p>（2）表达能力强，扩展性好</p>
<p>（3）和脚本语言的交互性好</p>
<p>（4）有一个一致的信息模型</p>
<p>（5）可以基于流来处理</p>
<p><img src="/2021/08/25/16-07-33/image-20210318203326542.png" alt="image-20210318203326542">-</p>
<p>总结就两个字，恶心！ 不知道为什么我看到这种代码就烦！</p>
<p>超级强格式了可以说！</p>
</li>
<li></li>
</ol>
<h3 id="2、zabbix服务"><a href="#2、zabbix服务" class="headerlink" title="2、zabbix服务"></a>2、zabbix服务</h3><p>1、简介</p>
<p>2、部署</p>
<p>注意，以下操作全是在centos7上进行的</p>
<ol>
<li><p>关闭防火墙和selinux</p>
<p><code>systemctl stop firewalld</code></p>
<p><code>setenforce 0</code></p>
</li>
<li><p>安装apache和php</p>
<p><code>yum install -y httpd php</code></p>
</li>
<li><p>安装zabbix</p>
<p>==记得关selinux 不然启动不了==</p>
<p>注意：需要先更换为<strong>阿里源</strong>，首先下载zabbix的源：</p>
<p><strong>rpm -Uvh <a href="https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm">https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm</a></strong></p>
<p>然后跟换为阿里源：<strong>sed -i ‘s#<a href="http://repo.zabbix.com/#https://mirros.aliyun.com/zabbix#g&#39;">http://repo.zabbix.com#https://mirros.aliyun.com/zabbix#g&#39;</a> zabbix.repo</strong></p>
<!--注意：使用sed替换时，如果替换内容中包含了 / ，原来sed格式中的 / 就需要替换为其它符号，这里替换的为#-->

<p>然后增加两个DNS：<strong>8.8.8.8</strong> 和 <strong>8.8.4.4</strong>，增加完后重启网卡: <code>systemctl restart network</code></p>
<p>然后：<code>yum clean all</code> 、<code>yum makecache</code></p>
<p>然后就可以正常安装：</p>
<p><code>dnf install zabbix-server-mysql zabbix-web-mysql zabbix-apache-conf zabbix-agent</code></p>
</li>
<li><p>启动数据库</p>
<p>若没有数据库管理软件需要先装：<code>yum install -y mariadb</code></p>
<p>然后启动数据库：<code>systemctl start mariadb</code></p>
<p>若第一次安装，还需要设置密码：<code>mysql_secure_installation</code></p>
<p>然后进入数据库：<code>mysql -uroot -p123</code></p>
<p>创建数据库：<code>create database zabbix character set utf8 collate utf8_bin;</code></p>
<p>创建用户：<code>reate user zabbix@localhost identified by &#39;123&#39;;</code></p>
<p>赋予zabbix用户对zabbix数据库的所有权：</p>
<p><code>grant all privileges on zabbix.* to zabbix@localhost;</code></p>
</li>
<li><p>导入数据</p>
<p><code>zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</code></p>
</li>
<li><p>配置zabbix-server</p>
<p>编辑配置文件 /etc/zabbix/zabbix_server.conf，设置密码：DBPassword=123</p>
</li>
<li><p>启动Zabbix server和agent进程</p>
<p><code>systemctl restart zabbix-server zabbix-agent httpd php-fpm</code><br><code>systemctl enable zabbix-server zabbix-agent httpd php-fpm</code></p>
</li>
<li><p>网页安装zabbix</p>
<p>连接到新安装的Zabbix前端： <a href="http://server_ip_or_name/zabbix">http://server_ip_or_name/zabbix</a></p>
<p><img src="/2021/08/25/16-07-33/image-20210319213354814.png" alt="image-20210319213354814"></p>
</li>
</ol>
<p>3、实操</p>
<h2 id="第二十二章-KVM虚拟化"><a href="#第二十二章-KVM虚拟化" class="headerlink" title="第二十二章 KVM虚拟化"></a>第二十二章 KVM虚拟化</h2><p><img src="/2021/08/25/16-07-33/image-20210322100602057.png" alt="image-20210322100602057"></p>
<p>为什么这里放了一张套娃的图片呢？因为我们准备在虚拟机下安装的CentOS中安装VMM，然后再创建新的虚拟机去安装Windows，套娃开始！</p>
<h2 id="第二十三章-版本控制"><a href="#第二十三章-版本控制" class="headerlink" title="第二十三章 版本控制"></a>第二十三章 版本控制</h2><p>1、安装Git：<code>yum install -y git</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307164919208.png" alt="image-20210307164919208">-</p>
<p>图形界面的是：<code>yum install -y gitk</code>，<code>yum install -y qgit</code></p>
<p>2、配置Git：<code>git config + 参数</code></p>
<p>例如，激活颜色选项：<code>git config --global color.ui auto</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170202174.png" alt="image-20210307170202174">-</p>
<p>关闭颜色选项：<code>git config --global color.ui false</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170233108.png" alt="image-20210307170233108">-</p>
<p>配置用户名：<code>git config --global user.name &quot;用户名&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307165912399.png" alt="image-20210307165912399">-</p>
<p>修改用户名：<code>git config --global --repalce-all user.name &quot;新用户名&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170010474.png" alt="image-20210307170010474">-</p>
<p>配置邮箱：<code>git config --global user.email &quot;邮箱&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170128189.png" alt="image-20210307170128189">-</p>
<p>修改邮箱：<code>git config --global --repalce-all user.email &quot;新的邮箱&quot;</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170359345.png" alt="image-20210307170359345">-</p>
<p>使用man查看 git config 的详细操作：<code>man git-config</code></p>
<p><img src="/2021/08/25/16-07-33/image-20210307170621184.png" alt="image-20210307170621184">-</p>
<p>查看 Git 的配置：git config –list</p>
<p><img src="/2021/08/25/16-07-33/image-20210307170735355.png" alt="image-20210307170735355">-</p>
<p>或者直接查看家目录下的.gitconfig 文件：</p>
<p><img src="/2021/08/25/16-07-33/image-20210307170834823.png" alt="image-20210307170834823">-</p>
<p><img src="/2021/08/25/16-07-33/image-20210307170859949.png" alt="image-20210307170859949">-</p>
<p>设置 Git 命令的别名：</p>
<p>例如：<code>git config --global alias.co checkout</code></p>
<p>这句命令生效后，用 git co 就等同于用 git checkout，查看配置文件内容：</p>
<p><img src="/2021/08/25/16-07-33/image-20210307171234281.png" alt="image-20210307171234281">-</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux笔记</tag>
      </tags>
  </entry>
</search>
